<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer刷题-数据结构与算法篇</title>
      <link href="/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><h3 id="1-整数除法"><a href="#1-整数除法" class="headerlink" title="#1 整数除法"></a>#1 整数除法</h3><p>输入两个int型整数，它们进行除法计算并返回商，**要求不得使用乘号*，除号/以及求余符号%**，当发出溢出时，返回最大的整数值。假设除数不为0。例如，输入15和2，输出15/2，即7。（注意：int型范围是-2^31 ~ -2^31-1）</p><p>注意：只基于减法实现是可以的，但是此情况的最坏时间复杂度为O(n)，需要对效率进一步提升。</p><p>细节：</p><ol><li>最小的整数是-2^31, 最大的整数是2^31。因此，如果将负整数直接转换为正整数可能导致溢出。可以先将正整数都转换成负整数，再根据需要调整商的符号。</li><li>直接溢出的情况，被除数为-2^31，除数为-1</li><li>防止被除数在扩大一倍时溢出，所以需要提前判断</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 辅助判断符号,奇数为负，偶数为正</span></span><br><span class="line">        <span class="keyword">int</span> negative = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            negative--;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            negative--;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = divideCore(dividend, divisor);</span><br><span class="line">        <span class="keyword">return</span> negative == <span class="number">1</span> ? -result : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divideCore</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dividend &lt;= divisor) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = divisor;</span><br><span class="line">        <span class="keyword">int</span> quotient = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个判断条件很重要，防止后面value扩大一倍时溢出</span></span><br><span class="line">        <span class="keyword">while</span> (value &gt;= Integer.MAX_VALUE / <span class="number">2</span> &amp;&amp; dividend &lt;= value + value) &#123;</span><br><span class="line">            quotient += quotient;</span><br><span class="line">            value += value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result += quotient;</span><br><span class="line">        dividend -= value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-二进制加法"><a href="#2-二进制加法" class="headerlink" title="#2 二进制加法"></a>#2 二进制加法</h3><p>给定两个表示二进制的字符串，请计算它们的和，并以二进制字符串的形式输出。例如，输入的二进制字符串分别是”11”和”10”，则输出”101”</p><p>注意：不能直接将二进制字符串转换成整数运算，因为并没有限定二进制字符串的长度，可能会造成溢出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a_length = a.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b_length = b.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (a_length &gt;= <span class="number">0</span> || b_length &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> digitA = a_length &gt;= <span class="number">0</span> ? a.charAt(a_length--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digitB = b_length &gt;= <span class="number">0</span> ? b.charAt(b_length--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = digitA + digitB + carry;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">            sum -= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑最后是否存在进位</span></span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">        result.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为存储顺序是从右至左，所以需要逆序输出</span></span><br><span class="line">    <span class="keyword">return</span> result.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-前n个数字二进制形式中1的个数"><a href="#3-前n个数字二进制形式中1的个数" class="headerlink" title="#3 前n个数字二进制形式中1的个数"></a>#3 前n个数字二进制形式中1的个数</h3><p>输入一个非负数n，请计算0到n之间每个数字的二进制形式中1的个数，并输出一个数组。例如，输入的n为4，由于0、1、2、3、4的二进制形式中1的个数分别为0、1、1、2、1，因此输出数组[0,1,1,2,1]。</p><p>简单分析：最直观的解法，就是用for循环来计算从0到n的每个整数i的二进制形式中1的个数。于是问题转换成如何求一个整数i的二进制形式中1的个数。</p><p>思路</p><ol><li><p>根据<code>i&amp;(i-1)</code>计算</p><p>此公式的核心思想是把i最右面的1变成0。可以通过for循环，不断地把最右边的1变成0，变化了几次就说明有几个1。其中页暗藏动态规划的思想，数字i中1的个数比i&amp;(i-1)中1的个数多1。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于思路<span class="number">1</span>实现:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countBits_1(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result[i] = result[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>根据<code>i/2</code>计算</p><p>通过观察发现，如果正整数i是偶数，那么i相当于’i/2’左移一位的结果，因此它们的二进制形式中1的个数是相同的。如果i是奇数，那么i相当于’i/2’左移一位之后，再将最右边一位设成1的结果，因此奇数i的二进制形式中1的个数比’i/2’中的1的个数多1。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于思路<span class="number">2</span>实现:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countBits_2(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// i &amp; 1, i为奇数则结果为1, 偶数为0</span></span><br><span class="line">        result[i] = result[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上述代码用’i &gt;&gt; 1’计算’i/2’，用’i &amp; 1’计算’i%2’，因为位运算比除法运算和求余运算更高效。</p><h3 id="4-只出现一次的数字"><a href="#4-只出现一次的数字" class="headerlink" title="#4 只出现一次的数字"></a>#4 只出现一次的数字</h3><p>输入一个整数数组，书注重只有一个数字出现了一次，而其他数字都出现了3次。请找出那个只出现一次的数字。例如，如果输入的数组为[0,1,0,1,0,1,100]，则只出现一次的数字是100。</p><p>思路：一个整数是由32个0或1组成的。我们可以将数组中所有数字的同一位置的数位相加。因此，<strong>如果数组中所有数字的第i个数位相加之和能被3整除，那么只出现一次的数字的第i个位数一定是0；如果数组中所有数字的第i个数位相加之和被3除余1，那么只出现一次的数字的第i个数位一定是1。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代表整数的长度为32bit</span></span><br><span class="line">    <span class="keyword">int</span>[] bitSums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把数组中所有数字按对应的bit位累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            bitSums[i] += (num &gt;&gt; (<span class="number">31</span> - i)) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断累加后对应的bit位能否被三整除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        result = (result &lt;&lt; <span class="number">1</span>) + bitSums[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举一反三：</strong>如果数组中只有一个数字出现m次，其他数字都出现n次，m不能被n整除，找出唯一出现m次的数字。</p><p>用同样的思路解决此问题，最后验证累加后的整数对应bit位能否被m整除。</p><h3 id="5-单词长度的最大乘积"><a href="#5-单词长度的最大乘积" class="headerlink" title="#5 单词长度的最大乘积"></a>#5 单词长度的最大乘积</h3><p>给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p><p>例如：输入的字符串数组words为[“abcw”,”foo”,”bar”,”fxyz”,”abcdef”], 最后返回的应该是16。</p><p>思路1：</p><p>假设两字符串长度分别为p,q。</p><ol><li>最直观的解法就是蛮力法。如果蛮力法比较两个字符串是否有相等字符，比较的时间复杂度为O(pq)。</li><li>通过哈希表来优化时间效率。对于每个字符串，用一个哈希表记录该字符串中的所有字符。因为题目假设的所有字符都是英文小写字母，只有26个可能的字符，因此最多只需要在每个字符串对应的哈希表中查询26次就能判断两个字符串是否包含相同的字符，因此比较的时间复杂度为O(1)。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct_1</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[words.length][<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 生成哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">            flags[i][c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 判断word i 和 word j是否有相同的字符</span></span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flags[i][k] == <span class="keyword">true</span> &amp;&amp; flags[j][k] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// k = 26说明没有相同字符</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> prod = words[i].length() * words[j].length();</span><br><span class="line">                result = Math.max(result, prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>进一步分析此方法的时间和空间复杂度。</p><p>第一步，初始化每个字符串对应的哈希表。如果words的长度为n，凭均每个字符串的长度为k，那么初始化哈希表的时间复杂度为O(nk)。</p><p>第二步，根据哈希表判断每对字符串是否包含相同的字符。总共有O(n^2)对字符串，每次判断需要的时间为O(1)，因此这一步的时间复杂度为O(n^2)。</p><p><strong>于是这种解法的整体时间复杂度为O(nk + n^2)。</strong></p><p>为每一个字符串创建一个数组，所以<strong>空间复杂度为O(n)</strong></p></li></ol><p>思路2：用整数的二进制数位记录字符串中出现的字符</p><p>前面的解法是用一个长度为26的布尔型数组记录字符串中出现的字符。布尔值只有两种可能，true or false。这与二进制有些类似。因此，可以将长度为26的布尔型数组用26个二进制的数位代替，二进制的0对应布尔值的false，1对应true。</p><p>26bit就足以表示一个字符串中可能出现的字符，所以我们可以用int(32bit)来表示。<strong>用二进制数位表示的好处是可以更快地判断两个字符串是否包含相同的字符。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct_2</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] flags = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : words[i].toCharArray()) &#123;</span><br><span class="line">            flags[i] |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 说明两个字符串没有相同的字符</span></span><br><span class="line">            <span class="keyword">if</span> ((flags[i] &amp; flags[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> prod = words[i].length() * words[j].length();</span><br><span class="line">                result = Math.max(result, prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>与思路1时间空间复杂度均相同。</p><p>但是在比较是否存在相等字符时，只需要一次运算即可。而思路1中可能需要26次布尔运算，所以<strong>新的解法时间效率更高</strong>。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="#双指针"></a>#双指针</h3><p>方向相反的双指针经常用来求排序数组中的两个数字之和。</p><p>方向相同的双指针通常用来求正数数组中子数组的和或乘积。</p><h3 id="6-排序数组中的两个数字之和"><a href="#6-排序数组中的两个数字之和" class="headerlink" title="#6 排序数组中的两个数字之和"></a>#6 排序数组中的两个数字之和</h3><p>考点 <code>双指针</code></p><p>输入一个递增序列的数组和一个值k，请问如何在数组中找出两个和为k的数字并返回它们的下标？假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。</p><p>例如：输入数组[1,2,4,6,10], k的值为8，应该返回[1,3]</p><p>分析：</p><ol><li><p>最直观的暴力解法，固定数组中的一个数字，然后判断数组中其余数字与他的和是不是等于k。可以看成是用两个for循环遍历数组，<strong>时间复杂度为O(n^2)</strong></p></li><li><p>上述解法可以用二分查找优化。还是先固定一个数字i，然后用二分查找寻找k-i。时间复杂度为O(nlogn)。</p></li><li><p>上述解法还可以用空间换时间进行优化。可以先将数组中所有的数字都放入一个哈希表，然后逐一扫描数组中的每个数字。扫描i, 就在哈希表里找k-i。判断哈希表中是否存在一个数字的时间复杂度为O(1)，因此新解法的**时间复杂度为O(n)<strong>。同时它需要一个大小为O(n)的哈希表，因此</strong>空间复杂度也是O(n)**。</p></li><li><p>存在时间复杂度是O(n)，空间复杂度是O(1)的解法，就是我们最后要引出的<code>双指针</code>。</p><p>两个指针一个从前向后移动，一个从后向前移动。如果小于target前指针后移，如果大于target后指针前移。如果相等则返回指针对应的索引。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// 双指针，一个从前向后移动，一个从后向前移动</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = numbers.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] != target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] + numbers[j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-数组中和为0的3个数字"><a href="#7-数组中和为0的3个数字" class="headerlink" title="#7 数组中和为0的3个数字"></a>#7 数组中和为0的3个数字</h3><p>输入一个数组，如何找出数组中所有和为0的3个数字的三元组？需要注意的是，返回值中不得包含重复的三元组。</p><p>例如：在数组[-1,0,1,2,-1,-4]中有两个三元组的和为0，它们分别是[-1,0,1]和[-1,-1,2]。</p><p>分析：</p><p>这是上一题的加强版。如果输入的数组是排序的，我们就可以先固定一个数字i，然后再排序数组中查找和为-i的两个数字。我们已经有了用O(n)时间在排序数组中找出和为给定值的两个数字的方法，由于需要固定数组中的每个数字，因此查找此三元组的时间复杂度是O(n^2)。</p><p>但是这个题目并没有说给出的数组是排序的，因此需要先对数组排序。排序算法的时间复杂度通常是O(nlogn)，因此这种解法的总时间复杂度是O(logn + n^2), <strong>最后还是O(n^2)</strong></p><p>最后要注意去除重复的三元组。在指针移动时跳过所有相同的值即可。需要跳过相同值的地方共有两处，第一处是固定i的时候，第二处是双指针移动的时候。移动前指针和后指针都可以，移动的那个指针要考虑跳过重复值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length - <span class="number">2</span>) &#123;</span><br><span class="line">            twoSum(nums, i, result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过重复的数字</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">while</span> (nums[i] == temp &amp;&amp; i &lt; nums.length - <span class="number">2</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class="line">    <span class="comment">// 双指针，一个从前向后移动，一个从后向前移动</span></span><br><span class="line">    <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过重复的数字</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">            <span class="keyword">while</span> (nums[j] == temp &amp;&amp; j &lt; k) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-和大于或等于k的最短子数组"><a href="#8-和大于或等于k的最短子数组" class="headerlink" title="#8 和大于或等于k的最短子数组"></a>#8 和大于或等于k的最短子数组</h3><p>输入一个正整数组成的数组和一个正整数k，请问数组中和大于或等于k的连续子数组的最短长度是多少？如果不存在所有数字之和大于或等于k的子数组，则返回0。</p><p>例如：输入数组[5,1,4,3]，k的值为7，最后输出2。</p><p>考点 <code>双指针</code></p><p>分析：</p><p>用两个指针P1，P2来锁定子数组，子数组由两个指针之间所有数字组成。</p><p>初始化时两指针都指向数组的第一个元素。</p><p>如果子数组和大于等于k，则P1右移，相当于从子数组的最左边删除一个数字，子数组长度减1。如果子数组和小于k，则P1右移，相当于在子数组的最右边添加一个新的数字，子数组长度加1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; right &lt; nums.length; right++) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>尽管代码中有两个嵌套的循环，但是**时间复杂度仍然是O(n)**。因为left和right都只加不减，变化范围都是[0~n-1]。</p><h3 id="9-乘积小于k的子数组"><a href="#9-乘积小于k的子数组" class="headerlink" title="#9 乘积小于k的子数组"></a>#9 乘积小于k的子数组</h3><p>输入一个由正整数组成的数组和一个正整数k，请问数组中有多少个数字乘积小于k的连续子数组？</p><p>例如：输入数组[10,5,2,6]，k的值为100，有8个子数组的所有数字的乘积小于100。</p><p>考点 <code>双指针</code></p><p>分析：</p><p>与上一题思路类似，用双指针P1，P2锁定子数组，如果子数组中所有数字的乘积小于k，那么右移P2；反之则右移P1。当指针P1到某个位置时子数组的乘积小于k，就不需要再向右移动指针P1。因为只要保持指针P2不动，向右移动指针P1形成的所有子数组的数字乘积就一定小于k。<strong>此时两个指针之间有多少个数字，就找到了多少个数字乘积小于k的子数组。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; right &lt; nums.length; right++) &#123;</span><br><span class="line">        product *= nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; product &gt;= k) &#123;</span><br><span class="line">            product /= nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        result += right &gt;= left ? right - left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>和上一题同理，<strong>时间复杂度为O(n)</strong></p><h3 id="累加数组数字求子数组之和"><a href="#累加数组数字求子数组之和" class="headerlink" title="#累加数组数字求子数组之和"></a>#累加数组数字求子数组之和</h3><p>使用双指针解决子数组之和问题有一个前提条件：数组中的所有数字都是正数。如果数组中有正数、负数和零，那么双指针的思路并不适用。因为当数组中有负数时在子数组中添加数字不一定能增加子数组之和，从子数组中删除数字也不一定能减少子数组之和。</p><p>所以引出求子数组和的另一种思路：<code>累加数组数字</code></p><p>首先需要预处理。假设数组长度为n，从头到尾扫描一次，就能求出从下标0开始到下标0结束的所有子数组之和S_0，从下标0开始到下标1结束的子数组之和S_1，以此类推，直到求出从下标0开始到最后一个数字的子数组之和S_n-1。因此，<strong>从下标为i开始到下标为j结束的子数组的和就是S_j - S_i-1</strong>。</p><h3 id="10-和为k的子数组"><a href="#10-和为k的子数组" class="headerlink" title="#10 和为k的子数组"></a>#10 和为k的子数组</h3><p>输入一个整数数组和一个整数k，请问数组中有多少个数字之和等于k的连续子数组？</p><p>例如：输入数组[1,1,1]，k的值为2，有2个连续子数组之和等于2。</p><p>分析：</p><p>最先想到暴力解法。在一个长度为n的数组中有O(n^2)个子数组，如果求出每个子数组的和需要O(n)的时间，那么总共需要O(n^3)的时间就能求出所有子数组的和。</p><p>对暴力解法进一步优化。在计算长度为i的子数组数字之和时，应该把子数组堪称长度为i-1的子数组的基础上添加一个新的数字。因此，如果已经求出了长度为i-1的子数组的数字之和，那么只要再加上新添加的数字就能得出长度为i的子数组的数字之和。因为只需要1次加法，需要O(1)时间，优化后的时间复杂度为O(n^2)。</p><p>再换一种思路，我们从头到尾扫描数组中的数字时求出前i个数字之和，并将结果保存下来。当扫描到数组的第i个数字时并求得前i个数字之和是x时，需要知道在i之前存在多少个j，满足前j个数字之和等于x-k。<strong>所以，对于每个i，不但要保存前i个数字之和，还要保存每个和出现的次数。</strong> 分析到这儿就知道我们需要一个哈希表，键是前i个数字之和，值是每个和出现的次数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; sumToCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刚开始累加和为0</span></span><br><span class="line">    sumToCount.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        result += sumToCount.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">        sumToCount.put(sum, sumToCount.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>只需要从头至尾扫描数组一次，所以**时间复杂度为O(n)<strong>。需要一个哈希表保存前i个数字的和及出现的次数，所以</strong>空间复杂度为O(n)**。</p><h3 id="11-0和1个数相同的子数组"><a href="#11-0和1个数相同的子数组" class="headerlink" title="#11 0和1个数相同的子数组"></a>#11 0和1个数相同的子数组</h3><p>输入一个只包含0和1的数组，请问如何求0和1个数相同的最长连续子数组的长度？</p><p>例如：在数组[0,1,0]中有两个子数组包含相同个数的0和1，分别是[0,1]和[1,0]，他们的长度都是2，因此输出2。</p><p>分析：</p><p><strong>如果题目中所有的0都变成-1，那么01个数相同的子数组和必为1。这样此题就转换成了一个求和为k的子数组的问题。</strong>想要完成这样的转换也很简单，只需要在每次累加时，判断当前数字时否为0，如果为0则累加-1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; sumToIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果累加和为0，说明01数量已经相等，长度=索引+1</span></span><br><span class="line">    sumToIndex.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i] == <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sumToIndex.containsKey(sum)) &#123;</span><br><span class="line">            result = Math.max(result, i - sumToIndex.get(sum));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sumToIndex.put(sum, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>与求和为k的子数组同理，<strong>时间复杂度空间复杂度都为O(n)</strong></p><h3 id="12-左右两边子数组的和相等"><a href="#12-左右两边子数组的和相等" class="headerlink" title="#12 左右两边子数组的和相等"></a>#12 左右两边子数组的和相等</h3><p>输入一个整数数组，如果一个数字左边的子数组的数字之和等于右边的子数组的数字之和，那么返回该数字的下标。如果存在多个这样的数字，则返回最左边一个数字的下标。如果不存在这样的数字，则返回-1。</p><p>例如：在数组[1,7,3,6,2,9]中，下标为3的数字左右两边子数组之和相等，因此应该输出3。</p><p>分析：</p><p>当扫描到第i个数字时，可以算出前i个数字的累加和。此时，i左边子数组的和等于前i个数字的和减i，i右边子数组的和等于整个数组的和total减前i个数字的累加和。所以此题还得求整个数组的累加和total。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pivotIntex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; nums.length; i++) &#123;</span><br><span class="line">        total += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum - nums[i] == total - sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>共有两个时间复杂度为O(n)的循环，因此**时间复杂度为O(n)<strong>。并没有使用数组、哈希表等辅助数据容器，因此</strong>空间复杂度为O(1)**。</p><h3 id="13-二维子矩阵的数字之和"><a href="#13-二维子矩阵的数字之和" class="headerlink" title="#13 二维子矩阵的数字之和"></a>#13 二维子矩阵的数字之和</h3><p>输入一个二维矩阵，如何计算给定左上角坐标和右下角坐标的子矩阵的数字之和？对于同一个二维矩阵，计算子矩阵的数字之和的函数可能由于输入不同的坐标而被反复调用多次。</p><p>例如：输入如下矩阵和坐标(2,1),(4,3)，应该返回8</p><p>[[3,0,1,4,2],</p><p>[5,6,3,2,1],</p><p>[1,2,0,1,5],</p><p>[4,1,0,1,7],</p><p>[1,0,3,0,5]]    </p><p>分析：</p><p>如果不考虑时间复杂度，采用蛮力法用两个嵌套的循环总是可以求出一个二维矩阵的数字之和。如果矩阵的行数和列数分别是m和n，那么这种蛮力法的时间复杂度是O(mn)。但是由于题目提到，计算函数可能被反复调用多次，因此应该优化求和的过程，尽快地实现子矩阵求和函数。</p><p>我们用[(r1,c1)(r2,c2)]来表示左上角坐标为(r1,c1)，右下角坐标为(r2,c2)的子矩阵的数字之和。通过观察发现，此矩阵的数字之和可以用4个左上角坐标为(0,0)的子矩阵的数字之和求得。[(r1,c1)(r2,c2)] = [(0,0)(r2,c2)] - [(0,0)(r2,c1-1)] - [(0,0)(r1-1,c2)] + [(0,0)(r1-1,c1-1)]。</p><p>再进一步思考，只要在预处理阶段求出(0,0)到每个右下角坐标的子矩阵的数字之和，然后存到一个辅助矩阵中，目标子矩阵的数字之和就可以在常数时间内计算完毕。 </p><p>那要怎么计算子矩阵呢？可以把[(0,0),(i,j)]看成两部分。第一部分是[(0,0),(i-1,j)],第二部分是矩阵中第i行中列号从0到j的所有数字。<strong>为了计算方便，可以在初始化时创建一个比原数组行列多1的辅助矩阵。这样在计算辅助矩阵的第一行时也可以在循环中进行。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] NumMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] sums = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length+<span class="number">1</span>][matrix[<span class="number">0</span>].length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> rowSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            rowSum += matrix[i][j];</span><br><span class="line">            sums[i+<span class="number">1</span>][j+<span class="number">1</span>] = sums[i][j+<span class="number">1</span>] + rowSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> sums[][], <span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sums[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] </span><br><span class="line">        - sums[row1][col2 + <span class="number">1</span>] </span><br><span class="line">        - sums[row2 + <span class="number">1</span>][col1] </span><br><span class="line">        + sums[row1][col1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>用两个嵌套的for循环计算辅助矩阵，时间复杂度为O(mn)。同时，辅助矩阵需要的空间也为O(mn)。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>java中String类型所表达的字符串时无法改变的。如果对字符串进行写操作，那么修改的内容在返回值的字符串中，原来的字符串保持不变。</p><p>由于每次对String实例进行修改将创建一个新的String实例，因此如果连续多次对String实例进行修改将连续创建多个新的String实例，不必要的内存开销较大。所以可以借助StringBuilder或StringBuffer(线程安全效率低)来容纳修改后的结果。</p><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="#双指针"></a>#双指针</h3><p>如果将字符串看成一个由字符串组成的数组，那么也可以用两个指针来定位一个子字符串。</p><p>可以在移动这两个指针的同时，统计两个指针之间的字符串中字符出现的次数，这样可以解决很多常见的面试题，如定位变位词等。</p><p>由于这种类型的面试题都与统计字母出现的次数有关，我们经常使用哈希表来存储每个元素出现的次数，因此解决这种类型的面试题通常需要同时使用<strong>双指针和哈希表</strong>。</p><h3 id="14-字符串中的变位词"><a href="#14-字符串中的变位词" class="headerlink" title="#14 字符串中的变位词"></a>#14 字符串中的变位词</h3><p>输入字符串s1和s2，如何判断字符串s2中是否包含字符串s1的某个变位词？如果字符串s2中包含字符串s1的某个变位词，则字符串s1至少有一个变位词是字符串s2的子字符串。假设两个字符串中只包含英文小写字母。</p><p>例如：</p><ol><li>字符串s1为”ac”, s2为”dgcaf”, 输出true</li><li>字符串s1为”ab”, s2为”dgcaf”, 输出false</li></ol><p>分析：</p><p>还是最先想到暴力法。可以先求出字符串s1的所有排列，然后判断每个排列是不是字符串s2的子字符串。如果一个字符串有n个字符，那么它一共有n!个排列，因此这种解法的时间复杂度不会低于O(n!)。</p><p>下面尝试更高效的解法。我们可以以用一个哈希表来存储每个字符出现的次数。首先扫描s1，每扫描到一个字符，就找到它在哈希表中的位置并把对应的值加1。然后考虑s2中是否有s1的变位词。假设字符串s2中有一个子字符串是s1的变位词，逐个扫描这个变位词中的字母，并把字母在哈希表中对应的值减1。<strong>如果同位词存在，最后操作完，哈希表中所有的值应该都是0。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s2.length() &lt; s1.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 先判断第一组和s1等长的子字符串是否是其变位词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i 为第一个指针的索引， i - s1.length() + 1为第二个指针的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s1.length(); i &lt; s2.length(); i++) &#123;</span><br><span class="line">            counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            counts[s2.charAt(i - s1.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areAllZero</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：需要扫描字符串s1和s2各一次，如果他们的长度分别是m和n，那么**时间复杂度是O(m+n)<strong>。这种解法用到了一个长度为26的数组，是一个常数，所以</strong>空间复杂度是O(1)**。</p><h3 id="15-字符串中所有的变位词"><a href="#15-字符串中所有的变位词" class="headerlink" title="#15 字符串中所有的变位词"></a>#15 字符串中所有的变位词</h3><p>输入字符串s1和s2，如何找出字符串s2的所有变位词在字符串s1中的起始下标？假设两个字符串中只包含英文小写字母。</p><p>例如：字符串s1为”cbadabacg”, 字符串s2为”abc”，应该输出0和5。</p><p>分析：就是上一题的变种。在成功找到变位词时返回对应子字符串第一个字符的索引即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; indices = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s1.length() &lt; s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 方便添加进列表</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先判断第一组子字符串</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s2.length(); i++) &#123;</span><br><span class="line">        counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">        indices.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = s2.length(); i &lt; s1.length(); i++) &#123;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        counts[s1.charAt(i - s2.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">            <span class="comment">// 注意: 前一个指针的索引是 i - s2.length() + 1</span></span><br><span class="line">            indices.add(i - s2.length() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areAllZero</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：与上一题同理，<strong>时间复杂度为O(n)</strong>, **空间复杂度为O(1)**。</p><h3 id="16-不含重复字符的最长子字符串"><a href="#16-不含重复字符的最长子字符串" class="headerlink" title="#16 不含重复字符的最长子字符串"></a>#16 不含重复字符的最长子字符串</h3><p>输入一个字符串，求该字符串中不含重复字符的最长子字符串的长度。</p><p>例如：输入字符串”babcca”，其最长的不含重复字符的子字符串是”abc”，长度为3。</p><p>分析：</p><p>用左右两个指针锁定子字符串，用哈希表存放字符出现的次数。如果两指针之间的子字符串不包含重复字符，则向前移动右指针，否则向前移动左指针。两指针初始化时都在起始位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ASCII码一共256个字符</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 用字符标识索引时，字符会自动转换成对应的ASCII码</span></span><br><span class="line">        counts[s.charAt(i)]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hasGreaterThan1(counts)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            counts[s.charAt(j)]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的j并不是左指针的位置，而是左指针前面的位置，所以不需要i-j+1</span></span><br><span class="line">        longest = Math.max(longest, i - j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasGreaterThan1</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步分析：</p><p>每次移动指针的时候都要扫描一次哈希表，虽然哈希表的长度固定，但是这个常数还是有点大。所以最好能有一个不需要多次遍历整个哈希表的解法。</p><p>其实我们真正关心的是哈希表中有没有比1大的数字，因为如果有大于的数字就说明子数组中包含重复的数字。可以定义一个变量countDup来存储哈希表中大于1的数字的个数**(其实这个值最大就是1，用boolean变量存也可以)**。当移动右指针导致哈希表中某个数字从1变成2时，变量countDup加1。当移动左指针导致哈希表中某个数字从2变成1时，变量countDup减1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ASCII码一共256个字符</span></span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> countDup = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 用字符标识索引时，字符会自动转换成对应的ASCII码</span></span><br><span class="line">            counts[s.charAt(i)]++;</span><br><span class="line">            <span class="keyword">if</span> (counts[s.charAt(i)] == <span class="number">2</span>) &#123;</span><br><span class="line">                countDup++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (countDup &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                counts[s.charAt(j)]--;</span><br><span class="line">                <span class="comment">// 检查是否有数字从2变成1</span></span><br><span class="line">                <span class="keyword">if</span> (counts[s.charAt(j)] == <span class="number">1</span>) &#123;</span><br><span class="line">                    countDup--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里的j并不是左指针的位置，而是左指针前面的位置，所以不需要i-j+1</span></span><br><span class="line">            longest = Math.max(longest, i - j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="17-包含所有字符串的最短字符串"><a href="#17-包含所有字符串的最短字符串" class="headerlink" title="#17 包含所有字符串的最短字符串"></a>#17 包含所有字符串的最短字符串</h3><p>输入两个字符串s和t，请找出字符串s中包含字符串t的所有字符的最短子字符串。</p><p>例如：输入的字符串s为”ADDBANCAD”，字符串t为”ABC”，则字符串s中包含字符’A’, ‘B’, ‘C’的最短子字符串是”BANC”。如果不存在符合条件的子字符串，则返回空字符串””。如果存在多个符合条件的子字符串，则返回任意一个。</p><p>分析：</p><p>用两个指针定位子字符串。如果某一时刻两个指针之间之间的子字符串还没有包含字符串t的所有字符，则在子字符串中添加新的字，于是向右移动第二个指针。如果已经包含字符串t的所有字符，则向右移动第一个指针。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; charToCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : t.toCharArray()) &#123;</span><br><span class="line">        charToCount.put(ch, charToCount.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当count等于0时，两指针之间的子字符串就包含t中的所有字符</span></span><br><span class="line">    <span class="keyword">int</span> count = charToCount.size();</span><br><span class="line">    <span class="comment">// start, end分别为两个指针</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, minStart = <span class="number">0</span>, minEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; s.length() || (count == <span class="number">0</span> &amp;&amp; end == s.length())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">// end &lt; s.length()</span></span><br><span class="line">            <span class="keyword">char</span> endCh = s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span> (charToCount.containsKey(endCh)) &#123;</span><br><span class="line">                charToCount.put(endCh, charToCount.get(endCh) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (charToCount.get(endCh) == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向右移动第二个指针</span></span><br><span class="line">            end++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// count == 0 &amp;&amp; end == s.length()</span></span><br><span class="line">            <span class="keyword">if</span> (end - start &lt; minLength) &#123;</span><br><span class="line">                minLength = end - start;</span><br><span class="line">                minStart = start;</span><br><span class="line">                minEnd = end;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> startCh = s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (charToCount.containsKey(startCh)) &#123;</span><br><span class="line">                charToCount.put(startCh, charToCount.get(startCh) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (charToCount.get(startCh) == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向右移动第一个指针</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minLength &lt; Integer.MAX_VALUE ? s.substring(minStart, minEnd) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>只有一个while循环，把两个变量从0增加到字符串s的长度。所以**时间复杂度为O(n)<strong>。哈希表的键为字符，假设字符串中只有英文字母，所以哈希表的大小不会超过256。因此</strong>空间复杂度为O(1)**。</p><h3 id="18-有效的回文"><a href="#18-有效的回文" class="headerlink" title="#18 有效的回文"></a>#18 有效的回文</h3><p>给定一个字符串，请判断它是不是回文。假设只需考虑字母和数字字符，并忽略大小写。</p><p>例如：”Was it a cat I saw”是一个回文字符串，而”race a car”不是回文字符串。</p><p>分析：</p><p>可以用双指针，一个从前向后移动，另一个从后向前移动。如果两指针指向的字符相同，则继续移动，直到两个指针相遇。<strong>注意：题目只考虑字母和数字字符，所以如果指针指向的字符既不是字母也不是数字，则跳过该字符。同时，由于忽略大小写，所以要把所有字母转换成相同的形式再做比较。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = s.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> ch2 = s.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (!Character.isLetterOrDigit(ch1)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isLetterOrDigit(ch2)) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ch1 = Character.toLowerCase(ch1);</span><br><span class="line">            ch2 = Character.toLowerCase(ch2);</span><br><span class="line">            <span class="keyword">if</span> (ch1 != ch2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在改变字母大小写时，建议操作字符而不是字符串。因为java中字符串不可变，修改字符串会创建新的字符串，造成内存浪费。</p><p>复杂度分析：</p><p>两个指针遍历字符串，**时间复杂度为O(n)**。</p><h3 id="19-最多删除一个字符得到回文"><a href="#19-最多删除一个字符得到回文" class="headerlink" title="#19 最多删除一个字符得到回文"></a>#19 最多删除一个字符得到回文</h3><p>给定一个字符串，请判断如果最多从字符串中删除一个字符能不能得到一个回文字符串。</p><p>例如：如果输入字符串”abca”，由于删除字符串’b’或’c’就能得到一个回文字符串，因此输出为true。</p><p>分析：</p><p>与上一题类似，还是用双指针从两侧开始向里逐步比较。如果字符相同，则继续比较。如果字符不同，则按题目要求，删除一个字符后比较剩下的字符。因为不知道删除两个不同字符中的哪一个，因此都可以进行尝试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当start == s.length() / 2说明是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(; start &lt; s.length() / <span class="number">2</span>; start++, end--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start) != s.charAt(end)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> start == s.length() / <span class="number">2</span></span><br><span class="line">                || isPalindrome(s, start, end - <span class="number">1</span>)</span><br><span class="line">                || isPalindrome(s, start + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) != s.charAt(end)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start &gt;= end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：最坏情况，从左右两端第一个字符开始就出现分歧，需要判断删除的情况。此时需要遍历字符串两遍，**时间复杂度O(n)**。</p><h3 id="20-回文子字符串的个数"><a href="#20-回文子字符串的个数" class="headerlink" title="#20 回文子字符串的个数"></a>#20 回文子字符串的个数</h3><p>给定一个字符串，请问该字符串中有多少个回文连续子字符串？</p><p>例如：字符串”aaa”有6个回文子字符串，分别为”a”, “a”, “a”, “aa”, “aa” 和 “aaa”。</p><p>分析：</p><p>同样用双指针来求解，但是思路略有不同。我们考虑从字符串的中心开始向两端延申。<strong>注意：回文的长度可以是奇数也可以是偶数。长度为奇数的回文对称中心只有一个字符，而长度为偶数的回文对称中心有两个字符。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        count+= countPalindrome(s, i, i);</span><br><span class="line">        count+= countPalindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.length()</span><br><span class="line">           &amp;&amp; s.charAt(start) == s.charAt(end)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        start--;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>for循环嵌套while循环，**时间复杂度为O(n^2)**。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单向链表的简单定义"><a href="#单向链表的简单定义" class="headerlink" title="#单向链表的简单定义"></a>#单向链表的简单定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哨兵节点"><a href="#哨兵节点" class="headerlink" title="#哨兵节点"></a>#哨兵节点</h3><p>哨兵节点是为了简化处理链表边界条件而引入的附加链表节点。哨兵节点通常位于链表的头部，它的值没有任何意义。在一个有哨兵节点的链表中，从第2个节点开始才真正保存有意义的信息。</p><p><strong>用哨兵节点简化链表的插入操作</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">append</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode newNode = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="comment">// 索引到链表的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.next = newNode;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码需要用if语句来单独处理输入头节点head为null的情形。可以用哨兵节点简化代码的逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">append</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode newNode = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">    ListNode node = dummy;</span><br><span class="line">    <span class="comment">// 索引到链表的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.next = newNode;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用哨兵节点简化链表的删除操作</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">delete</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断删除的节点是否是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head.val == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next.val == value) &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码用两条if语句来处理两个特殊情况</p><ol><li>输入的链表为空</li><li>被删除的节点是原始链表的头节点</li></ol><p>可以用哨兵节点简化代码逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">delete</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode node = dummy;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next.val == value) &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合理应用哨兵节点，就不再需要单独处理这些特殊的输入。</strong></p><h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="#双指针"></a>#双指针</h3><p>按移动方式可以细分成两种不同的方法。</p><ol><li>前后双指针，即一个指针在链表中提前朝着指向下一个节点的指针移动若干步，然后移动第二个指针。<strong>前后双指针的经典应用是查找链表的倒数第k个节点。</strong></li><li>快慢双指针，即两个指针在链表中移动的速度不一样，通常是快的指针朝着指向下一个节点的指针一次移动两步，慢的指针一次只移动一步。<strong>采用这种方法，在一个没有环的链表中，当快的指针到达链表尾节点的时候慢的指针正好指向链表的中间节点。</strong></li></ol><h3 id="21-删除倒数第k个节点"><a href="#21-删除倒数第k个节点" class="headerlink" title="#21 删除倒数第k个节点"></a>#21 删除倒数第k个节点</h3><p>如果给定一个链表，请问如何删除链表中的倒数第k个节点？假设链表中节点的总数为n，那么1&lt;=k&lt;=n。要求只能遍历链表一次。</p><p>例如：</p><p>输入链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，删除倒数第2个节点之后的链表为</p><p>1-&gt;2-&gt;3-&gt;4-&gt;6</p><p>分析：</p><p>如果可以遍历链表两次，那么这个问题就会变得简单。在第1次遍历链表时，可以得出链表的节点总数n。在第2次遍历链表时，可以找出链表的第n-k个节点(即倒数第k+1个节点)，然后通过修改指针，即可删除倒数第k个节点。</p><p>但是题目要求只能遍历链表一次。我们可以定义两个指针，来遍历一次就找到倒数第k+1个节点。第一个指针P1从链表头节点开始先走k步，第二个指针P2保持不动；从第k+1步开始指针P2也从链表的头节点开始和指针P1以相同的速度遍历。由于两个指针的距离始终保持为k，当指针P1指向链表的尾节点时指针P2正好指向倒数第k+1个节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode front = head, back = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        front = front.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为前指针是从head开始，相当于开始时多走了一步</span></span><br><span class="line">    <span class="comment">// 所以判断条件为front != null 而不是 front.next != null</span></span><br><span class="line">    <span class="keyword">while</span> (front != <span class="keyword">null</span>) &#123;</span><br><span class="line">        front = front.next;</span><br><span class="line">        back = back.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    back.next = back.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：遍历列表一边，**时间复杂度为O(n)**。</p><h3 id="22-链表中环的入口节点"><a href="#22-链表中环的入口节点" class="headerlink" title="#22 链表中环的入口节点"></a>#22 链表中环的入口节点</h3><p>如果一个链表中包含环，那么应该如何找出环的入口节点？从链表的头节点开始顺着next指针方向进入环的第1个节点为环的入口节点。</p><p>例如：下图所示的链表中，环的入口节点是3。</p><p><img src="image-20211102122856262.png" alt="image-20211102122856262"></p><p>分析：</p><ol><li><p>第一步是确定一个链表中是否包含环。如果链表中没有环，自然不存在环的入口节点，此时应该返回null。</p><p>可以用两个指针来判断链表中是否有环。指针P1，P2同时从头节点出发，P1一次走一步，P2一次走两步。如果链表中不包含环，P2指针直至抵达链表的尾节点都不会和走得慢的指针相遇。如果链表中包含环，走得快的指针在环里绕了一圈之后将会追上走得慢的指针。因此，<strong>可以根据一快一慢两个指针能否相遇来判断链表中是否包含环。</strong></p></li><li><p>第二步是如何找到环的入口节点，还是可以用两个指针来解决。先定义两个指针P1，P2指向指向链表的头节点。如果链表中的环有n个节点，指针P1先在链表中向前移动n步，然后两个指针以相同的速度向前移动。当指针P2指向环的入口时，指针P1已经围绕环走了一圈又回到了入口节点。</p><p><img src="image-20211102124559505.png" alt="image-20211102124559505"></p></li><li><p>最后一个问题是如何得到环中节点的数目。前面用一快一慢两个指针判断链表中是否存在环时，两个指针相遇的节点一定在环中。可以从这个相遇的节点出发一边继续向前移动一边计数，当再次回到这个节点时就可以得到环中节点的数目。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">getNodeInLoop</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实两个指针不是必须都从头节点出发</span></span><br><span class="line">    <span class="comment">// 只要一快一慢两个指针相遇，即可判断成环</span></span><br><span class="line">    ListNode slow = head.next;</span><br><span class="line">    ListNode fast = slow.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle1</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode inLoop = getNodeInLoop(head);</span><br><span class="line">    <span class="keyword">if</span> (inLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到环中的节点数量n</span></span><br><span class="line">    <span class="keyword">int</span> loopCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ListNode n = inLoop; n.next != inLoop; n = n.next) &#123;</span><br><span class="line">        loopCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针先向前移动n步</span></span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopCount; i++) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针一起移动直至相遇</span></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><ol start="4"><li><p>上述解法需要求出链表的环中节点的数目。但是如果仔细分析，就会发现没必要求出环中节点的数目。慢的指针一次走一步，假设在相遇时慢的指针走了k步。由于快的指针一次走两步，因此在相遇时快的指针一共走了2k步。因此相遇时慢的指针比快的指针多走了k步。另外，两指针相遇时快的指针比慢的指针在环中多转了若干全，也就是说，<strong>快指针多走的步数k一定是环中节点数目的整数倍。满指针走过的步数k也是环中节点数目的整数倍。</strong></p><p>基于此思想，可以让一个指针指向相遇的节点，该指针的位置是之前慢的指针走了k步到达的位置。接着让另一个指针指向链表的头节点，然后两个指针以相同的速率一起移动，<strong>此时两指针相遇，前指针比后指针多走k步，相遇的节点刚好是环的入口节点</strong>。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode inLoop = getNodeInLoop(head);</span><br><span class="line">    <span class="keyword">if</span> (inLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inLoop提前移动了k步，node指向头节点</span></span><br><span class="line">    <span class="comment">// 然后两者以相同速率一起移动</span></span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != inLoop) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        inLoop = inLoop.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-两个链表的第1个重合节点"><a href="#23-两个链表的第1个重合节点" class="headerlink" title="#23 两个链表的第1个重合节点"></a>#23 两个链表的第1个重合节点</h3><p>输入两个单向链表，如何找出它们的第1个重合节点。</p><p>例如：</p><p><img src="image-20211102144127782.png" alt="image-20211102144127782"></p><p>此时两个链表的第1个重合节点的值是4。</p><p>分析：</p><p>很直观地想到暴力法求解。在第1个链表中按顺序遍历每个节点，每遍历到一个节点时，在第2个链表中顺序遍历每个节点，然后进行比较。如果第1个链表的长度为m，第2个链表的长度为n，那么该方法的时间复杂度是O(mn)。蛮力法一般不是最好的解法， 所以进一步分析此种链表的特点以求突破。</p><p>特点1：可以在重合的两个链表的基础上构造一个包含环的链表。</p><p><img src="image-20211102145829302.png" alt="image-20211102145829302"></p><p>此时，环的入口节点即是两个链表的第1个重合节点。可以利用上一题的方法解决。</p><p>特点2：如果两个单向链表有重合节点，那么从某个节点开始这两个链表的next指针都指向同一个节点。</p><p>那么如果我们可以从链表的尾部开始比较，最后一个相同的节点就是我们要找的节点。想要实现从尾部开始比较，可以利用栈这种先进后出的结构。将两个链表分别入栈，然后比较栈顶结点。如果两链表的长度分别为m，n，此种方法的**时间复杂度为O(m+n)<strong>。</strong>空间复杂度也为O(m+n)**。</p><p>上述方法之所以要用栈，是因为我们希望能同时到达两个链表的尾节点。当两个链表的长度不同时，如果从头开始遍历，到达尾节点的时间就不一致。其实解决这个问题有更简单的方法：首先遍历两个链表得到它们的长度，这样就能知道哪个链表比较长，以及长链表比短链表多几个节点。假设长链表比短链表多k个节点。第2次遍历时，指针P1，P2分别指向长短链表的头部。指针P1先在长链表中移动k步，然后两指针同时移动，此时两指针相遇的节点即是第一个公共节点。此种方法的**时间复杂度也是O(m+n)<strong>，</strong>由于不需要用栈，空间复杂度为O(1)**。</p><p><img src="image-20211102151210407.png" alt="image-20211102151210407"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count1 = countList(headA);</span><br><span class="line">    <span class="keyword">int</span> count2 = countList(headB);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> delta = Math.abs(count1 - count2);</span><br><span class="line">    ListNode longer = count1 &gt; count2 ? headA : headB;</span><br><span class="line">    ListNode shorter = count1 &gt; count2 ? headB : headA;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++) &#123;</span><br><span class="line">        longer = longer.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (longer != shorter) &#123;</span><br><span class="line">        shorter = shorter.next;</span><br><span class="line">        longer = longer.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="#24 反转链表"></a>#24 反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>例如：</p><p><img src="image-20211102152116962.png" alt="image-20211102152116962"></p><p>分析：</p><p>在调整节点指针时，除了需要知道节点本身，还要知道它的前一个节点和后一个节点。所以在遍历链表逐个反转每个节点的next指针时需要用到3个指针。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：遍历链表一边，**时间复杂度O(n)<strong>，</strong>空间复杂度O(1)**。</p><h3 id="25-链表中的数字相加"><a href="#25-链表中的数字相加" class="headerlink" title="#25 链表中的数字相加"></a>#25 链表中的数字相加</h3><p>给定两个表示非负整数的单向链表，请问如何实现这两个整数的相加并把它们的和仍然用单向链表表示？链表中的每个节点表示整数十进制的一位，并且头节点对应整数的最高位而尾节点对应整数的个位。</p><p>例如：</p><p><img src="image-20211102154056177.png" alt="image-20211102154056177"></p><p>分析：</p><p>第一反应是，根据链表求出整数，然后将整数相加，最后把结果用链表表示。<strong>这种思路最大的问题是没考虑到整数有可能会溢出</strong>，当链表较长时，可能会超出int甚至long的范围。</p><p>通常两整数相加，都是先算低位再算高位，因为还要考虑进位的问题。所以想到可以把链表反转，然后在逐个节点上实现加法。最后把表示和的链表反转。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    head1 = reverseList(head1);</span><br><span class="line">    head2 = reverseList(head2);</span><br><span class="line">    ListNode reversedHead = addReversed(head1, head2);</span><br><span class="line">    <span class="keyword">return</span> reverseList(reversedHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">addReversed</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode sumNode = dummy;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> || head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (head1 == <span class="keyword">null</span> ? <span class="number">0</span> : head1.val)</span><br><span class="line">            + (head2 == <span class="keyword">null</span> ? <span class="number">0</span> : head2.val) + carry;</span><br><span class="line">        carry = sum &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        sum = sum &gt;= <span class="number">10</span> ? sum - <span class="number">10</span> : sum;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line"></span><br><span class="line">        sumNode.next = newNode;</span><br><span class="line">        sumNode = sumNode.next;</span><br><span class="line"></span><br><span class="line">        head1 = head1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : head1.next;</span><br><span class="line">        head2 = head2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : head2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后的进位</span></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sumNode.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-重排链表"><a href="#26-重排链表" class="headerlink" title="#26 重排链表"></a>#26 重排链表</h3><p>给定一个链表，链表中节点的顺序是L0-&gt;L1-&gt;L2-&gt;…-&gt;Ln-1-&gt;Ln，请问如何重排链表使节点的顺序变成L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;L2-&gt;Ln-2…</p><p>例如：</p><p><img src="image-20211102160234120.png" alt="image-20211102160234120"></p><p>分析：</p><p>观察输入链表和输出链表之间的关系，发现重排链表实际上是把链表分成前后两半。在示例链表中，前半段包含1、2、3三个节点，后半段包含4、5、6三个节点。然后把后半段链表反转，再与前半段链表拼接。</p><p>首先需要解决的问题是如何把一个链表分成两半，即找到链表的中间节点。可以一快一慢两个指针实现。两个指针同时从链表的头节点出发，快的指针一次走两步，慢的指针一次走一步，当快的指针走到链表的尾节点时，慢的指针刚好走到链表的中间节点。要注意：链表的节点总数可能是奇数也可能是偶数。当链表的节点总数是奇数时，要确保链表的前半段比后半段多一个节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode fast = dummy;</span><br><span class="line">    ListNode slow = dummy;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode temp = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    link(head, reverseList(temp), dummy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(ListNode node1, ListNode node2, ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = head;</span><br><span class="line">    <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = node1.next;</span><br><span class="line"></span><br><span class="line">        prev.next = node1;</span><br><span class="line">        node1.next = node2;</span><br><span class="line">        prev = node2;</span><br><span class="line"></span><br><span class="line">        node1 = temp;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.next = node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，当变量fast指向尾节点时，变量slow指向前半段的最后一个节点。</p><h3 id="27-回文链表"><a href="#27-回文链表" class="headerlink" title="#27 回文链表"></a>#27 回文链表</h3><p>如何判断一个链表是不是回文？要求解法的时间复杂度是O(n)，并且不得使用超过O(1)的辅助空间。</p><p>例如：</p><p><img src="image-20211107151640955.png" alt="image-20211107151640955"></p><p>分析：</p><p>如果不考虑辅助空间的限制，直观的解法是创建一个新的链表，链表中的节点顺序和输入链表的节点顺序正好相反。二者比较即可判断是否是回文链表，此时需要O(n)的辅助空间。</p><p>分析回文链表的特点以找出更好的解法。回文链表的一个特性是对称性，也就是说，如果把链表分为前后两半，那么前半段链表反转之后与后半段链表是相同的。因此可以想到把链表分成前后两半，然后把其中一半反转。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode secondHalf = slow.next;</span><br><span class="line">    <span class="comment">// 如果fast.next != null，说明链表中节点个数为奇数</span></span><br><span class="line">    <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 跳过中间节点</span></span><br><span class="line">        secondHalf = slow.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> equals(secondHalf, reverseList(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.val != head2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head1 = head1.next;</span><br><span class="line">        head2 = head2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head1 == <span class="keyword">null</span> &amp;&amp; head2 == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，不管链表的节点总数是奇数还是偶数，变量slow都指向链表前半段的最后一个节点。</p><h3 id="双向链表和循环链表"><a href="#双向链表和循环链表" class="headerlink" title="双向链表和循环链表"></a>双向链表和循环链表</h3><p>由于单向链表只能从头节点开始遍历到尾节点，遍历的顺序受到限制，在很多场景下使用起来不太方便，因此双向链表应运而生。双向链表在单向链表节点的基础上增加了指向前一个节点的指针，这样一来，既可从前往后遍历，也可以从后向前遍历。</p><p>如果把链表尾节点的下一个节点的指针指向链表的头节点，那么此时链表就变成一个循环链表。循环链表既可以是单向链表，也可以是双向链表。</p><h3 id="28-展平多级双向链表"><a href="#28-展平多级双向链表" class="headerlink" title="#28 展平多级双向链表"></a>#28 展平多级双向链表</h3><p>在一个多级双向链表中，节点除了有两个指针分别指向前后两个节点，还有一个指针指向它的子链表，并且子链表也是一个双向链表，它的节点也有指向子链表的指针。请将这样的多级双向链表展成普通的双向链表，即所有节点都没有子链表。</p><p>例如：</p><p><img src="image-20211107160039114.png" alt="image-20211107160039114"></p><p>分析：</p><p>展平的规则是一个节点的子链表展平之后将插入该节点和它的下一个节点之间。由于子链表中的节点也有可能有子链表，<strong>因此这里的链表是一个递归的结构</strong>。在展平子链表时，如果它也有自己的子链表，那么它嵌套的子链表也要一起展平。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    flattenGetTail(head);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">flattenGetTail</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node node = head;</span><br><span class="line">    Node tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        <span class="keyword">if</span> (node.child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node child = node.child;</span><br><span class="line">            Node childTail = flattenGetTail(node.child);</span><br><span class="line"></span><br><span class="line">            node.child = <span class="keyword">null</span>;</span><br><span class="line">            node.next = child;</span><br><span class="line">            child.prev = node;</span><br><span class="line">            childTail.next = next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                next.prev = childTail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tail = childTail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，递归函数flattenGetTail在展平以head为头节点的链表之后返回链表的尾节点。在该函数中需要逐一扫描链表中的节点。如果一个节点node有子链表，由于子链表也可能有嵌套的子链表，因此先递归调用flattenGetTail函数展平子链表，子链表展平之后头节点时child，尾节点是childTail。最后将展平的子链表插入节点node和它的下一个节点next之间，即把展平的子链表头节点child插入节点node之后，并将尾节点childTail插入节点next之前。</p><p>这种解法每个节点都会遍历一次，如果链表总共有n个节点，那么时间复杂度时O(n)。函数flattenGetTail的递归调用次数取决于链表嵌套的次数，因此，如果链表的层数为k，那么该节点的空间复杂度是O(k)。</p><h3 id="29-排序的循环链表"><a href="#29-排序的循环链表" class="headerlink" title="#29 排序的循环链表"></a>#29 排序的循环链表</h3><p>在一个循环链表中节点的值递增排序，请设计一个算法在该循环链表中插入节点，并保证插入节点之后循环链表仍然是排序的。</p><p>例如：</p><p><img src="image-20211107163817220.png" alt="image-20211107163817220"></p><p>分析：</p><p>再插入节点4时，新的节点位于3，5节点之间。为了使插入新节点后循环链表仍然是排序的，新节点的前一个节点的值应该比新节点的值小，后一个节点的值应该比新节点大。</p><p>但是特殊情况需要特殊处理。</p><p>特殊情况1：如果新节点是链表中最大或最小的节点，新的节点将被插入到最大值和最小值之间。</p><p>特殊情况2：如果链表中的节点数小于2，那么应该有两种可能。第1种可能是开始的时候链表是空的，一个节点都没有，此时插入一个新的节点，该节点成为循环链表中唯一的节点，那么next指针指向节点自己。第2种可能是开始的时候链表中只有一个节点，插入一个新的节点之后，两个节点的next指针互相指向对方。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">insert</span> <span class="params">(Node head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(insertVal);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        head.next = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == head) &#123;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.next = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertCore(head, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertCore</span><span class="params">(Node head, Node node)</span> </span>&#123;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = head.next;</span><br><span class="line">    Node biggest = head;</span><br><span class="line">    <span class="comment">// 如果是因为不满足next != head退出，表示新节点是链表中最大或最小的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!(cur.val &lt;= node.val &amp;&amp; next.val &gt;= node.val &amp;&amp; next != head)) &#123;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; biggest.val) &#123;</span><br><span class="line">            biggest = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur.val &lt;= node.val &amp;&amp; next.val &gt;= node.val) &#123;</span><br><span class="line">        cur.next = node;</span><br><span class="line">        node.next = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.next = biggest.next;</span><br><span class="line">        biggest.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="30-插入、删除和随机访问都是O-1-的容器"><a href="#30-插入、删除和随机访问都是O-1-的容器" class="headerlink" title="#30 插入、删除和随机访问都是O(1)的容器"></a>#30 插入、删除和随机访问都是O(1)的容器</h3><p>设计一个数据结构，使如下3个操作的时间复杂度都是O(1)。</p><ul><li>insert(value)：如果数据集种不包含一个数值，则把它添加到数据集中。</li><li>remove(value)：如果数据集中包含一个数值，则把它删除。</li><li>getRandom()：随机返回数据集中的一个数值，要求数据集中每个数字被返回的概率都相同。</li></ul><p>分析：</p><p>由于要求插入和删除的时间复杂度都是O(1)，因此需要用哈希表来实现。</p><p>如果只用哈希表，则不能等概率地返回其中的每个数值。如果数值是保存在数组中的，那么很容易实现等概率地返回其中的每个数值。假设数组的长度是n，那么等概率生成从0到n-1的一个数字。如果生成的随机数是i，则返回数组中下标为i的数值。由此可以发现，需要结合哈希表和数组来设计这个数据容器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; numToLocation;</span><br><span class="line">    ArrayList&lt;Integer&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        numToLocation = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numToLocation.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        numToLocation.put(val, nums.size());</span><br><span class="line">        nums.add(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!numToLocation.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用数组中最后一个元素覆盖要删除的元素，并修改哈希表中对应位置的键值对</span></span><br><span class="line">        <span class="keyword">int</span> location = numToLocation.get(val);</span><br><span class="line">        numToLocation.put(nums.get(nums.size() - <span class="number">1</span>), location);</span><br><span class="line">        numToLocation.remove(val);</span><br><span class="line">        nums.set(location, nums.get(nums.size() - <span class="number">1</span>));</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> r = random.nextInt(nums.size());</span><br><span class="line">        <span class="keyword">return</span> nums.get(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31-最近最少使用缓存"><a href="#31-最近最少使用缓存" class="headerlink" title="#31 最近最少使用缓存"></a>#31 最近最少使用缓存</h3><p>设计实现一个最近最少使用(Least Recently Used, LRU)缓存，要求如下两个操作的时间复杂度都是O(1)。</p><ul><li>get(key)：如果缓存中存在键key，则返回它对应的值，否则返回-1</li><li>put(key,value)：如果缓存中之前包含key，则它的值设为value；否则添加键key及对应的值value。在添加一个键时，如果缓存容量已经满了，则在添加新键之前删除最近最少使用的键(缓存中最长时间没有被使用过的元素)。</li></ul><p>分析：</p><p>哈希表的get和put操作的时间复杂度都是O(1)，但普通的哈希表无法找出最近最少使用的键，因此需要在哈希表的基础上进行改进。</p><p>由于需要知道缓存中最近最少使用的元素，因此可以把缓存中的元素存入链表中。每次访问一个元素(无论是通过get还是put操作)，该元素都被移到链表的尾部。这样，<strong>位于链表头部的元素就是最近最少使用的。</strong></p><p>如果这个链表是单向链表，那么找到一个节点的前一个节点需要从链表的头节点开始遍历链表，需要O(n)的时间。因此可以用双向链表来存储缓存中的元素。在双向链表中查找一个结点的前一个节点，只需要顺着prev指针向前走一步，时间复杂度为O(1)。</p><p>首先定义双向链表中的节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    <span class="keyword">public</span> ListNode prev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义最近最少使用缓存的数据结构。缓存中包含一个哈希表，哈希表的键就是缓存的键，哈希表的值是双向链表中的节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line">    <span class="keyword">private</span> ListNode tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ListNode&gt; map;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个容量为cap的缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line"></span><br><span class="line">        capacity = cap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于在双向链表中添加和删除节点，上述代码创建了两个哨兵节点，即head和tail，他们分别位于双向链表的头部和尾部。函数put所添加的节点将位于这两个节点之间。</p><p>接下来实现get，put及辅助函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    ListNode node = map.get(key);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    moveToTail(node, node.value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">        moveToTail(map.get(key), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">            ListNode toBeDelete = head.next;</span><br><span class="line">            deleteNode(toBeDelete);</span><br><span class="line"></span><br><span class="line">            map.remove(toBeDelete.key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(key, value);</span><br><span class="line">        insertToTail(node);</span><br><span class="line"></span><br><span class="line">        map.put(key, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToTail</span><span class="params">(ListNode node, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    deleteNode(node);</span><br><span class="line"></span><br><span class="line">    node.value = newValue;</span><br><span class="line">    insertToTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.prev.next = node.next;</span><br><span class="line">    node.next.prev = node.prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertToTail</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    tail.prev.next = node;</span><br><span class="line">    node.prev = tail.prev;</span><br><span class="line">    node.next = tail;</span><br><span class="line">    tail.prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-有效的变位词"><a href="#32-有效的变位词" class="headerlink" title="#32 有效的变位词"></a>#32 有效的变位词</h3><p>给定两个字符串s和t，请判断它们是不是一组变位词。在一组变位词中，他们中的字符及每个字符出现的次数都相同， 但字符的顺序不能相同。</p><p>例如：</p><p>“anagram”和”nagaram”就是一组变位词。</p><p>分析：</p><p>由于变位词和字符出现的次数相关，因此可以用一个哈希表来存储每个字符出现的次数。哈希表的键是字符，而值是对应字符出现的次数。<strong>如果哈希表的键取值范围是固定的，而且范围不是很大，则可以用数组来模拟哈希表。</strong></p><p>如果只考虑英文字母，则用数组来模拟哈希表：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram1</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 长度不同一定不是同位词</span></span><br><span class="line">    <span class="keyword">if</span> (str1.length() != str2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符顺序相同也不是同位词</span></span><br><span class="line">    <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str1.toCharArray()) &#123;</span><br><span class="line">        counts[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str2.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counts[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入字符串的长度为n，上述解法的**时间复杂度为O(n)<strong>。不管字符串的长度如何，辅助数组的长度都是固定的，因此</strong>空间复杂度是O(1)**。</p><p>如果考虑用字符串表示中文或其他非英语语言，那么ASCII码字符集是不够的。因为一个ASCII码字符的长度为8位，所以ASCII码字符集能包含256个不同的字符，中文及很多语言的字符集都远远超过这个数字。为了包含更多的字符，需要其他编码的字符集，目前使用最多的是Unicode编码。一个Unicode的字符的长度为16位，这样就能表示65536个字符。此种情况下，如果还和之前一样，创建一个长度为65536的数组，似乎会浪费内存。所以此时就可以创建一个类型为HashMap的真正的哈希表。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram2</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1.length() != str2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str1.toCharArray()) &#123;</span><br><span class="line">        counts.put(ch, counts.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str2.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counts.containsKey(ch) || counts.get(ch) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counts.put(ch, counts.get(ch) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的**时间复杂度仍然是O(n)<strong>。但是如果输入的字符串中不同字符的数目越多，HashMap就需要越多的空间。因此，可以认为使用HashMap的</strong>空间复杂度是O(n)**。</p><h3 id="33-变位词组"><a href="#33-变位词组" class="headerlink" title="#33 变位词组"></a>#33 变位词组</h3><p>给定一组单词，请将他们按照变位词分组。假设单词中只包含英文小写字母。</p><p>例如：输入一组单词[“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]，这组单词可以分成三组，分别是[“eat”, “tea”, “ate”]、[“tan”, “nat”]、[“bat”]。</p><p>分析：</p><p>解决这个问题，就需要找出一组变位词共同的特性，然后依据此特性把它们分到一组。这里主要介绍两种方法：</p><ol><li><p>将单词映射到数字。把每个英文小写字母映射到一个质数，如把字母’a’映射到数字2，字母’b’映射到数字3，以此类推。字母’z’映射到第26个质数101。每给出一个单词，就把单词中的所有字母对应的数字相乘，于是每个单词都可以算出一个数字。例如，单词’eat’可以映射到数字1562(11*2*71)。’</p><p>如果两个单词护卫变位词，那么它们中每个字母出现的次数都对应相同，由于乘法满足交换律，因此上述算法把一组变位词映射到同一个数值。由于每个字母都是映射到一个质数，因此不互为变位词的两个单词一定会映射到不同的数字。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams1(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">int</span> hash[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Map&lt;Long, List&lt;String&gt;&gt; groups = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="keyword">long</span> wordHash = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            wordHash *= hash[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        groups.putIfAbsent(wordHash, <span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">        groups.get(wordHash).add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(groups.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入n个单词，平均每个单词有m个字母，那么该算法的时间复杂度是O(mn)。</p><p>该算法有一个潜在的问题：<strong>由于把单词映射到数字用到了乘法，因此当单词非常长时，乘法就有可能溢出</strong>。</p><ol start="2"><li>将单词的字母排序。互为变位词的单词排序后会得到相同的字符串。因此可以定义一个哈希表，哈希表的键是把单词字母排序得到的字符串，而值是一组变位词。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams2(String[] strs) &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; groups = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        Arrays.sort(charArray);</span><br><span class="line">        String sorted = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">        groups.putIfAbsent(sorted, <span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">        groups.get(sorted).add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(groups.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每个单词平均有m个字母，排序一个单词需要O(mlogm)的时间，假设总共有n个单词，该算法总的时间复杂度是<strong>O(nmlogm)<strong>。</strong>虽然该方法的时间效率不如前一种方法，但是该方法不用担心乘法可能带来的溢出问题。</strong></p><h3 id="34-外星语言是否排序"><a href="#34-外星语言是否排序" class="headerlink" title="#34 外星语言是否排序"></a>#34 外星语言是否排序</h3><p>y偶一门外星语言，它的子目标刚好包含所有的英文小写字母，只是字母表的顺序不同。给定一组单词和字母表顺序，请判断这些单词是否按照字母表的顺序排序。</p><p>例如：输入一组单词[“offer”, “is”, “comming”]，以及字母表顺序”zyxwvutsrqponmlkjihgfedcba”，由于字母’o’在字母表中位于’i’的前面，因此单词”offer”排在”is”的前面；同理，单词”is”排在”comming”的前面。因此，这一组单词是按照字母表顺序排序的，应该输出true。</p><p>分析：</p><p>为了方便查找每个字母在字母表中的顺序，可以创建一个哈希表，哈希表的键为字母表的每个字母，而值为字母在字母表中的顺序。字母表中字母的数目是固定的，一共26个。所以可以用数组来模拟哈希表。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlienSorted</span><span class="params">(String[] words, String order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] orderArray = <span class="keyword">new</span> <span class="keyword">int</span>[order.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.length(); i++) &#123;</span><br><span class="line">            orderArray[order.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSorted(words[i], words[i + <span class="number">1</span>], orderArray)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(String word1, String word2, <span class="keyword">int</span>[] order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; word1.length() &amp;&amp; i &lt; word2.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = word1.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> ch2 = word2.charAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (order[ch1 - <span class="string">&#x27;a&#x27;</span>] &lt; order[ch2 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (order[ch1 - <span class="string">&#x27;a&#x27;</span>] &gt; order[ch2 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i == word1.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入n个单词，每个单词的平均长度为m，那么该算法的**时间复杂度是O(mn)<strong>，</strong>空间复杂度是O(1)**。</p><h3 id="35-最小时间差"><a href="#35-最小时间差" class="headerlink" title="#35 最小时间差"></a>#35 最小时间差</h3><p>给定一组范围在00:00至23:59的时间，求任意两个时间之间的最小时间差。</p><p>例如：输入时间数组[“23:50”, “23:59”, “00:00”]，”23:59”和”00:00”之间只有1分钟的间隔，是最小的时间差。</p><p>分析：</p><p>最直观的解法是求出任意两个时间的间隔，然后得出最小的是价差。如果输入n个时间，这种蛮力法需要O(n^2)的时间。</p><p>上述解法的一个优化是把n个时间排序，排序后只需要计算两相邻时间之间的间隔，这样就只需要计算O(n)个时间差。由于对n个时间进行排序通常需要O(nlogn)的时间，因此这种优化算法的总体时间复杂度是O(nlogn)。</p><p>一个特殊情况需要考虑：”00:00”也有可能是第二天的00:00，所以在计算时要考虑到两种情况: </p><ol><li>最小时间间隔出现在同一天</li><li>最小时间间隔需要和第二天00:00比较</li></ol><p>一天有24小时，即1440分钟。如果用一个长度为1440的数组表示一天的时间，那么数组的下标为0的位置对应时间00:00，下表为1的位置对应时间00:01。数组中的每个元素是true或false标识。由于数组的下标对应的是时间，因此两个时间之间的时间差就是他们在数组中对应的下标之差。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 列表长度大于1440，则一定出现了两个相同时间，所以最小时间间隔为0</span></span><br><span class="line">    <span class="keyword">if</span> (timePoints.size() &gt; <span class="number">1440</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> minutesFlags[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1440</span>];</span><br><span class="line">    <span class="keyword">for</span> (String time : timePoints) &#123;</span><br><span class="line">        String t[] = time.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> min = Integer.parseInt(t[<span class="number">0</span>]) * <span class="number">60</span> + Integer.parseInt(t[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 如果为true，则列表中出现了两个相同时间，即最小时间间隔为0</span></span><br><span class="line">        <span class="keyword">if</span> (minutesFlags[min]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        minutesFlags[min] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(minutesFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">boolean</span> minuteFlags[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minDiff = minuteFlags.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> first = minuteFlags.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minuteFlags.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minuteFlags[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                minDiff = Math.min(i - prev, minDiff);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prev = i;</span><br><span class="line">            first = Math.min(i, first);</span><br><span class="line">            last = Math.max(i, last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minDiff = Math.min(minuteFlags.length - last + first, minDiff);</span><br><span class="line">    <span class="keyword">return</span> minDiff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设输入时间的数目是n。上述代码中有两个for循环，主函数for的时间复杂度是O(n)；辅助函数helper的for循环执行次数为minuteFlags的长度1440，所以时间复杂度为O(1)。因此**总时间复杂度为O(n)<strong>。该方法需要创建一个长度为常数的辅助数组，</strong>空间复杂度为O(1)**。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux韩顺平学习笔记</title>
      <link href="/2021/09/29/linux_hsp/"/>
      <url>/2021/09/29/linux_hsp/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相关课程学习资料请添加韩老师微信获取</p><p>微信号<code>hspfly</code></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>linux是一个开源、免费的操作系统。 其稳定性、 安全性、 处理多并发已经得到业界的认可，因此目前很多企业级项目都会部署到linux/unix系统上。</p><h3 id="Linux主要的发行版："><a href="#Linux主要的发行版：" class="headerlink" title="Linux主要的发行版："></a>Linux主要的发行版：</h3><p>​    Ubuntu, RedHat, CentOS, Debain, Fedora, SuSE, OpenSUSE</p><p>(本课程主要使用CentOS)</p><h3 id="Linux应用领域"><a href="#Linux应用领域" class="headerlink" title="Linux应用领域"></a>Linux应用领域</h3><ul><li><p><code>服务器领域</code></p><p>linux再服务器领域的应用是最强的</p><p>linux免费、稳定、高效等特点在这里得到了很好的体现， 尤其在一些高端领域尤为广泛（c/c++/php/java/python/go）</p></li><li><p><code>嵌入式领域</code></p><p>linux运行稳定、对网络的良好支持性、低成本， 且可以根据需要进行剪裁，内核最小可以达到几百KB等特点，使其近些年来再嵌入式领域广泛应用</p><p>主要应用： 机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件等都是其应用领域。以后再物联网中应用会更加广泛。</p></li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li>VMware Workstation Pro 15.5 </li><li>Centos7.6 DVD版 （目前主流的生产环境）</li><li>Centos8.1 DVD版 （未来的主流）</li></ol><p>在配置Cenots时， 网络连接模式要选NAT模式，避免造成IP冲突。</p><p><img src="image-20211001130843302.png" alt="image-20211001130843302"></p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="虚拟机克隆"><a href="#虚拟机克隆" class="headerlink" title="虚拟机克隆"></a>虚拟机克隆</h3><p>如果你已经安装了一台linux操作系统， 还想要更多的， 没必要再重新安装， 直接克隆即可。</p><ul><li>方式1：直接拷贝一份安装好的虚拟机文件，然后用vmware打开</li><li>方式2：使用vmware的克隆操作。（注意：克隆时需要先关闭linux系统）</li></ul><h3 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h3><p>如果在使用虚拟机系统时，想要回到原先的摸一个状态，比如担心可能有些误操作造成系统异常，需要回到原先某个正常运行的状态，vmware提供了这样的功能，叫快照管理</p><p>快照管理类似于Git的分支管理，但使用时会占用一定的磁盘空间，建议在系统发生有意义的变化时使用。</p><h3 id="虚拟机迁移和删除"><a href="#虚拟机迁移和删除" class="headerlink" title="虚拟机迁移和删除"></a>虚拟机迁移和删除</h3><p>安装好的虚拟机，本质上就是（放在文件夹中的）文件。因此虚拟系统的迁移很方便，你可以把安装好的虚拟系统文件夹整体<strong>拷贝</strong>或者<strong>剪切</strong>到另外的位置使用。</p><p>删除也很简单，先在vmware中进行移除 （不会删除本地文件），再手动删除本地文件。</p><h3 id="windows和虚拟机共享文件"><a href="#windows和虚拟机共享文件" class="headerlink" title="windows和虚拟机共享文件"></a>windows和虚拟机共享文件</h3><p>安装vmtools</p><p>可以在windows下更好地管理vm虚拟机</p><p>可以设置wondows和centos的共享文件夹</p><p><img src="image-20211001145806913.png" alt="image-20211001145806913"></p><p><img src="image-20211001150308200.png" alt="image-20211001150308200"></p><h2 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Linux的文件系统采用级层式的树状目录结构，在此结构中的最上层是根目录”/“，然后在此目录下再创建其他的目录。</p><p><code>在Linux世界里，一切皆文件</code>，硬件设备、网络通信等资源也是通过文件管理。</p><ul><li><p>这样做最明显的好处是，开发者仅需要使用一套 API 和开发工具即可调取 Linux 系统中绝大部分的资源。</p></li><li><p>不利之处在于，使用任何硬件设备都必须与根目录下某一目录执行挂载操作，否则无法使用。我们知道，本身 Linux 具有一个以根目录为树根的文件目录结构，每个设备也同样如此，它们是相互独立的。如果我们想通过 Linux 上的根目录找到设备文件的目录结构，就必须将这两个文件系统目录合二为一，这就是挂载的真正含义。</p></li></ul><h3 id="具体目录结构"><a href="#具体目录结构" class="headerlink" title="具体目录结构"></a>具体目录结构</h3><p>了解即可</p><p>可以用<code>pwd</code>指令显示当前用户所在目录的绝对路径</p><ul><li><p>/bin <code>【常用】</code>：</p><p>是Binary的缩写，这个目录存放着最经常使用的命令。</p></li><li><p>/sbin：</p><p>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p>/home <code>【常用】</code> ：</p><p>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p></li><li><p>/root <code>【常用】</code>：</p><p>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p>/lib：</p><p>系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p>/lost+found：</p><p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p>/etc <code>【常用】</code>：</p><p>所有的系统管理所需要的配置文件和子目录my.conf。</p></li><li><p>/usr <code>【常用】</code>：</p><p>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</p></li><li><p>/boot <code>【常用】</code>：</p><p>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p>/proc <code>【不能动】</code>：</p><p>这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</p></li><li><p>/srv <code>【不能动】</code>：</p><p>service的缩写，该目录存放一些服务启动之后需要提供的数据。</p></li><li><p>/sys <code>【不能动】</code>：</p><p>这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。</p></li><li><p>/tmp：</p><p>这个目录是用来存放一些临时文件的。</p></li><li><p>/dev：</p><p>类似windows的设备管理器，把所有的硬件用文件的形式存储。</p></li><li><p>/media <code>【不能动】</code>：</p><p>linux系统会自动识别一些设备，例如U盘光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p></li><li><p>/mnt <code>【常用】</code>：</p><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。</p></li><li><p>/opt：</p><p>这是给主机额外安装软件所摆放的目录，如安装ORACLE数据库就可放到该目录下。默认为空。</p></li><li><p>/usr/local <code>【常用】</code>：</p><p>这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。</p></li><li><p>/var <code>【常用】</code>：</p><p>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</p></li><li><p>/selinux：</p><p>SELinux是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式， 可以自行设置。</p></li></ul><h2 id="Linux-远程连接"><a href="#Linux-远程连接" class="headerlink" title="Linux 远程连接"></a>Linux 远程连接</h2><p>为什么要远程连接Linux？</p><ol><li>Linux服务器是开发小组共享</li><li>正式上线的项目是运行在公网</li><li>因此程序员需要远程登录到Linux进行项目管理或者开发</li></ol><h3 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h3><p>xshell 7 <a href="https://www.netsarang.com/en/xshell/">XSHELL - The Industry’s Most Powerful SSH Client (netsarang.com)</a></p><ol><li><p>首先在虚拟机中通过ifconfig命令获取ip</p><img src="image-20211001165231780.png" alt="image-20211001165231780" style="zoom: 80%;"   /></li><li><p>在xshell中新建会话，填入对应ip</p><img src="image-20211001165423495.png" alt="image-20211001165423495" style="zoom: 80%;"  /></li><li><p>连接成功</p><img src = "image-20211001165938748.png" alt="image-20211001165938748.png" style="zoom: 80%;"  ></li></ol><h3 id="文件上传下载"><a href="#文件上传下载" class="headerlink" title="文件上传下载"></a>文件上传下载</h3><p>xshell只能进行远程命令式的操作，如果需要上传或下载文件，需要用到<code>Xftp</code> <a href="https://www.netsarang.com/zh/xftp/">XFTP - NetSarang Website</a></p><p>配置过程与xshell类似</p><ol><li><p>新建会话并输入对应主机ip，协议默认SFTP</p><img src="image-20211001170906472.png" alt="image-20211001170906472" style="zoom: 80%;"  /></li><li><p>输入系统对应的用户名和密码</p><img src="image-20211001171657031.png" alt="image-20211001171657031" style="zoom: 80%;"  /></li><li><p>连接成功</p><img src="image-20211001172731187.png" alt="image-20211001172731187" style="zoom: 67%;" /></li><li><p>（如果有乱码，则在属性中修改编码格式）</p><img src="image-20211001172459766.png" alt="image-20211001172459766" style="zoom: 67%;"  /><img src="image-20211001172553054.png" alt="image-20211001172553054" style="zoom: 67%;"  /></li></ol><h2 id="vi-amp-vim-编辑器"><a href="#vi-amp-vim-编辑器" class="headerlink" title="vi &amp; vim 编辑器"></a>vi &amp; vim 编辑器</h2><p>vim具有程序编辑的能力，可以看作是vi增强版本，可以生动地以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，因此被广泛使用。</p><h3 id="vi-和-vim-常用的三种模式"><a href="#vi-和-vim-常用的三种模式" class="headerlink" title="vi 和 vim 常用的三种模式"></a>vi 和 vim 常用的三种模式</h3><ul><li><p>正常模式（默认模式）</p><p>在这个模式中，可以使用<code>上下左右按键</code>来移动光标，你可以使用<code>删除字符</code>或<code>删除整行</code>来处理档案内容，也可以使用<code>复制、粘贴</code>来处理文件数据</p></li><li><p>插入模式</p><p>按下<code>i,I,o,O,a,A,r,R</code>等任何一个字母之后才会进入编辑模式</p></li><li><p>命令行模式</p><p>按Esc退出插入模式，然后输入”:”进入命令行模式。在这个模式中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等动作</p></li></ul><p><strong>各模式相互切换示意图</strong></p><img src="image-20211001190603554.png" alt="image-20211001190603554" style="zoom: 50%;"  /><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li>拷贝当前行 【yy】，拷贝当前向下5行 【5yy】，粘贴 【p】</li><li>删除当前行 【dd】，删除当前向下5行 【5dd】</li><li>在文件中查找某个单词，在<code>命令行模式</code>下输入【/关键字】，回车查找，按n查找下一个</li><li>设置文件行号【set nu】，取消文件行号【set nonu】</li><li>编辑文件，到达文档最末行/首行，<code>正常模式</code>下输入【G】/【gg】</li><li>撤销输入，在<code>正常模式</code>下输入【u】</li><li>编辑文件，光标移动到某行, <code>正常模式下</code>输入【shift+g】<ul><li>显示行号：set nu</li><li>输入行号这个数</li><li>输入shift+g</li></ul></li></ul><p><strong>Vim键盘图</strong></p><img src="image-20211001200549477.png" alt="image-20211001200549477" style="zoom: 80%;"  /><h2 id="关机-、-重启和用户登录注销"><a href="#关机-、-重启和用户登录注销" class="headerlink" title="关机 、 重启和用户登录注销"></a>关机 、 重启和用户登录注销</h2><h3 id="关机-amp-重启命令"><a href="#关机-amp-重启命令" class="headerlink" title="关机 &amp; 重启命令"></a>关机 &amp; 重启命令</h3><ul><li><p>shutdown -h now：表示立即关机</p></li><li><p>shutdown -h 1：表示1分钟后关机 （直接输入shutdown等效于shutdown -h 1）</p></li><li><p>shutdown -r now：立即重启</p></li><li><p>halt：关机，等效于shutdown -h now</p></li><li><p>reboot：重启，等效于shutdown -r now</p></li><li><p>sync：把内存的数据同步到磁盘</p><p><strong>当我们关机或者重启时，都应该先执行一下sync，防止数据丢失</strong></p><p><strong>现在的shutdown、halt、reboot等命令均已在关机前进行了sync</strong></p></li><li><p>logout：注销用户，<strong>在图形运行级别无效，在运行级别3有效</strong>。</p></li></ul><h3 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h3><ul><li><p>登陆时尽量少使用root账号，因为他是系统管理员，拥有最大权限。使用时要注意避免操作失误。可以利用普通用户登录，登录后再用”su - 用户名“来切换成系统管理员身份。</p></li><li><p>在提示符下驶入logout即可注销用户</p><p><strong>logout注销指令在图形运行级别无效，在运行级别3下有效。</strong></p><p><strong>运行级别这个概念，后面介绍。</strong></p></li></ul><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>基本语法 <code>useradd 用户名</code></p><p>案例：添加一个用户milan <strong>==&gt;</strong> useradd milan</p><p> 默认该用户的家目录在/home/milan</p><p>当创建用户成功后，会自动创建和用户同名的家目录</p><p>也可以通过<code>useradd -d 指定目录 用户名</code>，给新创建的用户指定家目录</p><h3 id="指定-amp-修改密码"><a href="#指定-amp-修改密码" class="headerlink" title="指定 &amp; 修改密码"></a>指定 &amp; 修改密码</h3><p>基本语法 <code>passwd 用户名</code></p><p>案例：给milan指定密码 <strong>==&gt;</strong> passwd milan</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>基本语法 <code>userdel 用户名</code></p><p>案例1：删除用户milan，但要保留家目录 <strong>==&gt;</strong> userdel milan</p><p>案例2：删除用户milan以及主目录（home/milan） <strong>==&gt;</strong> userdel -r milan</p><p><strong>一般情况下建议保留家目录</strong></p><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><p>基本语法 <code>id 用户名</code></p><p>案例：查询root信息 <strong>==&gt;</strong> id root</p><p>当用户不存在时，返回无此用户</p><h4 id="查询当前用户-登录用户"><a href="#查询当前用户-登录用户" class="headerlink" title="查询当前用户/登录用户"></a>查询当前用户/登录用户</h4><p>基本语法 </p><ul><li><code>whoami</code> 查询当前用户</li><li><code>who am i</code> 查询登录用户</li></ul><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>基本语法 <code>su - 用户名</code></p><p>在Linux中，如果当前用户的权限不够，可以通过su - 指令切换到高权限用户，比如root。从权限高的用户切换到权限低的用户不需要输入密码，反之则需要。当需要返回到原来用户时，使用<code>exit/logout</code>指令。</p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>类似于角色，系统可以对有共性/权限的多个用户进行统一的管理。</p><p><strong>每个用户至少要属于一个组！</strong></p><img src="image-20211001231506984.png" alt="image-20211001231506984" style="zoom:80%;"  /><p>基本语法</p><ul><li>添加组 <code>groupadd 组名</code></li><li>删除组 <code>groupdel 组名</code></li><li>创建用户时指定组 <code>useradd -g 组名 用户名</code></li><li>修改用户组 <code>usermod -g 组名 用户名</code></li></ul><h3 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h3><ol><li> /etc/passwd 文件</li></ol><ul><li>用户（user）的配置文件，记录用户的各种信息。</li><li>每行的含义：用户名：口令：用户标识号：注释性描述：主目录：登录shell</li></ul><ol start="2"><li> /etc/shadow 文件</li></ol><ul><li>口令配置文件</li><li>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</li></ul><ol start="3"><li> /etc/group 文件</li></ol><ul><li>组（group）的配置文件，记录Linux包含的组的信息。</li><li>每行含义：组名：口令：组标识号：组内用户列表（隐藏）</li></ul><h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><p>共有7个运行级别：</p><ol start="0"><li><p>关机</p></li><li><p>单用户【找回丢失密码】</p></li><li><p>多用户状态没有网络服务</p></li><li><p>多用户状态有网络服务</p></li><li><p>系统未使用保留给用户</p></li><li><p>图形界面</p></li><li><p>系统重启</p></li></ol><p>常用运行级别是3和5，也可以指定默认运行级别，后面演示。</p><h3 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h3><p>基本指令 <code>init [0123456]</code></p><h3 id="Centos7后运行级别说明"><a href="#Centos7后运行级别说明" class="headerlink" title="Centos7后运行级别说明"></a>Centos7后运行级别说明</h3><p>在Centos7以前，在/etc/inittab文件中进行修改</p><p>在Centos7以后进行了简化，如下：</p><p>​    multi-user.target: analogous to runlevel 3</p><p>​    graphical.target: analogous to runlevel 5</p><p>查看当前默认运行级别 <code>systemctl get-default</code></p><p>设置默认运行级别 <code>systemctl set-default xxx.target</code></p><h2 id="找回root密码-【面试题】"><a href="#找回root密码-【面试题】" class="headerlink" title="找回root密码 【面试题】"></a>找回root密码 【面试题】</h2><p>不同版本的系统操作流程略有区别，这里适用于Centos7之后的版本。</p><ol><li><p>首先启动系统，进入开机界面，在页面中按”e”进入编辑界面</p><img src="image-20211002000436645.png" alt="image-20211002000436645" style="zoom:80%;"  /></li><li><p>进入编辑界面，使用键盘上的上下键把光标往下移动，找到以”linux16”开头内容所在的行数，在行的最后面输入 <code>init=/bin/sh</code></p><img src="image-20211002000601694.png" alt="image-20211002000601694" style="zoom:80%;"  /></li><li><p>输入完成后，按快捷键<code>Ctrl + x</code>进入单用户模式</p></li><li><p>在光标闪烁的位置输入<code>mount -o remount,rw /</code>, 然后按回车键</p><img src="image-20211002000744156.png" alt="image-20211002000744156"   /></li><li><p>在新的一行最后面输入<code>passwd</code>， 完成后按键盘的回车键（Enter）。输入密码，<strong>然后再次确认密码即</strong>可(<strong>密码长度最好8位以上,但不是必须的</strong>), 密码修改成功后，会显示passwd…..的样式，说明密码修改成功</p><img src="image-20211002001001897.png" alt="image-20211002001001897"   /></li><li><p>在鼠标闪烁的位置中（最后一行中）输入<code>touch /.autorelabel</code>，完成后按键盘的回车键（Enter）</p></li><li><p>继续在光标闪烁的位置中，输入<code>exec /sbin/init</code>，完成后按键盘的回车键（Enter）,等待系统自动修改密码(<strong>这个过程时间可能有点长，耐心等待</strong>)，完成后，系统会自动重启, <strong>新的密码生效</strong>了</p></li></ol><h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><ul><li><code>man [命令或配置文件] </code>（获得帮助信息）</li><li><code>help 命令</code> （获得shell内置命令得帮助信息）</li></ul><h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><ol><li><p>pwd指令：显示当前工作目录的绝对路径</p><p>基本语法 <code>pwd</code></p></li></ol><ol start="2"><li><p>ls指令：查看当前目录的内容信息</p><p>基本语法 <code>ls [选项] [目录或文件]</code></p><p>常用选项：</p><ul><li>-a：显示当前目录所有的文件和目录，包括隐藏的</li><li>-l：以列表的方式显示信息</li></ul></li></ol><ol start="3"><li><p>cd指令：切换到指定目录</p><p>基本语法 <code>cd [参数]</code></p><p><strong>绝对路径和相对路径：</strong>绝对路径是从根目录开始，相对目录是从当前位置开始</p><p><img src="image-20211002165846507.png" alt="image-20211002165846507"></p><p>cd ~ 或者 cd：回到自己的家目录，比如你是root，则到/root；如果是tom，则到/home/tom</p><p>cd..：回到当前目录的上一级目录</p><p>案例：</p><ul><li>使用绝对路径切换到root目录 <strong>==&gt;</strong> cd /root</li><li>使用相对路径到/root，当前在/home/tom <strong>==&gt;</strong> cd ../../root</li></ul></li></ol><ol start="4"><li><p>mkdir指令：创建目录</p><p>基本语法 <code>mkdir [选项] 要创建的目录</code></p><p>常用选项</p><ul><li>-p：创建多级目录</li></ul><p>实例：</p><ul><li>创建一个目录/home/dog <strong>==&gt;</strong> mkdir /home/dog</li><li>创建多级目录/home/animal/tiger <strong>==&gt;</strong> mkdir -p /home/animal/tiger</li></ul></li></ol><ol start="5"><li><p>rmdir指令：删除空目录</p><p>基本语法 <code>rmdir [选项] 要删除的空目录</code></p><p>案例：</p><ul><li>删除目录/home/dog <strong>==&gt;</strong> rmdir /home/dog</li></ul><p>使用细节：</p><ul><li>mkdir删除的是空目录，如果目录下有内容是无法删除的。</li><li>如果需要删除非空目录，需要使用rm -rf删除</li></ul></li></ol><ol start="6"><li><p>touch指令：创建空文件</p><p>基本语法 <code>touch 文件名称</code></p><p>案例：</p><ul><li>创建一个空文件hello.txt <strong>==&gt;</strong> touch hello.txt</li></ul></li></ol><ol start="7"><li><p>cp指令：拷贝文件到指定目录</p><p>基本语法 <code>cp [选项] source dest</code></p><p>常用选项：</p><ul><li>-r：递归复制整个文件夹</li></ul><p>实例：</p><ul><li>将/home/hello.txt拷贝到/home/bbb目录下 <strong>==&gt;</strong> cp /home/hello.txt /home/bbb</li><li>将/home/bbb整个目录拷贝到/opt <strong>==&gt;</strong> cp -r /home/bbb /opt</li></ul><p>使用细节：</p><ul><li>强制覆盖不提示的方法：\cp, \cp -r </li></ul></li></ol><ol start="8"><li><p>rm指令：移除文件或目录</p><p>基本语法 <code>rm [选项] 要删除的文件或目录</code></p><p>常用选项：</p><ul><li><p>-r：递归删除整个文件夹</p></li><li><p>-f：强制删除不提示</p></li></ul><p>实例：</p><ul><li><p>将/home/hello.txt删除 <strong>==&gt;</strong> rm /home/hello.txt</p></li><li><p>递归删除整个文件夹/home/bbb <strong>==&gt;</strong> rm -rf /home/bbb</p></li></ul><p>使用细节：</p><ul><li><p>想要强制删除不提示，带上-f参数即可</p></li><li><p><strong>使用前一定慎重！！！</strong></p></li></ul></li></ol><ol start="9"><li><p>mv指令：移动文件与目录 或 重命名</p><p>基本语法：</p><ul><li><code>mv oldFileName newFileName</code> 重命名</li><li><code> mv source dest</code> 移动文件</li></ul><p>实例：</p><ul><li><p>将/home/cat.txt文件重命名为pig.txt <strong>==&gt;</strong> mv /home/cat.txt /home/pig.txt</p></li><li><p>将/home/pig.txt文件移动到/root目录下 <strong>==&gt;</strong> mv /home/pig.txt /root</p></li><li><p>移动目录/opt/bbb到/home下 <strong>==&gt;</strong> mv /opt/bbb /home</p></li></ul></li></ol><ol start="10"><li><p>cat指令：查看文件内容</p><p>基本语法 <code>cat [选项] 文件名</code></p><p>常用选项：</p><ul><li>-n： 显示行号</li></ul><p>实例：</p><ul><li>显示/etc/profile并显示行号 <strong>==&gt;</strong> cat -n /etc/profile</li></ul><p>使用细节：</p><ul><li>cat只能浏览文件，而不能修改文件。为了浏览方便，一般会带上管道命令|more</li><li>e.g. cat -n /etc/profile | more</li></ul></li></ol><ol start="11"><li><p>more指令</p><p>基本语法 <code>more 文件名</code></p><p>more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。其中内置了若干快捷键（交互的指令），如下：</p><p><img src="image-20211002211740449.png" alt="image-20211002211740449"></p><p>实例：</p><ul><li>查看/etc/profile文件 <strong>==&gt;</strong> more /etc/profile</li></ul></li><li><p>less指令</p><p>基本语法 <code>less 文件名</code></p><p>less指令用来分屏查看文件的内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。<strong>less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于大型文件有较高的效率。</strong>操作说明如下：</p><p><img src="image-20211002212230782.png" alt="image-20211002212230782"></p><p>实例：</p><ul><li>查看/etc/profile文件 <strong>==&gt;</strong> less /etc/profile</li></ul></li></ol><ol start="13"><li><p>echo指令：输出内容到控制台</p><p>基本语法 <code>echo [选项] [输出内容]</code></p><p>实例：</p><ul><li>输出环境变量$HOSTNAME <strong>==&gt;</strong> echo $HOSTNAME</li><li>输出hello world <strong>==&gt;</strong> echo “hello world” （可以不加双引号）</li></ul></li><li><p>head指令：输出文件头部内容，默认输出前10行</p><p>基本语法 <code>head [-n number] 文件名</code></p><p>案例：</p><ul><li>查看/etc/profile前5行 <strong>==&gt;</strong> head -n 5 /etc/profile</li></ul></li><li><p>tail指令：输出文件尾部内容，默认输出最后10行</p><p>基本语法：</p><ul><li><code>tail [-n number] 文件名</code> 输出最后number行文件</li><li><code>tail -f 文件名</code> 实时追踪该文档的所有更新</li></ul><p>实例：</p><ul><li>查看/etc/profile最后5行 <strong>==&gt;</strong> tail-n 5 /etc/profile</li><li>实时监控mydate.txt <strong>==&gt;</strong> tail -f mydate.txt （文件发生变化后会直接在控制台输出）</li></ul></li><li><p>&gt; 输出重定向指令 和 &gt;&gt; 追加指令</p><p>基本语法：</p><ul><li><code>ls -l &gt; 文件</code> 列表的内容写入文件中（覆盖写）</li><li><code>ls -al &gt;&gt; 文件</code> 列表的内容追加到文件末尾</li><li><code>cat 文件1 &gt; 文件2</code> 将文件1的内容覆盖到文件2</li><li><code>echo ”内容“ &gt;&gt; 文件</code> 把内容追加到文件末尾</li></ul><p>实例：</p><ul><li>将/home目录下的文件列表写入到/home/info.txt中，覆盖写入 <strong>==&gt;</strong> ls -l /home &gt; /home/info.txt （如果info.txt没有，会自动创建）</li><li>将当前日历信息追加到/home/mycal文件中 <strong>==&gt;</strong> cal &gt;&gt; /home/mycal</li></ul></li><li><p>ln指令：软链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</p><p>基本语法 <code>ln -s 原文件或目录 软链接名</code></p><p>案例：</p><ul><li>在/home目录下创建一个软链接myroot，连接到/root目录 <strong>==&gt;</strong> ln -s /root /home/myroot</li><li>删除软连接myroot <strong>==&gt;</strong> rm /home/myroot</li></ul><p>细节说明：</p><ul><li>当我们使用pwd指令查看目录时，看到的仍然是软链接所在的目录</li></ul></li><li><p>history指令：查看已执行过的历史命令，也可以执行历史命令</p><p>基本语法 <code>history [n]</code></p><p>实例：</p><ul><li>显示所有的历史命令 <strong>==&gt;</strong> history</li><li>显示最近使用过的10个指令 <strong>==&gt;</strong> history 10</li><li>执行历史编号为5的指令 <strong>==&gt;</strong> !5 （使用前先用history查看指令的历史编号）</li></ul></li></ol><h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><ol><li><p>date指令：显示当前日期</p><p>基本语法：</p><ul><li><p><code>date</code> 显示当前时间 </p></li><li><p><code>date +%Y</code> 显示当前年份 </p></li><li><p><code>date +%m</code> 显示当前月份 </p></li><li><p><code>date +%d</code> 显示当前是哪一天 </p></li><li><p><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> 显示年月日时分秒</p></li></ul></li></ol><ol start="2"><li><p>date指令：设置日期</p><p>基本语法 <code>date -s 字符串时间</code></p><p>实例：</p><ul><li>date -s “2021-6-20 16:44:30”</li></ul></li><li><p>cal指令：查看日历</p><p>基本语法 <code>cal [选项]</code></p><p>实例：</p><ul><li><p>显示当前月份的日历 <strong>==&gt;</strong> cal</p></li><li><p>显示2021年的日历 <strong>==&gt;</strong> cal 2021</p></li></ul></li></ol><h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h3><ol><li><p>find指令：从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端</p><p>基本语法 <code>find [搜索范围] [选项]</code></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td>-user&lt;用户名&gt;</td><td>查找属于指定用户名所有文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件（+n大于，-n小于，n等于，单位有k、M、G）</td></tr></tbody></table><p>实例：</p><ul><li>按文件名，查找/home目录下的hello.txt文件 <strong>==&gt;</strong> find /home -name hello.txt</li><li>按拥有者，查找/opt目录下用户名为nobody的文件 <strong>==&gt;</strong> find /opt -user nobody</li><li>查找整个linux系统下大于200M的文件 <strong>==&gt;</strong> find / -size +200M</li></ul></li><li><p>locate指令</p><p>locate指令可以快速定位文件路径。locate命令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位的文件名。Locate指令无需遍历整个文件系统，查询速度较快。为了保障查询结果的准确度，管理员必须定期更新locate时刻。</p><p>基本语法 <code>locate 文件名</code></p><p>特别说明：由于locate指令基于数据进行查询，所以第一次运行前，必须是使用updatedb指令创建locate数据库</p><p>实例：</p><ul><li>用locate指令快速定位hello.txt文件所在目录 <strong>==&gt;</strong> updatedb, locate hello.txt</li></ul></li></ol><ol start="3"><li><p>which指令：查看某个指令在哪个目录下</p><p>基本语法 <code>which 指令名</code></p><p>实例：</p><ul><li>查看ls指令在哪个目录 <strong>==&gt;</strong> which ls</li></ul></li></ol><ol start="4"><li><p>grep指令和管道符号|</p><p>grep过滤查找，管道符，“|“，表示将前一个命令输出传递给后面的命令处理。grep一般和管道符号一起使用。</p><p>基本语法 <code>grep [选项] 查找内容 源文件</code></p><p>常用选项：</p><ul><li>-n 显示匹配行及行号</li><li>-i 忽略字母大小写</li></ul><p>实例：过滤查找hello.txt中的”yes“文本</p><ul><li>写法1：cat /home/hello.txt | grep -n “yes”</li><li>写法2：grep -n “yes” /home/hello.txt</li></ul></li></ol><h2 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h2><ol><li><p>gzip/gunzip指令：只能用于压缩/解压文件</p><p>基本语法 <code>gzip/gunzip 文件名</code></p><p>使用细节：压缩后原文件会消失，解压后压缩文件会消失</p></li><li><p>zip/unzip指令：用于压缩/解压文件或文件夹</p><p>基本语法：<code>zip/unzip [选项] xxx.zip 压缩内容</code></p><p>常用选项：</p><ul><li>-r：递归压缩，即压缩目录 （zip常用）</li><li>-d&lt;目录&gt;：指定解压后文件的存放目录（unzip常用）</li></ul></li></ol><ol start="3"><li><p>tar指令：打包指令</p><p>基本语法：<code>tar [选项] xxx.tar(.gz) 打包内容</code></p><p>选项说明：</p><table><thead><tr><th>选项</th><th align="left">功能</th></tr></thead><tbody><tr><td>-c</td><td align="left">产生.tar打包文件</td></tr><tr><td>-v</td><td align="left">显示详细信息</td></tr><tr><td>-f</td><td align="left">指定压缩后的文件名</td></tr><tr><td>-z</td><td align="left">打包同时压缩</td></tr><tr><td>-x</td><td align="left">解包.tar文件</td></tr></tbody></table><p>实例：</p><ul><li>压缩多个文件，将pig.txt和cat.txt 压缩成  pc.tar.gz <strong>==&gt;</strong> tar -zcvf pc.tar.gz pig.txt cat.txt</li><li>将/home的文件夹压缩成myhome.tar.gz <strong>==&gt;</strong> tar -zcvf myhome.tar.gz /home</li><li>pc.tar.gz 解压到当前目录 <strong>==&gt;</strong> tar -zxvf pc.tar.gz</li><li>将myhome.tar.gz  解压到/opt/tmp2目录下 <strong>==&gt;</strong> tar -zxvf myhome.tar.gz <code>-C</code> opt/tmp2 (-C后面指定解压目录)</li></ul></li></ol><h2 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h2><p>在Linux中的每个用户必须属于至少一个组，不能独立于组外。在Linux中每个文件都有所有者、所在组、其他组的概念</p><p><img src="image-20211002233042774.png" alt="image-20211002233042774"></p><p>一个文件a.txt由tom创建，tom属于组1，那么a.txt的所有者是tom，所在组是组1。组1中的用户对a.txt有一定的权限。组2、组3不包含tom，它们相对于a.txt的所在组而言是其他组。</p><h3 id="文件-目录-所有者"><a href="#文件-目录-所有者" class="headerlink" title="文件/目录 所有者"></a>文件/目录 所有者</h3><p>一般为文件的创建者，谁创建了该文件，就自然成为该文件的所有者。</p><h4 id="查看文件的所有者"><a href="#查看文件的所有者" class="headerlink" title="查看文件的所有者"></a>查看文件的所有者</h4><p>可以通过ls指令查看 <code>ls -ahl</code></p><img src="image-20211003001542456.png" alt="image-20211003001542456" style="zoom: 80%;" /><h4 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h4><p>基本指令 <code>chown 用户名 文件名</code></p><p>实例：</p><ul><li>将apple.txt文件的所有者修改成tom <strong>==&gt;</strong> chown tom apple.txt</li></ul><h3 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h3><p>基本指令 <code>groupadd 组名</code></p><p>实例：</p><ul><li>创建一个monster组 <strong>==&gt;</strong> groupadd monster</li><li>创建一个用户fox，并加入到monster组中 <strong>==&gt;</strong> useradd -g monster fox</li></ul><h3 id="文件-目录-所在组"><a href="#文件-目录-所在组" class="headerlink" title="文件/目录 所在组"></a>文件/目录 所在组</h3><p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组</p><h4 id="查看文件-目录所在组"><a href="#查看文件-目录所在组" class="headerlink" title="查看文件/目录所在组"></a>查看文件/目录所在组</h4><p>可以通过ls指令查看 <code>ls -ahl</code></p><img src="image-20211003002132904.png" alt="image-20211003002132904"  /><h4 id="修改文件-目录的所在组"><a href="#修改文件-目录的所在组" class="headerlink" title="修改文件/目录的所在组"></a>修改文件/目录的所在组</h4><p>基本指令：</p><ul><li><code>chgrp 组名 文件/目录</code> 改变所在组</li><li>-R 如果是目录，使其下所有子文件或目录递归生效</li></ul><p>实例：</p><ul><li>修改orange.txt文件到fruit组 <ol><li>groupadd fruit</li><li>touch orange.txt (假设在root权限下创建，默认属于root组)</li><li>chgrp fruit orange.txt</li></ol></li><li>将/home/test目录下所有的文件和目录的所在组都改成shaolin <strong>==&gt;</strong> chgrp -R shaolin /home/test</li></ul><h3 id="其他组"><a href="#其他组" class="headerlink" title="其他组"></a>其他组</h3><p>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其它组</p><h3 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h3><p>基本指令：</p><ul><li><code>usermod -g 新组名 用户名</code></li><li><code>usermod -d 目录名 用户名</code> 改变该用户登录的初始目录 （<strong>特别说明：</strong>用户需要有进入到新目录的权限）</li></ul><p>实例：</p><ul><li>将用户zwj从原来所在组修改到wudang组 <strong>==&gt;</strong> usermod -g wudang zwj</li></ul><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>ls -l显示如下内容</p><p>-rw-r–r–.  1 root root  121 10月  2 21:37 hello.java</p><p>0-9位说明：</p><ul><li><p>第0位确定文件类型（d，-，l，c，b）<br>d是目录，相当于windows的文件夹</p><p>-是普通文件</p><p>l是链接文件，相当于windows的快捷方式<br>c是字符设备文件，鼠标，键盘<br>b是块设备，比如硬盘</p></li><li><p>第1-3位确定<strong>所有者</strong>（该文件的所有者）拥有该文件的权限 [User]</p></li><li><p>第4-6位确定<strong>所属组</strong>（同用户组的）拥有该文件的权限 [Group]</p></li><li><p>第7-9位确定<strong>其他用户</strong>拥有该文件的权限 [Other]</p></li></ul><h3 id="rwx权限"><a href="#rwx权限" class="headerlink" title="rwx权限"></a>rwx权限</h3><h4 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a>rwx作用到文件</h4><p>【r】代表可读（read）：可以读取、查看</p><p>【w】代表可写（write）：可以修改，但是不代表可以删除该文件，<strong>删除一个文件的前提条件是对该文件所在的目录有写权限</strong>，才能删除该文件</p><p>【x】代表可执行（execute）：可以被执行</p><h4 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a>rwx作用到目录</h4><p>【r】代表可读（read）：可以读取，ls查看目录内容</p><p>【w】代表可写（write）：可以修改，对目录内创建+删除+重命名目录名</p><p>【x】代表可执行（execute）：可以进入该目录</p><h3 id="文件及目录权限实际案例"><a href="#文件及目录权限实际案例" class="headerlink" title="文件及目录权限实际案例"></a>文件及目录权限实际案例</h3><p>ls -l显示如下内容</p><p>-rw-r–r–.  1 root root  121 10月  2 21:37 hello.java</p><p>10个字符确定不同用户能对文件干什么：</p><ul><li>第一个字符代表文件类型： -l d c b</li><li>其余字符每三个一组（rwx）读（r）写（w）执行（x）</li><li>第一组rw-：文件拥有者的权限是读、写但不能执行</li><li>第二组r–：与文件拥有者同一组的用户的权限是读、但不能写和执行</li><li>第三组r–-：不与文件拥有者同组的其他用户的权限是读、但不能写和执行</li></ul><p>可用数字表示为：r=4，w=2，x=1。 因此rwx = 4 + 2 + 1 = 7</p><p>其他说明：</p><ul><li>1 若是文件：硬件连接 若是目录：子目录数+文件数</li><li>root 用户</li><li>root 组</li><li>121 文件大小（字节），如果是文件夹显示4096字节</li><li>10月  2 21:37</li><li>hello.java 文件名</li></ul><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>基本指令 <code>chmod [选项,选项...] 文件/目录名</code></p><h4 id="第一种方式：-、-、-变更权限"><a href="#第一种方式：-、-、-变更权限" class="headerlink" title="第一种方式：+、-、=变更权限"></a>第一种方式：+、-、=变更权限</h4><p>u：所有者</p><p>q：所有组 </p><p>o：其他用户 </p><p>a：所有人（u、g、o的总和）</p><p>指令示例：</p><ul><li>chmod u=rwx,g=rx,o=x 文件/目录名</li><li>chmod o+w 文件/目录名</li><li>chmod a-x 文件/目录名</li></ul><p>实例：</p><ul><li>给hello.java文件的所有者读写执行的权限，给所在组读执行权限， 给其他组读执行权限 <strong>==&gt;</strong> chmod u=rwx,g=rx,0=x hello.java</li><li>给hello.java文件的所有者除去执行的权限，增加组写的权限 <strong>==&gt;</strong> chmod u-x,g+w hello.java</li><li>给hello.java文件的所有用户添加读的权限 <strong>==&gt;</strong> chmod a+r hello.java</li></ul><h4 id="第二种方式：通过数字变更权限"><a href="#第二种方式：通过数字变更权限" class="headerlink" title="第二种方式：通过数字变更权限"></a>第二种方式：通过数字变更权限</h4><p>r=4，w=2，x=1， rwx=4+2+1=7</p><p>chmod u=rwx,g=rx,o=x 文件目录名 </p><p>相当于chmod 751 文件目录</p><p>实例：</p><ul><li>将/home/hello.java文件的权限修改成 rwxr-xr-x,使用数字的方式实现 <strong>==&gt;</strong> chmod 755 /home/hello.java</li></ul><h3 id="修改文件所有者-1"><a href="#修改文件所有者-1" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><p>基本指令：</p><ul><li> <code>chown newowner 文件/目录</code>  改变所有者</li><li><code>chown newowner:newgroup 文件/目录</code> 改变所有者和所在组</li><li>-R 如果是目录，则使其下所有子文件或目录递归生效</li></ul><p>实例：</p><ul><li>将/home/hello.java文件的所有者修改成tom <strong>==&gt;</strong> chown tom /home/hello.java</li><li>将/home/test目录下所有的文件和目录的所有者都修改成tom <strong>==&gt;</strong> chown -R tom /home/test</li></ul><h2 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h2><h3 id="crond-任务调度"><a href="#crond-任务调度" class="headerlink" title="crond 任务调度"></a>crond 任务调度</h3><p>crontab 进行定时任务的设置</p><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><ul><li><p>任务调度：是指系统在某个时间执行的特定的命令或程序。</p></li><li><p>任务调度分类.</p><ul><li>系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</li><li>个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份</li></ul><p><img src="image-20211015124511506.png" alt="image-20211015124511506"></p></li></ul><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p><code>crontab [选项]</code></p><p>常用选项：</p><ul><li>-e 编辑crontab定时任务 </li><li>-l 查询crontab任务 </li><li>-r 删除当前用户所有的crontab任务</li></ul><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ul><li>设置任务调度文件：/etc/crontab</li><li>设置个人任务调度。执行crontab -e命令</li><li>接着输入任务到调度文件</li><li>例如：<ul><li>*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt </li><li>意思说每个小时的每分钟执行ls -l /etc/ &gt; /tmp/to.txt 命令</li></ul></li></ul><p>参数细节说明：</p><p>5个占位符的说明</p><p><img src="image-20211015130318394.png" alt="image-20211015130318394"></p><p>特殊符号的说明：</p><p><img src="image-20211015150607827.png" alt="image-20211015150607827"></p><p>特殊时间执行案例：</p><p><img src="image-20211015150803821.png" alt="image-20211015150803821"></p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li><p>每隔1分钟，就将当前的日期信息，追加到/tmp/mydate文件中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e </span><br><span class="line">*/1 * * * * data &gt;&gt; /tmp/mydata</span><br></pre></td></tr></table></figure></li><li><p>每隔1分钟，将当前日期和日历都追加到/home/mycal文件中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步: 编辑一个脚本文件</span><br><span class="line">vim /home/my.sh</span><br><span class="line">date &gt;&gt; /home/mycal</span><br><span class="line">cal &gt;&gt; /home/mycal</span><br><span class="line"></span><br><span class="line">第二步: 给my.sh增加执行权限 (必须，否则没权限无法执行)</span><br><span class="line">chmod u+x /home/my.sh</span><br><span class="line"></span><br><span class="line">第三步:</span><br><span class="line">crontab -e</span><br><span class="line">*/1 * * * * /home/my.sh</span><br></pre></td></tr></table></figure></li><li><p>每天凌晨2:00将mysql数据库testdb，备份到文件中，提示：指令为mysqldump -u root -p 密码 数据库 &gt;&gt; /home/bd.bak</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">0 2 * * * mysqldump -u root -proot testdb &gt; /home/db.bak</span><br></pre></td></tr></table></figure></li></ol><h4 id="crond相关指令"><a href="#crond相关指令" class="headerlink" title="crond相关指令"></a>crond相关指令</h4><p><code>crontab -r</code> 终止任务调度</p><p><code>crontab -l</code> 列出当前有哪些任务调度</p><p><code>service crond restart</code> 重启任务调度</p><h3 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行</p></li><li><p>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业</p></li><li><p>at命令是<strong>一次性定时任务计划</strong>，执行完一个任务后不再执行此任务了</p></li><li><p>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep atd</span><br></pre></td></tr></table></figure></li><li><p>示意图：</p><p><img src="image-20211015152727550.png" alt="image-20211015152727550"></p><p>执行完就会移出队列了，所以不会反复执行</p></li></ul><h4 id="at-命令格式"><a href="#at-命令格式" class="headerlink" title="at 命令格式"></a>at 命令格式</h4><p><code>at [选项] [时间]</code></p><p>输入完指令后，要连续按<strong>两次</strong>ctrl + D 结束at命令输入</p><h4 id="at-命令选项"><a href="#at-命令选项" class="headerlink" title="at 命令选项"></a>at 命令选项</h4><p><img src="image-20211015152930841.png" alt="image-20211015152930841"></p><h4 id="at-时间定义"><a href="#at-时间定义" class="headerlink" title="at 时间定义"></a>at 时间定义</h4><p><img src="image-20211015153110423.png" alt="image-20211015153110423"></p><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li><p>2天后的下午5点执行/bin/ls /home</p><p><img src="image-20211015153245525.png" alt="image-20211015153245525"></p></li><li><p>atq命令来查看系统中没有执行的工作任务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atq</span><br></pre></td></tr></table></figure></li><li><p>明天17点钟，输出时间到指定文件内，比如/root/date100.log</p><p><img src="image-20211015153405541.png" alt="image-20211015153405541"></p></li><li><p>2分钟后，输出时间到指定文件内，比如 /root/date200.log</p><p><img src="image-20211015153511968.png" alt="image-20211015153511968"></p></li><li><p>删除已经设置的任务， <code>atrm 编号</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atq // 先查看还未执行的任务编号</span><br><span class="line">atrm 4 // 删除编号为4的任务</span><br></pre></td></tr></table></figure></li></ol><h2 id="Linux-磁盘分区"><a href="#Linux-磁盘分区" class="headerlink" title="Linux 磁盘分区"></a>Linux 磁盘分区</h2><h3 id="Linux-分区"><a href="#Linux-分区" class="headerlink" title="Linux 分区"></a>Linux 分区</h3><h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><ol><li><p>Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分</p></li><li><p>Linux采用了一种叫”载入“的处理方法，它的整个文件系统包含了一整套的目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得</p></li><li><p>示意图：</p><p><img src="image-20211015162207598.png" alt="image-20211015162207598"></p></li></ol><h4 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a>硬盘说明</h4><ol><li><p>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</p></li><li><p>对于IDE硬盘，驱动驱动标识符为” hdx~ “，其中”hd“表明分区所在的设备类型，这里是指IDE硬盘了。”x“为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），”~“代表分区，前四个分区用数字1到4表示，他们是主分区和拓展分区；从5开始就是逻辑分区。</p><p>例如，hda3表示为第一个IDE硬盘上的第三个主分区或拓展分区，hdb2表示为第二个IDE硬盘上的第二个主分区或拓展分区</p></li><li><p>对于SCSI硬盘则标识为”sdx~“，SCSI硬盘是用”sd“来表示分区所在设备的类型的，其余则和IDE硬盘的标识方式一样</p></li></ol><h4 id="查看所有设备挂载情况"><a href="#查看所有设备挂载情况" class="headerlink" title="查看所有设备挂载情况"></a>查看所有设备挂载情况</h4><p>命令：<code>lsblk</code> or <code>lsblk -f</code></p><p><img src="image-20211015162634171.png" alt="image-20211015162634171"></p><p><img src="image-20211015162650314.png" alt="image-20211015162650314"></p><p>UUID是分区的唯一标识符，40位</p><h3 id="挂载的经典案例"><a href="#挂载的经典案例" class="headerlink" title="挂载的经典案例"></a>挂载的经典案例</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>以<strong>增加一块硬盘</strong>为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。</p><h4 id="如何增加一块硬盘？"><a href="#如何增加一块硬盘？" class="headerlink" title="如何增加一块硬盘？"></a>如何增加一块硬盘？</h4><ol><li>虚拟机添加硬盘</li><li>分区</li><li>格式化</li><li>挂载</li><li>设置可以自动挂载</li></ol><h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><p>在<strong>虚拟机</strong>菜单中，选择<strong>设置</strong>，然后设备列表里添加硬盘，然后一路<strong>下一步</strong>，中间只有选择磁盘大小的地方需要修改，直到完成。然后重启系统才能识别。</p><p><img src="image-20211015163555052.png" alt="image-20211015163555052"></p><h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><p>分区命令 <code>fdisk /dev/sdb</code> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev（device)这个目录中包含了所有Linux系统中使用的外部设备。但是不是存放外部设备的驱动程序。它实际上是一个访问这些外部设备的端口。我们可以非常方便的去访问这些外部设备，和访问一个文件，一个目录没有任何区别</span><br></pre></td></tr></table></figure><p>开始对 /sdb分区</p><ul><li><p>m    显示命令列表 </p></li><li><p>p    显示磁盘分区 同 fdisk -l </p></li><li><p>n    新增分区 </p></li><li><p>d    删除分区 </p></li><li><p>w    写入并退出 </p></li></ul><p>说明：开始分区后输入n，新增分区，然后选者p，分区类型为主分区。两次回车默认剩余全部空间。最后输入w写入分区并退出，若不保存退出输入q</p><p><img src="image-20211015163940155.png" alt="image-20211015163940155"></p><h5 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h5><p>格式化磁盘</p><p>分区命令：<code>mkfs -t ext4 /dev/sdb1</code></p><p>其中ext4是分区类型</p><h5 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h5><p>挂载：将一个分区与一个目录联系起来</p><p><code>mount 设备名称 挂载目录</code></p><p>例如：mount /dev/sdb1 /newdisk</p><p>解除挂载：<code>umount 设备名称 or 挂载目录</code></p><p>例如：umount /dev/sdb1 或者 umount /newdisk</p><p><strong>注意：用命令行挂载，重启后就会失效</strong></p><h5 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h5><p>永久挂载：通过修改/etc/fstab 实现挂载</p><p><img src="image-20211015164713199.png" alt="image-20211015164713199"></p><p>vim /etc/fstab打开文件</p><p>第一个位置可以写UUID或者设备号</p><p>第二个位置是挂载目录</p><p>最后一个位置写0 0即可</p><p>添加完成后，执行mount -a即刻生效</p><h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><h4 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h4><p>基本语法 <code>df -h</code></p><p><img src="image-20211015165013147.png" alt="image-20211015165013147"></p><h4 id="查询指定目录的磁盘占用情况"><a href="#查询指定目录的磁盘占用情况" class="headerlink" title="查询指定目录的磁盘占用情况"></a>查询指定目录的磁盘占用情况</h4><p>基本语法 <code>du -h</code></p><p>查询指定目录的磁盘占用情况，默认为当前目录</p><ul><li>-s 指定目录占用大小汇总</li><li>-h 带计量单位</li><li>-a 含文件</li><li>–max-depth=1 子目录深度</li><li>-c 列出明细的同时，增加汇总值</li></ul><p>实例：查询 /opt目录的磁盘占用情况，深度为1</p><p><img src="image-20211015165445951.png" alt="image-20211015165445951"></p><h3 id="磁盘情况-工作实用指令"><a href="#磁盘情况-工作实用指令" class="headerlink" title="磁盘情况 - 工作实用指令"></a>磁盘情况 - 工作实用指令</h3><ol><li><p>统计/opt文件夹下文件的个数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /opt | grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>统计/opt文件夹下目录的个数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /opt | grep &quot;^d&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>统计/opt文件夹下文件的个数，包括子文件夹里的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -lR /opt | grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>统计/opt文件夹下目录的个数，包括子文件夹里的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -lR /opt | grep &quot;^d&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>以树状显示目录结构</p><p>如果显示找不到指令，就说明没有安装tree</p><p>使用yum install tree安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree /home</span><br></pre></td></tr></table></figure></li></ol><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="Linux-网络配置原理图"><a href="#Linux-网络配置原理图" class="headerlink" title="Linux 网络配置原理图"></a>Linux 网络配置原理图</h3><p><img src="image-20211015174643678.png" alt="image-20211015174643678"></p><h3 id="查看网络IP和网关"><a href="#查看网络IP和网关" class="headerlink" title="查看网络IP和网关"></a>查看网络IP和网关</h3><h4 id="查看虚拟网络编辑器和修改IP地址"><a href="#查看虚拟网络编辑器和修改IP地址" class="headerlink" title="查看虚拟网络编辑器和修改IP地址"></a>查看虚拟网络编辑器和修改IP地址</h4><p>VMware workstation</p><p>编辑 =&gt; 虚拟网络编辑器</p><p><img src="image-20211015174822325.png" alt="image-20211015174822325"></p><h4 id="查看网关"><a href="#查看网关" class="headerlink" title="查看网关"></a>查看网关</h4><p><img src="image-20211015175139172.png" alt="image-20211015175139172"></p><h3 id="查看windows环境中的VMnet8网络配置（ipconfig指令）"><a href="#查看windows环境中的VMnet8网络配置（ipconfig指令）" class="headerlink" title="查看windows环境中的VMnet8网络配置（ipconfig指令）"></a>查看windows环境中的VMnet8网络配置（ipconfig指令）</h3><p><img src="image-20211015175316078.png" alt="image-20211015175316078"></p><h3 id="查看linux的网络配置ifconfig"><a href="#查看linux的网络配置ifconfig" class="headerlink" title="查看linux的网络配置ifconfig"></a>查看linux的网络配置ifconfig</h3><p><img src="image-20211015175350477.png" alt="image-20211015175350477"></p><h3 id="ping测试主机之间网络连通性"><a href="#ping测试主机之间网络连通性" class="headerlink" title="ping测试主机之间网络连通性"></a>ping测试主机之间网络连通性</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p>ping 目的主机 (功能描述：测试当前服务器是否可以连接目的主机)、</p><h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4><p>测试当前服务器是否可以连接百度</p><p>ping <a href="http://www.baidu.com/">www.baidu.com</a></p><h3 id="linux-网络环境配置"><a href="#linux-网络环境配置" class="headerlink" title="linux 网络环境配置"></a>linux 网络环境配置</h3><h4 id="第一种方法-自动获取"><a href="#第一种方法-自动获取" class="headerlink" title="第一种方法 (自动获取)"></a>第一种方法 (自动获取)</h4><p>登陆后，通过界面的设置自动获取ip</p><p>特点：Linux启动后会自动获取IP，缺点是每次自动获取的ip地址可能不一样</p><p><img src="image-20211015180646004.png" alt="image-20211015180646004"></p><p><img src="image-20211015180652841.png" alt="image-20211015180652841"></p><h4 id="第二种方法-指定ip"><a href="#第二种方法-指定ip" class="headerlink" title="第二种方法 (指定ip)"></a>第二种方法 (指定ip)</h4><p>说明：直接修改配置文件来指定IP，并且可以连接到外网(程序员推荐)</p><p>编辑 /etc/sysconfig/network-scripts/ifcfg-ens33</p><p>要求：将IP地址配置为静态的，比如ip地址为192.168.200.130</p><p>ifcfg-ens33 文件说明</p><p><img src="image-20211015181021651.png" alt="image-20211015181021651"></p><p>红色部分是需要修改的</p><p><strong>重启网络服务或重启系统生效</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service network restart</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="设置主机名和hosts映射"><a href="#设置主机名和hosts映射" class="headerlink" title="设置主机名和hosts映射"></a>设置主机名和hosts映射</h3><h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><ol><li>为了方便记忆，可以给Linux系统设置主机名，也可以根据需要修改主机名</li><li>指令hostname: 查看主机名</li><li>修改文件在 /etc/hostname指定</li><li>修改后，重启生效</li></ol><h4 id="设置hosts映射"><a href="#设置hosts映射" class="headerlink" title="设置hosts映射"></a>设置hosts映射</h4><ul><li><p>windows</p><p>在C:\windows\System32\drivers\etc\hosts 文件指定即可</p></li></ul><ul><li><p>linux</p><p>在/etc/hosts 文件 指定</p></li></ul><h3 id="主机名解析过程分析-Hosts-DNS"><a href="#主机名解析过程分析-Hosts-DNS" class="headerlink" title="主机名解析过程分析 (Hosts, DNS)"></a>主机名解析过程分析 (Hosts, DNS)</h3><h4 id="Hosts是什么"><a href="#Hosts是什么" class="headerlink" title="Hosts是什么"></a>Hosts是什么</h4><p>一个文本文件，用来记录<strong>IP和Hostname的映射关系</strong></p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS就是Domain Name System的缩写，域名系统</p><p>是互联网上作为域名和IP地址相互映射的一个<strong>分布式数据库</strong></p><h4 id="应用实例：用户在浏览器输入了www-baidu-com"><a href="#应用实例：用户在浏览器输入了www-baidu-com" class="headerlink" title="应用实例：用户在浏览器输入了www.baidu.com"></a>应用实例：用户在浏览器输入了<a href="http://www.baidu.com/">www.baidu.com</a></h4><ol><li><p>浏览器先检查浏览器缓存中有没有该域名解析ip地址，有就先调用这个IP完成解析；如果没有，就检查DNS解析器缓存，如果有就直接返回ip完成解析。（这两个缓存可以理解为本地解析器缓存）</p></li><li><p>一般来说，当电脑第一次成功访问某一网站后，在一定的时间内，浏览器或者操作系统会缓存它的ip地址DNS解析记录，如在命令行输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipconfig /displaydns//DNS缓存解析</span><br><span class="line">ipconifg /flushdns//手动清理dns缓存</span><br></pre></td></tr></table></figure></li><li><p>如果本地解析器缓存没有找到对应的映射，则检查系统系统中的hosts文件中有没有配置对应的域名ip映射。如果有，则完成解析并返回</p></li><li><p>如果本地DNS解析器缓存和hosts文件中均没有找到对应的ip，则到域名服务DNS进行解析</p><p><img src="image-20211015181858114.png" alt="image-20211015181858114"></p></li></ol><h2 id="进程管理-重点"><a href="#进程管理-重点" class="headerlink" title="进程管理 (重点)"></a>进程管理 (重点)</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>在Linux中，每个执行的程序都称为一个进程。每个进程都分配一个ID号(pid，进程号)。</li><li>每个进程都可能以两种方式存在。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的进程。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li><li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。</li></ol><p><img src="image-20211016160842083.png" alt="image-20211016160842083"></p><h3 id="显示系统执行的过程"><a href="#显示系统执行的过程" class="headerlink" title="显示系统执行的过程"></a>显示系统执行的过程</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>命令：<code>ps</code></p><p>可以用来查看目前系统中，有哪些进程正在执行，以及他们的执行状况，可以不加任何参数。</p><p>常用参数：</p><ul><li>-a 显示当前终端的所有进程信息</li><li>-u 以用户的格式显示进程信息</li><li>-x 显示后台进程运行的参数</li><li>-e 显示所有的进程</li><li>-f 全格式</li></ul><p><img src="image-20211016161140363.png" alt="image-20211016161140363"></p><h4 id="ps-详解"><a href="#ps-详解" class="headerlink" title="ps 详解"></a>ps 详解</h4><ol><li><p>指令：<code>ps -aux | grep xxx</code> 比如我们想看看有没有sshd服务</p></li><li><p>指令说明</p><table><thead><tr><th align="left">field</th><th>explanation</th></tr></thead><tbody><tr><td align="left">USER</td><td>进程执行用户</td></tr><tr><td align="left">PID</td><td>进程号</td></tr><tr><td align="left">%CPU</td><td>当前进程占用cpu的百分比</td></tr><tr><td align="left">%MEM</td><td>占用物理内存的百分比</td></tr><tr><td align="left">VSZ</td><td>进程占用虚拟内存大小（KB）</td></tr><tr><td align="left">RSS</td><td>进程占用的物理内存的大小（KB）</td></tr><tr><td align="left">TTY</td><td>终端名称</td></tr><tr><td align="left">STAT</td><td>运行状态，S-表示sleep休眠、s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-表示正在运行，D-短期等待，z-僵尸进程，T-被跟踪或者被停止等等</td></tr><tr><td align="left">STARTED</td><td>执行的开始时间</td></tr><tr><td align="left">TIME</td><td>占用CPU时间</td></tr><tr><td align="left">COMMAND</td><td>启动进程所用的命令和参数，如果过长会被截断显示</td></tr></tbody></table></li></ol><h3 id="终止进程-kill-和-killall"><a href="#终止进程-kill-和-killall" class="headerlink" title="终止进程 kill 和 killall"></a>终止进程 kill 和 killall</h3><p>若是某个进程执行一半需要停止时，或是以消耗了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。</p><p>基本语法：</p><p><code>kill [选项] 进程号</code> 通过<strong>进程号</strong>杀死/终止进程</p><p><code>killall 进程名称</code> 通过<strong>进程名</strong>杀死进程，也支持通配符(这在系统因负载过大而变得很慢时很有用)</p><p>常用选项：</p><ul><li>-9 强迫进程立即停止</li></ul><p>最佳实践：</p><ol><li><p>踢掉某个非法登录用户 (比如某个用户登陆的进程号是11421)</p><p>kill 11421</p></li><li><p>终止远程登陆服务sshd，在适当时候再次重启sshd服务</p><p>kill sshd对应的进程号</p><p>systemctl start sshd.service</p></li><li><p>终止多个gedit</p><p>killall gedit</p></li><li><p>强制停止一个终端</p><p>kill -9 bash对应的进程号</p></li></ol><h3 id="查看进程树-pstree"><a href="#查看进程树-pstree" class="headerlink" title="查看进程树 pstree"></a>查看进程树 pstree</h3><p>基本语法 <code>pstree [选项]</code> 可以更加直观地来看进程信息</p><p>常用选项：</p><ul><li>-p 显示进程的PID</li><li>-u 显示进程的所属用户</li></ul><h3 id="服务-service-管理"><a href="#服务-service-管理" class="headerlink" title="服务(service)管理"></a>服务(service)管理</h3><h4 id="管理指令"><a href="#管理指令" class="headerlink" title="管理指令"></a>管理指令</h4><p>基本命令 <code>service 服务名 [start|stop|restart|reload|status]</code></p><p>服务(service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，比如（mysqld，sshd 防火墙等），因此我们又称为守护进程，是Linux中非常重要的知识点</p><p>在CentOS7.0后，很多服务不再使用service，而是systemctl(后面讲)</p><h4 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h4><ol><li><p>通过 <code>setup</code> 指令进入系统服务</p><p>带*号的表示开机自动启动，可以通过空格编辑</p><p>退出按tab切换到下面的命令按钮</p><p><img src="image-20211016164739193.png" alt="image-20211016164739193"></p></li><li><p>ls -l /etc/init.d/</p><p><img src="image-20211016164433521.png" alt="image-20211016164433521"></p></li></ol><h4 id="服务的运行级别"><a href="#服务的运行级别" class="headerlink" title="服务的运行级别"></a>服务的运行级别</h4><p>linux系统有七种运行级别（runlevel）：<strong>常用的是级别3和5</strong></p><ul><li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录</li><li>运行级别2：多用户状态（没有NFS），不支持网络</li><li>运行级别3：完全的多用户状态（有NFS），登录后进入控制台命令行模式</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登陆后进入图形GUI模式</li><li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li></ul><p>开机的流程说明</p><p><img src="image-20211016164952140.png" alt="image-20211016164952140"></p><h4 id="CentOS7-0后运行级别说明"><a href="#CentOS7-0后运行级别说明" class="headerlink" title="CentOS7.0后运行级别说明"></a>CentOS7.0后运行级别说明</h4><p>multi-user.target: analogous to runlevel 3 </p><p>graphical.target: analogous to runlevel 5</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看默认运行级别</span><br><span class="line">systemctl get-default</span><br><span class="line"></span><br><span class="line">设置默认运行级别</span><br><span class="line">systemctl set-default TARGET.target</span><br></pre></td></tr></table></figure><h4 id="chkconfig-指令"><a href="#chkconfig-指令" class="headerlink" title="chkconfig 指令"></a>chkconfig 指令</h4><ul><li>通过chkconfig命令可以给服务的各个运行级别设置自 启动/关闭</li><li>chkconfig指令管理的服务在 /etc/init.d查看</li><li>注意：CentOS7.0后，很多服务使用systemctl管理</li></ul><p>基本语法：</p><ul><li><code>chkconfig --list [|grep xxx]</code> 查看服务</li><li><code>chkconfig 服务名 --list</code> 查看服务</li><li><code>chkconfig --level x 服务名 on/off</code> 对服务在x等级下的状态进行控制</li></ul><p>案例：</p><ol><li><p>对network服务在运行级别3，关闭/开启自启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig --level 3 network off/on</span><br></pre></td></tr></table></figure></li></ol><p>使用细节：chkconfig重新设置服务后，需要重启机器才能生效</p><h4 id="systemctl-管理指令"><a href="#systemctl-管理指令" class="headerlink" title="systemctl 管理指令"></a>systemctl 管理指令</h4><p>基本语法 <code>systemctl [start|stop|restart|status] 服务名</code></p><p>systemctl指令管理的服务在/usr/lib/systemd/system查看</p><h5 id="systemctl-设置服务的自启动状态"><a href="#systemctl-设置服务的自启动状态" class="headerlink" title="systemctl 设置服务的自启动状态"></a>systemctl 设置服务的自启动状态</h5><p><code>systemctl list-unit-files [|grep 服务名]</code> 查看服务开机启动状态</p><p><code>systemctl enable 服务名</code> 设置服务开机启动</p><p><code>systemctl disable 服务名</code> 关闭服务开机启动</p><p><code>systemctl is-enabled 服务名</code> 查询某个服务是否是自启动的</p><h5 id="案例：对防火墙进行操作"><a href="#案例：对防火墙进行操作" class="headerlink" title="案例：对防火墙进行操作"></a>案例：对防火墙进行操作</h5><p>查看当前防火墙状态 =&gt; systemctl status firewalld</p><p>关闭/开启防火墙 =&gt; systemctrl stop/start firewalld</p><p>细节：</p><p>关闭或启用防火墙后，立即生效 [用telnet测试某个端口即可]</p><p>这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置</p><p>如果希望设置某个服务自启动或关闭永久生效，需要用<code>sysemctl enable/disable 服务名</code></p><p>打开或关闭指定端口：</p><p>在真正的生产环境，往往需要将防火墙打开。但是问题是，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要让防火墙打开指定的端口，比如80，22，8080…</p><p><img src="image-20211016171450080.png" alt="image-20211016171450080"></p><p>firewall 指令 (重新载入才能生效)</p><ol><li><code>firewall-cmd -permanent --add-port=端口号/协议</code> 打开端口</li><li><code>firewall-cmd -permanent --remove-port=端口号/协议</code> 关闭端口</li><li><code>firewall-cmd --reload</code> 重新载入</li><li><code>firewall-cmd --query-port=端口号/协议</code> 查询端口是否开放</li></ol><h3 id="top-动态监控进程"><a href="#top-动态监控进程" class="headerlink" title="top 动态监控进程"></a>top 动态监控进程</h3><p>基本语法 <code>top [选项]</code></p><p><img src="image-20211016171831705.png" alt="image-20211016171831705"></p><p>top与ps命令很相似，他们都用来显示正在执行的进程。top和ps最大的不同之处在于，top在执行后可以更新正在运行的进程。</p><p>常用选项：</p><ul><li>-d 秒数：指定top命令每隔几秒更新，默认是3秒</li><li>-i：使top不显示任何闲置或者僵尸进程</li><li>-p：通过指定监控进程ID来仅仅监控某个进程的状态</li><li>-u 用户名：监视特定的用户(也可以在进入页面后输入u交互)</li></ul><p>交互操作：</p><ul><li>P：以CPU使用率排序，默认就是此项</li><li>M：以内存的使用率排序</li><li>N：以PID排序</li><li>q：退出top</li><li>k：终止进程</li></ul><h3 id="netstat-监控网络状态"><a href="#netstat-监控网络状态" class="headerlink" title="netstat 监控网络状态"></a>netstat 监控网络状态</h3><p>基本语法 <code>netstat [选项]</code></p><p>常用选项：</p><ul><li>-an：按一定顺序排列输出</li><li>-p：显示哪个进程在调用</li></ul><p>案例：查看服务名为sshd的服务信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -anp | grap sshd</span><br></pre></td></tr></table></figure><p><img src="image-20211016172718259.png" alt="image-20211016172718259"></p><p>第三列是linuxIP和端口，第四列是通过xhell建立连接的主机的IP和端口</p><p><img src="image-20211016172731096.png" alt="image-20211016172731096"></p><h4 id="ping-检测主机连接"><a href="#ping-检测主机连接" class="headerlink" title="ping 检测主机连接"></a>ping 检测主机连接</h4><p>一种网络检测工具，主要是用于检测远程主机是否正常，或是两部主机间的网线或网卡故障。</p><p>命令 <code>ping ip地址</code></p><h2 id="软件包管理-RPM-amp-YUM"><a href="#软件包管理-RPM-amp-YUM" class="headerlink" title="软件包管理 RPM &amp; YUM"></a>软件包管理 RPM &amp; YUM</h2><h3 id="rmp包的管理"><a href="#rmp包的管理" class="headerlink" title="rmp包的管理"></a>rmp包的管理</h3><p>rpm用于互联网下载包的打包及安装工具，它包含在某些linux分发版中。它生成具有.RPM拓展名的文件。RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。</p><p>Linux的分发版都有采用（suse，redhat，centos等），可以说是公用的行业标准。</p><h4 id="包的简单查询指令"><a href="#包的简单查询指令" class="headerlink" title="包的简单查询指令"></a>包的简单查询指令</h4><p><code>rpm -qa | grep xxx</code> 查询已安装的rpm列表</p><p>案例：查看当前系统是否安装了firefox</p><ul><li>rpm -qa | grep firefox</li></ul><h4 id="rpm包名基本格式"><a href="#rpm包名基本格式" class="headerlink" title="rpm包名基本格式"></a>rpm包名基本格式</h4><p>一个rpm包名：firefox-60.2.2-1.el7.centos.x86_64<br>名称：firefox<br>版本号：60.2.2-1<br>适用操作系统：el7.centos.x86_64 表示centos7.x的64位系统</p><p>(如果是i686、i386表示32位系统，noarch表示通用)</p><h4 id="rpm包的其他查询指令"><a href="#rpm包的其他查询指令" class="headerlink" title="rpm包的其他查询指令"></a>rpm包的其他查询指令</h4><p><code>rpm -qa</code> 查询所安装的所有rpm软件包</p><p>rpm -qa | more </p><p>rpm -qa | grep xxx (如：rpm -qa | grep firefox)</p><p>rpm -q 软件包名： 查询软件包是否安装</p><p>案例：</p><ul><li>rpm -q firefox</li></ul><p>rpm -qi 软件包名：查询软件包信息</p><p>案例：</p><ul><li>rpm -qi firefox</li></ul><p>rpm -ql 软件包名：查询软件包中的文件</p><p>案例：</p><ul><li>rpm -ql firefox</li></ul><p>rpm -qf 文件全路径名：查询文件所属的软件包</p><p>案例：</p><ul><li><p>rpm -qf /etc/passwd</p></li><li><p>rpm -qf /root/install.log</p></li></ul><h4 id="安装rpm包"><a href="#安装rpm包" class="headerlink" title="安装rpm包"></a>安装rpm包</h4><p>基本语法 <code>rpm -ivh rpm包全路径名称</code></p><p>案例：</p><ul><li>安装firefox =&gt; rpm -ivh /opt/firefox (先按tab补全再回车)</li></ul><p>参数：</p><ul><li>-i install(安装)</li><li>-v verobse(提示)</li><li>-h hash(进度条)</li></ul><h4 id="卸载rpm包"><a href="#卸载rpm包" class="headerlink" title="卸载rpm包"></a>卸载rpm包</h4><p>基本语法 <code>rpm -e rpm包名</code></p><p>案例：</p><ul><li>删除firebox软件包 =&gt; rpm -e firefox</li></ul><p>细节：</p><p>如果其他软件包依赖于你要卸载的软件包，卸载时会产生错误信息。如果必须要删除这个软件包，可以增加参数<code>--nodeps</code>，就可以强制删除。但是一般不推荐这么做，因为依赖于该软件包的程序可能无法运行。</p><p><code>rmp -e --nodeps 软件包名</code></p><h3 id="yum包的管理"><a href="#yum包的管理" class="headerlink" title="yum包的管理"></a>yum包的管理</h3><p>Yum是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并安装，可以自动处理依赖关系，并且一次安装所有依赖的软件包</p><p>基本指令</p><ul><li><code>yum list | grep xxx</code> 查询yum服务器是否有需要安装的软件</li><li><code>yum install xxx</code> 下载安装</li></ul><p>案例：</p><ul><li>使用yum的方式来安装firefox <ol><li>rpm -e firefox 先卸载</li><li>yum list | grep firefox 查询yum服务器是否有firefox</li><li>yum install firefox 安装</li></ol></li></ul><h2 id="CentOS8-0-vs-CentOS7-0"><a href="#CentOS8-0-vs-CentOS7-0" class="headerlink" title="CentOS8.0 vs. CentOS7.0"></a>CentOS8.0 vs. CentOS7.0</h2><p><img src="image-20211020165912290.png" alt="image-20211020165912290"></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><a href="https://www.bilibili.com/video/BV1Sv411r7vd?spm_id_from=333.999.0.0">【小白入门 通俗易懂】2021韩顺平 一周学会Linux_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> linux系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/09/29/hello-world/"/>
      <url>/2021/09/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> categories_test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tags_test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
