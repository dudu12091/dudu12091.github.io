<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解JVM</title>
      <link href="/2022/01/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
      <url>/2022/01/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a>JVM概述</h2><h3 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h3><p><img src="image-20220117005847459.png" alt="image-20220117005847459"></p><ul><li>JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机</li><li>JVM是运行在操作系统之上的，与硬件没有任何关系</li></ul><h3 id="Java的跨平台及原理"><a href="#Java的跨平台及原理" class="headerlink" title="Java的跨平台及原理"></a>Java的跨平台及原理</h3><p><img src="image-20220117010120531.png" alt="image-20220117010120531"></p><ul><li>跨平台：由Java编写的程序可以在不同的操作系统上运行。一次编写，多处运行</li><li>原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM) (<strong>Java虚拟机不和包括java在内的任何语言绑定，它只与class文件这种二进制文件格式所关联。</strong>无论使用何种语言进行软件开发，只要将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行，可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁)</li></ul><h3 id="JVM的组成"><a href="#JVM的组成" class="headerlink" title="JVM的组成"></a>JVM的组成</h3><p><img src="image-20220117010549260.png" alt="image-20220117010549260"></p><ul><li>类加载子系统</li><li>运行时数据区[我们主要关注这里的堆、栈、方法区]</li><li>执行引擎(一般都是JIT编译器和解释器共存)</li></ul><p><code>名词解释</code></p><ol><li><p>JIT(即时编译器): 主要影响性能。在部分商用虚拟机中（如HotSpot），Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，下文统称JIT编译器）。</p><p>即时编译器并不是虚拟机必须的部分，Java虚拟机规范并没有规定Java虚拟机内必须要有即时编译器存在，更没有限定或指导即时编译器应该如何去实现。但是，即时编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分。</p></li><li><p>解释器：负责响应时间。逐行解释字节码。</p></li></ol><h3 id="三大商业虚拟机"><a href="#三大商业虚拟机" class="headerlink" title="三大商业虚拟机"></a>三大商业虚拟机</h3><ul><li>Sun HotSpot<ul><li>它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机</li></ul></li><li>BEA JRocket<ul><li>专注于服务端应用(JRockit内部不包含解释器实现，全部代码都靠即时编译器编译后执行)</li></ul></li><li>iBM J9<ul><li>市场定位与hotspot接近，服务器端，桌面应用，嵌入式等</li></ul></li></ul><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><h3 id="类的加载分几步？"><a href="#类的加载分几步？" class="headerlink" title="类的加载分几步？"></a>类的加载分几步？</h3><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>按照JAVA虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括7个阶段：</p><ul><li>过程一：加载(Loading)</li><li>过程二：链接(Linking)，又分为三个部分<ul><li>验证(Verification)</li><li>准备(Preparation)</li><li>解析(Resolution)</li></ul></li><li>过程三：初始化(Initialization)</li><li>过程四：使用(Using)</li><li>过程五：卸载(Unloading)</li></ul><p><strong>在JAVA中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义。引用数据类型则需要进行类的加载。</strong></p><h3 id="过程一：加载-Loading"><a href="#过程一：加载-Loading" class="headerlink" title="过程一：加载(Loading)"></a>过程一：加载(Loading)</h3><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70-16426426384522.png" alt="img"></p><p>类的加载指的是将类的.class文件中的二进制数据读取到内存中，存放在运行时数据区的方法区中，并创建一个大的Java.lang.Class对象，用来封装方法区内的数据结构。</p><p>在加载类时，Java虚拟机必须完成以下三件事情：</p><ol><li>通过类的全名，获取类的二进制数据流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构(Java类模型)</li><li>在内存中创建Java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li></ol><p>对于加载过程，简言之就是将Java类的字节码文件加载到内存中，并在内存中创建出Java类的原型——<code>类模板对象</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类模板对象：Java类在JVM内存储的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期间便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</span><br></pre></td></tr></table></figure><p>对于类的二进制数据流，虚拟机可以通过多种途径获得(只要所读取的字节码符合JVM规范即可)：</p><ol><li>通过文件系统读入.class文件(最常见)</li><li>读入jar、zip等归档数据包，提取类文件</li><li>实现放在数据库中的类的二进制数据</li><li>使用类似于HTTP之类的协议通过网络加载</li><li>在运行时生成一段Class的二进制信息</li></ol><p><strong>Class实例的位置：</strong></p><p>类将.class文件加载至方法区(元空间)后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。</p><h3 id="过程二：链接-Linking"><a href="#过程二：链接-Linking" class="headerlink" title="过程二：链接(Linking)"></a>过程二：链接(Linking)</h3><h4 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2-1 验证"></a>2-1 验证</h4><p>验证：确保Class文件的字节流中包含的信息符合当前虚拟机要求，保证被加载类的正确性</p><ol><li>确保Class文件的字节流中包含信息符合当前虚拟机的要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证：<ul><li>文件格式验证<ul><li>是否以魔数oxCAFEBABE开头</li><li>主版本和副版本是否在当前Java虚拟机的支持范围内</li><li>数据中的每一项是否都拥有正确的长度等</li></ul></li><li>元数据验证<ul><li>这个类是否有除了Object之外的父类，这个类是否继承了final类？</li><li>是否实现了父类或接口中要求实现的方法？</li><li>类中的字段，方法是否与父类产生矛盾？</li></ul></li><li>字节码验证</li><li>符号引用验证</li></ul></li></ol><p><img src="image-20220124002430854.png" alt="image-20220124002430854"></p><h4 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2-2 准备"></a>2-2 准备</h4><p>准备：<strong>为类的静态变量分配内存并将其初始化为默认值</strong>，这些内存都将在<strong>方法区</strong>中分配</p><p>注意：</p><ol><li><p>这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中</p></li><li><p>这里所设置的初始值通常是数据类型默认的初始值，而不是在Java代码中被显示赋予的值</p><ul><li>同时被final和static修饰的属性，在准备阶段就会被直接赋值。如下所示，value在准备阶段就会被直接赋值123</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2-3 解析"></a>2-3 解析</h4><p>解析：将常量池中的符号引用转换为直接引用的过程(将类、接口、字段和方法的符号引用转为直接引用)</p><ol><li>虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换时无法直接被虚拟机使用的。<strong>当虚拟机运行起来时，需要从常量池中获得对应的符号引用，再在类加载过程中(初始化阶段)将其替换成直接引用，并翻译到具体的内存地址中</strong></li><li>符号引用: 符号引用以<strong>一组符号</strong>来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<strong>符号引用与虚拟机实现的内存布局无关</strong>，引用的目标并不一定已经加载到了内存中</li><li>直接引用: 直接引用可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。<strong>直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</strong>如果有了直接引用，那就说明目标必定已经存在于内存之中了</li><li>Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。<strong>在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行</strong></li><li>符号引用有：类和接口的全限定名，字段的名称和描述符，方法的名称和描述符</li></ol><h3 id="过程三：初始化-Initialization"><a href="#过程三：初始化-Initialization" class="headerlink" title="过程三：初始化(Initialization)"></a>过程三：初始化(Initialization)</h3><p>初始化：</p><ol><li><p>为类变量赋予正确的初始化值</p></li><li><p><strong>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</strong>此方法不需要定义，是javac编译器自动收集类中的所有变量的赋值动作和静态代码块中的语句合并而来</p></li><li><p>若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完成。<strong>clinit不同于类的构造方法(init)(由父及子，静态先行)</strong></p></li><li><p>Java编译器不会为所有的类都产生&lt;clinit&gt;()初始化方法。哪些类在编译为字节码后，字节码中不会包含&lt;clinit&gt;()方法？</p><ul><li>一个类中没有声明任何的静态变量，也没有静态代码块时</li><li>一个类中声明静态变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</li><li>一个类中包含static final修饰的基本数据类型的字段。如果这个static final变量不是通过方法或者构造器指定，则在链接阶段赋值；如果通过调用方法赋值，则也会生成&lt;clinit&gt;()</li></ul></li><li><p>&lt;clinit&gt;()的调用会死锁么？</p><ul><li>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span> num=<span class="number">1</span>; <span class="comment">//类变量的赋值动作</span></span><br><span class="line">    <span class="comment">//静态代码快中的语句</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        num=<span class="number">2</span>;</span><br><span class="line">        number=<span class="number">20</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="comment">// 报错:非法的前向引用</span></span><br><span class="line">        <span class="comment">// 因为在此时number变量只是被初始化为默认值，并没有被赋值，所以不能使用</span></span><br><span class="line">        <span class="comment">//System.out.println(number); </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Linking之prepare: number=0 --&gt;initial:20--&gt;10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);</span><br><span class="line">        System.out.println(ClassInitTest.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20220124013240403.png" alt="image-20220124013240403"></p><h4 id="主动引用-触发在初始化阶段的Clinit方法"><a href="#主动引用-触发在初始化阶段的Clinit方法" class="headerlink" title="主动引用(触发在初始化阶段的Clinit方法)"></a>主动引用(触发在初始化阶段的Clinit方法)</h4><ol><li><p>当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>初始化一个子类(当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化)</p></li><li><p>当虚拟机启动时，用户需要指定一个执行的主类(包含main()方法的类)，虚拟机会先初始化这个主类</p></li><li><p>JDK7开始提供的动态语言支持(涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类)</p></li><li><p>如果一个接口定义了default方法，那么直接实现或者间接实现该接口类的初始化，该接口要在其之前被初始化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 注意,如果把A接口中的默认方法注释,那么就只输出:子类初始化......</span><br><span class="line">输出:</span><br><span class="line">CompareB的初始化</span><br><span class="line">子类初始化.....</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoB</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类初始化......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareB的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h4><ol><li><p>除了以上的情况属于主动引用，其他的情况均属于被动引用。被动引用不会引起类的初始化，意味着没有&lt;clinit&gt;()的调用</p></li><li><p>调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化</p></li><li><p>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化</p></li><li><p>当通过子类引用父类的静态变量，不会导致子类初始化</p></li><li><p>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了</p></li><li><p>通过数组定义类引用，不会触发此类的初始化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 这里不会进行初始化,因为相当于parent只开辟了空间,没赋值</span><br><span class="line">Parent[] parent = <span class="keyword">new</span> Parent[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用-Using"><a href="#使用-Using" class="headerlink" title="使用(Using)"></a>使用(Using)</h3><ol><li>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，就可以使用了</li><li>开发人员可以在程序中访问和调用它的静态类成员信息(比如：静态字段、静态方法)或者使用new关键字为其创建对象实例</li></ol><h3 id="卸载-Unloading"><a href="#卸载-Unloading" class="headerlink" title="卸载(Unloading)"></a>卸载(Unloading)</h3><ol><li>类、类的加载器、类的实例之间的引用关系<ul><li>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</li><li>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象</li></ul></li></ol><p><img src="image-20220124024809213.png" alt="image-20220124024809213"></p><ol start="2"><li><p>方法区的垃圾回收</p><ul><li>方法区的垃圾回收机制主要回收两部分内容：常量池中废弃的常量和不再使用的类型</li><li>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</li><li>判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了，需要同时满足下面三个条件</li></ul><p><img src="image-20220124025423206.png" alt="image-20220124025423206"></p></li><li><p>类的卸载</p><ul><li>启动类加载器加载的类型在整个运行期间是不可能被卸载的</li><li>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的被访问，其达到unreachable的可能性极小</li><li><strong>开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾回收功能才可以做到。</strong>可以预想，稍微复杂点的应用场景中(比如: 很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)</li></ul></li></ol><h2 id="类加载器-ClassLoader"><a href="#类加载器-ClassLoader" class="headerlink" title="类加载器 ClassLoader"></a>类加载器 ClassLoader</h2><ol><li>ClassLoader的作用<ul><li>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。<strong>因此，ClassLoader在整个加载阶段只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于他是否可以运行，则由Execution Engine决定</strong></li></ul></li><li>.class文件的显示加载与隐式加载的方式是指JVM加载class文件到内存的方式(在日常开发以上两种方式一般会混合使用)<ul><li>显式加载：指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或getClassLoader().loadClass()加载class对象<ul><li>Class.forName(name)会执行类的加载、链接及初始化</li><li>getClassLoader().loadClass()只会执行类的加载</li></ul></li><li>隐式加载：则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JCM自动加载到内存中</li></ul></li></ol><h3 id="类加载器的分类与测试"><a href="#类加载器的分类与测试" class="headerlink" title="类加载器的分类与测试"></a>类加载器的分类与测试</h3><h4 id="类加载器的介绍"><a href="#类加载器的介绍" class="headerlink" title="类加载器的介绍"></a>类加载器的介绍</h4><ol><li>JVM支持两种类型的类加载器，分别为<strong>引导类加载器(Bootstrap ClassLoader)和自定义类加载器(User-Defined ClassLoader)</strong></li><li>从概念上来讲,自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器,但是Java虚拟机规范并没有这么定义,而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li><li>无论类加载器的类型如何划分, 在程序中我们常见的类加载器如下所示。除了顶层的启动类加载器外, 其余的类加载器都应当有自己的”父类”加载器</li></ol><p><img src="image-20220125011836402.png" alt="image-20220125011836402"></p><p><img src="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/image-20220125012046868.png" alt="image-20220125012046868"></p><h4 id="启动-引导-类加载器-Bootstrap-ClassLoader"><a href="#启动-引导-类加载器-Bootstrap-ClassLoader" class="headerlink" title="启动(引导)类加载器 Bootstrap ClassLoader"></a>启动(引导)类加载器 Bootstrap ClassLoader</h4><ol><li>这个类加载使用C/C++语言实现的, 嵌套在JVM内部</li><li><strong>它用来加载Java的核心类库(JAVA_HOME/jre/lib/rt.jar、resource.jar或sum.boot.class.path路径下的内容),用于提供JVM自身需要的类(String类就是使用的这个类加载器)</strong></li><li><strong>由于安全考虑,Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</strong></li><li>并不继承自java.lang.ClassLoader,没有父加载器</li><li>加载扩展类和应用程序类加载器,并指定为他们的父类加载器</li></ol><p><img src="image-20220125012335192.png" alt="image-20220125012335192"></p><h4 id="扩展类加载器-Extension-ClassLoader"><a href="#扩展类加载器-Extension-ClassLoader" class="headerlink" title="扩展类加载器 Extension ClassLoader"></a>扩展类加载器 Extension ClassLoader</h4><ol><li>Java语言编写,由sum.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类,父类加载器为启动类加载器</li><li><strong>从java.ext.dirs系统属性所指定的目录中加载类库, 或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载</strong></li></ol><h4 id="应用程序-系统-类加载器-App-ClassLoader"><a href="#应用程序-系统-类加载器-App-ClassLoader" class="headerlink" title="应用程序(系统)类加载器 App ClassLoader"></a>应用程序(系统)类加载器 App ClassLoader</h4><ol><li>java语言编写,由sum.misc.Launcher$AppClassLoader实现</li><li>派生于ClassLoader类,父类加载器为扩展类加载器</li><li><strong>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</strong></li><li><strong>该类加载是程序中默认的类加载器, 一般来说, Java应用的类都是由它来完成加载</strong></li><li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li></ol><h4 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h4><ol><li>在Java的日常应用程序开发中, 类的加载几乎是由上述3种类加载器相互配合执行的, 在必要时, 我们可以自定义类加载器, 来定制类的加载方式(自定义类加载器通常需要继承于ClassLoader)</li><li>体现Java语言强大生命力和巨大魅力的关键因素之一便是, Java 开发者可以自定义类加载器来实现类库的动态加载, 加载源可以是本地的JAR包, 也可以是网络上的远程资源</li><li>自定义 ClassLoader 的子类时候,我们常见的会有两种做法<ul><li>重写loadClass()方法(<strong>不推荐</strong>,这个方法会保证类的双亲委派机制)</li><li>重写findClass()方法 –&gt; <strong>推荐</strong></li><li>这两种方法本质上差不多, 毕竟loadClass()也会调用findClass(), 但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法, 根据参数指定类的名字, 返回对应的Class对象的引用。</li></ul></li></ol><h4 id="Class-forName-与ClassLoader-loadClass-的区别"><a href="#Class-forName-与ClassLoader-loadClass-的区别" class="headerlink" title="Class.forName()与ClassLoader.loadClass()的区别"></a>Class.forName()与ClassLoader.loadClass()的区别</h4><ol><li>Class.forName(): 是一个静态方法, 最常用的是Class.forName(String className); 根据传入的类的全限定名返回一个 Class 对象。该方法在将 Class 文件加载到内存的同时, 会执行类的初始化。如:Class.forName(“com.atguigu.java.HelloWorld”);</li><li>ClassLoader.loadClass(): 这是一个实例方法, 需要一个 ClassLoader 对象来调用该方法。该方法将 Class 文件加载到内存时, 并不会执行类的初始化, 直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象, 所以可以根据需要指定使用哪个类加载器。</li></ol><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><strong>工作原理</strong></p><ol><li>如果一个类加载收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类加载器去执行</li><li>如果父类加载器还存在其父类加载器, 则进一步向上委托, 依次递归, 请求最终将到达顶层的启动类加载器</li><li>如果父类的加载器可以完成类的加载任务, 就成功返回, 倘若父类加载器无法完成此加载任务, 子加载器才会尝试自己去加载, 这就是双亲委派模式</li></ol><p><img src="image-20220125013633831.png" alt="image-20220125013633831"></p><p><strong>本质</strong></p><p>规定了类加载的顺序是: 引导类加载器先加载, 若加载不到, 由扩展类加载器加载, 若还加载不到, 才会由系统类加载器或自定义的类加载器进行加载</p><p><img src="image-20220125013754090.png" alt="image-20220125013754090"></p><p><strong>源码分析</strong></p><p>(双亲委派机制在java.lang.ClassLoader.loadClass(String,boolean)接口中体现)</p><ol><li>先在当前加载器的缓存中查找有无目标类, 如果有, 直接返回</li><li><strong>判断当前加载器的父加载器是否为空, 如果不为空, 则调用parent.loadClass(name, false)接口进行加载</strong></li><li><strong>反之, 如果当前加载器的父类加载器为空, 则调用findBootstrapClassOrNull(name)接口, 让引导类加载器进行加载</strong></li><li>如果通过以上3条路径都没能成功加载, 则调用findClass(name)接口进行加载。该接口最终会调用java.lan g.ClassLoader接口的defineClass系列的native接口加载目标Java类</li><li>双亲委派的模型就隐藏在这第2和第3步中</li></ol><p><strong>双亲委派机制优势</strong></p><ol><li>避免类的重复加载, 确保一个类的全局唯一性(当父ClassLoader已经加载了该类的时候, 就没有必要子ClassLoader再加载一次)</li><li>保护程序安全, 防止核心API被随意篡改<br>(自定义类java.lang.String类是无法正确运行的)</li></ol><p><strong>双亲委托模式的弊端</strong></p><p>检查类是否加载的委托过程是单向的, 这个方式虽然从结构上说比较清晰, 使各个ClassLoader的职责非常明确, 但是同时会带来一个问题, 即顶层的ClassLoader无法访问底层的ClassLoader所加载的类</p><p><strong>结论</strong></p><p>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型, 只是建议采用这种方式而已。比如在Tomcat中, 类加载器所采用的加载机制就和传统的双亲委派模型有一定区别, 当缺省的类加载器接收到一个类的加载任务时, 首先会由它自行加载, 当它加载失败时,才会将类的加载任务委派给它的超类加载器去执行, 这同时也是Servlet规范推荐的一种做法</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>作用：</p><ul><li>用来存储指向下一条指令的地址, 也是即将要执行的指令代码。由执行引擎读取下一条指令</li></ul><p>特点：</p><ul><li>是线程私有的、不会存在内存溢出</li></ul><p>注意：</p><ul><li>在物理上，程序计数器是用寄存器实现的，是整个cpu中最快的一个执行单元</li><li>它是唯一一个在java虚拟机规范中没有OOM(内存溢出)的区域</li></ul><p>解释：</p><ul><li>每个线程都有一个程序计数器, 是线程私有的, 就是一个指针, 指向方法区中的方法字节码(用来存储指向下一条指令的地址, 也是即将要执行的指令代码), 由执行引擎读取下一条指令, 是一个非常小的内存空间,几乎可以忽略不记</li><li>这块内存区域很小, 它是当前线程所执行的字节码的行号指示器, 字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>如果执行的是一个Native方法, 那这个计数器是undefined</li></ul><p><img src="image-20220126010837676.png" alt="image-20220126010837676"></p><p><img src="image-20220126010852317.png" alt="image-20220126010852317"></p><p><strong>使用PC寄存器存储字节码指令地址有什么用呢?</strong></p><ol><li>因为CPU需要不停的切换各个线程, 这时候切换回来以后, 就得知道接着从哪开始继续执行</li><li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</li></ol><p><strong>PC寄存器为什么设定为线程私有?</strong></p><p>为了能够准确记录各个线程正在执行的当前字节码指令地址, 最好的办法自然是为每一个线程都分配一个PC寄存器</p><p><strong>关于线程在JVM中的说明:</strong></p><ol><li>在Hotspot JVM里, 每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行以后, 此时一个操作系统的本地线程也同时创建。Java线程执行终止后, 本地线程也会被回收</li><li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化完毕, 它就会调用Java线程中的run方法</li></ol><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><h3 id="本地接口-Native-Interface"><a href="#本地接口-Native-Interface" class="headerlink" title="本地接口 Native Interface"></a>本地接口 Native Interface</h3><ol><li>本地接口的作用是融合不同的编程语言为Java所用, 它的初衷是融合C/C++程序, Java诞生的时候是C/C++横行的时候, 要想立足, 必须由调用C/C++程序, 于是就在内存中专门开辟了一块区域处理标记为native的代码, 它的具体做法是在Native Method Stack中登记native方法, 在Execution Engine执行时加载native libraies</li><li>目前该方法的使用的越来越少了, 除非是与硬件有关的应用, 比如通过Java程序驱动打印机或者Java系统管理生产设备, 在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达,比如可以使用Socket通信, 也可以使用Web Service等等</li></ol><h3 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈 Native Method Stack"></a>本地方法栈 Native Method Stack</h3><p>它的具体做法是Native Method Stack中登记native方法, 在Execution Engine 执行时加载本地方法库</p><p>native方法的举例: Object类中的clone、wait、notify、 hashCode 等 Unsafe类都是native方法</p><p><img src="image-20220126012043805.png" alt="image-20220126012043805"></p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每创建一个线程就会创建一个Java栈, 每一个Java栈中都会有很多栈帧(局部变量表 | 操作数栈 | 动态链接 | 方法返回地址 | 一些附加信息)</p><p><strong>注意:</strong> 虚拟机栈中不存在GC(垃圾回收),但是存在StackOverflowError和OOM</p><p><strong>解释:</strong></p><ol><li>虚拟机栈(Java Virtual Machine Stacks)和线程是紧密联系的, <strong>每创建一个线程时就会对应创建一个Java栈</strong>, 所以Java栈也是”线程私有”的内存区域</li><li>这个栈中又会对应包含多个栈帧, <strong>每调用一个方法时就会往栈中创建并压入一个栈帧</strong>, 栈帧是用来存储方法数据和部分过程结果的数据结构</li><li>每一个方法从调用到最终返回结果的过程, 就对应一个栈帧从入栈到出栈的过程[先进后出]</li></ol><p><strong>栈帧中有如下部分组成:</strong></p><p><img src="image-20220126012716810.png" alt="image-20220126012716810"></p><p>可能导致栈内存溢出(StackOverflowError)的原因：</p><ol><li>栈帧过多导致栈内存溢出(方法的递归调用,没设置正确停止条件)</li><li>局部数组过大。当函数内部的数组过大时,有可能导致堆栈溢出</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">    <span class="comment">//sayHello()发生了递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoT</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            sayHello();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            sayHello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Java虚拟机规范允许<strong>Java栈的大小是动态的或者是固定不变的</strong>(可以通过-Xss参数调整栈的大小)</p><ol><li>如果采用固定大小的Java虚拟机栈, 那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定</li><li>如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量, Java虚拟机将会抛出一个<strong>StackoverflowError</strong></li><li>如果Java虚拟机栈可以动态扩展, 并且在尝试扩展的时候无法申请到足够的内存, 或者是在创建新的线程时就没有足够的内存区创建对应的虚拟机栈, 那Java虚拟机将会抛出一个<strong>OutOfMemoryError</strong></li></ol><p><strong>栈和堆的区别是什么?</strong></p><ol><li>从GC、OOM、StackOverflowError的角度<ul><li>栈中不存在GC, 当固定大小的栈会发生StackOverflowError,动态的会发生OOM。堆中GC、OOM、StackOverflowError都存在</li></ul></li><li>从堆栈的执行效率角度<ul><li>栈的执行效率高于堆</li></ul></li><li>内存大小, 数据结构<ul><li>堆的空间比栈的大一般, 栈是一种FIFO先进后出的模型。堆中结构复杂,可以有链表、数组等</li></ul></li><li>栈管运行, 堆管存储</li></ol><h3 id="局部变量表-LocalVariables"><a href="#局部变量表-LocalVariables" class="headerlink" title="局部变量表 LocalVariables"></a>局部变量表 LocalVariables</h3><ol><li><strong>定义为一个数字数组, 主要用于存储方法参数和定义在方法体内的局部变量</strong>(这些数据类型包括各种基本数据类型、对象引用(reference)以及return Address类型)</li><li>由于局部变量是建立在线程的栈上, 是线程私有数据, 因此不存在数据安全问题</li><li><strong>局部变量表所需容量大小是在编译期确定下来的。</strong>(并保存在方法Code属性的maximum local variables数据项中, 在方法运行期间不会改变局部变量表的大小的)</li></ol><p>假设有这样一个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用javap -v 类.class 或者使用jclasslib</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVariableTest test=<span class="keyword">new</span> LocalVariableTest();</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        String name=<span class="string">&quot;xiaozhi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap -v LocalVariableTest.class可以查看字节码文件</p><p><img src="image-20220203011447785.png" alt="image-20220203011447785"></p><p><img src="image-20220203011500652.png" alt="image-20220203011500652"></p><ol start="4"><li>关于slot的理解(引用数据类型(方法的返回地址)占用1个slot)<ul><li>局部变量表中基本的存储单元是slot(变量槽)</li><li>在局部变量表中, 32位以内的类型只占有一个slot(包括引用数据类型), 64位的类型(long和double)占有两个slot</li><li>byte、short、char在存储前被转换为int, boolean也被转换为int(0表示fasle,非0表示true)。long和double则占据两个slot</li></ul></li><li>Jvm会为局部变量表中的每一个slot都分配一个访问索引, 通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>如果需要访问局部变量表中一个64bit的局部变量值时, 只需要使用前一个索引即可(比如:访问long或double类型变量)</li></ol><p><img src="image-20220203011934165.png" alt="image-20220203011934165"></p><ol start="7"><li>如果当前帧是由构造方法或者实例方法创建,那么该对象引用this将会放在index为0的slot处</li></ol><p><img src="image-20220203012622593.png" alt="image-20220203012622593"></p><ol start="8"><li>栈帧中的局部变量表中的槽位是可以复用的, 如果一个局部变量过了其作用域, 那么在其作用域之后申请的新的局部变量就很可能会复用过期局部变量的槽位, 从而达到节省资源的目的</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVar2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时的b就会复用a的槽位</span></span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>与GC Roots的关系: 局部变量表中的变量也是重要的垃圾回收根节点, 只要被局部变量表中直接或间接引用的对象都不会被回收</li></ol><h3 id="操作数栈-operand-stack"><a href="#操作数栈-operand-stack" class="headerlink" title="操作数栈 operand stack"></a>操作数栈 operand stack</h3><ol><li>我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>,其中的栈指的就是操作数栈。</li><li>每一个独立的栈帧中除了包含局部变量表以外, 还包含了一个<strong>后进先出</strong>的操作数栈, 也可以称之为<strong>表达式栈</strong></li><li>操作数栈, 在方法执行过程中, 根据字节码指令, 往栈中写入数据或提取数据, 即入栈或出栈</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值, 其所需的最大深度<strong>在编译期就定义好了</strong>, 保存在方法的Code属性中, 为max_stack的值</li><li>栈中的任何一个元素都是可以任意的Java数据类型<ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li>如果被调用的方法带有返回值的话, 其返回值将会被压入当前栈帧的操作数栈中, 并更新PC寄存器中下一条需要执行的字节码指令</li><li>操作数栈, 主要用于保存计算机过程的中间结果, 同时作为计算过程中变量临时的存储空间</li></ol><p>例子1：</p><p><img src="image-20220203013337835.png" alt="image-20220203013337835"></p><p><img src="image-20220203013503375.png" alt="image-20220203013503375"></p><p><img src="image-20220203013541415.png" alt="image-20220203013541415"></p><p><img src="image-20220203013603745.png" alt="image-20220203013603745"></p><p><img src="image-20220203013617844.png" alt="image-20220203013617844"></p><p><img src="image-20220203013701158.png" alt="image-20220203013701158"></p><p><img src="image-20220203013713014.png" alt="image-20220203013713014"></p><p><img src="image-20220203013759063.png" alt="image-20220203013759063"></p><p><img src="image-20220203013831812.png" alt="image-20220203013831812"></p><p>例子2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//byte、short、char、boolean:都以int型保存</span></span><br><span class="line">        <span class="keyword">byte</span> i=<span class="number">15</span>;</span><br><span class="line">        <span class="keyword">short</span> j=<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> k=i+j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> m=<span class="number">12L</span>;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">800</span>;</span><br><span class="line">        <span class="comment">//存在宽化类型转换</span></span><br><span class="line">        m=m*n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20220203014103324.png" alt="image-20220203014103324"></p><p><img src="image-20220203014133084.png" alt="image-20220203014133084"></p><ol start="8"><li>何为栈顶缓存技术？<ul><li>前面提过, 基于栈式架构的虚拟机所使用的零地址指令更加紧凑,但完成一项操作的时候必然需要使用更多的入栈和出栈指令, 这同时也就意味着将需要更多的指令分派(instruction dispatch)次数和内存读/写次数。</li><li>由于操作数是存储在内存中的, 因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个题, HotSpot JVM的设计者们提出了栈顶缓存(ToS,Top-of-Stack Cashing)技术, <strong>将栈顶元素缓存在物理CPU的寄存器中</strong>,以此降低对内存的读/写次数, 提升执行引擎的执行效率</li><li>有关栈顶缓存技术需要关注两个核心问题：<ul><li>缓存了栈顶附近的多少个元素？如果缓存了n个元素，那么就叫n-TOS caching；</li><li>缓存带有多少种“状态”？如果有n种状态那么就叫n-state TOS caching。</li></ul></li></ul></li></ol><h3 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接 Dynamic Linking"></a>动态链接 Dynamic Linking</h3><p><img src="image-20220204005348435.png" alt="image-20220204005348435"></p><ol><li>运行时常量池位于方法区, 字节码中的常量池结构如下:</li></ol><p><img src="image-20220204005520368.png" alt="image-20220204005520368"></p><ol start="2"><li>为什么需要常量池呢？<ul><li>常量池的作用, 就是为了提供一些符号和常量, 便于指令的识别。下面提供一张测试类的运行时字节码文件格式</li></ul></li></ol><p><img src="image-20220204010016985.png" alt="image-20220204010016985"></p><p><img src="image-20220204010034361.png" alt="image-20220204010034361"></p><ol start="3"><li>每一个栈帧内部都包含一个指向运行时常量池Constant pool或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令</li><li>在Java源文件被编译成字节码文件中时, 所有的变量和方法引用都作为符号引用(symbolic Refenrence)保存在class字节码文件的常量池里。比如: 描述一个方法调用了另外的其他方法时,就是通过常量池中指向方法的符号引用来表示的,那么动态链接的作用就是为了将这些符号引用(#)最终转换为调用方法的直接引用</li><li><strong>方法的调用: (小插曲)难点</strong><ol><li>静态链接(早期绑定): 当一个字节码文件被装载进JVM内部时, 如果被调用的目标方法在编译期可知, 且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接 (invokestatic | invokespecial)</li><li>动态链接(晚期绑定): 如果被调用的方法在编译期无法被确定下来,也就是说,只能够在程序运行期将调用方法的符号引用转换为直接引用,由于这种引用转换过程具备动态性,因此也就被称之为动态链接。**<code>体现了多态</code>** (invokevirtual | invokeinterface)</li><li><strong><code>非虚方法:</code></strong> 如果方法在编译器就确定了具体的调用版本,这个版本在运行时是不可变的。这样的方法称为非虚方法<br><code>(静态方法、私有方法、final方法、实例构造器(实例已经确定,this()表示本类的构造器)、父类方法(super调用)都是非虚方法)</code></li><li>其他所有体现多态特性的方法称为虚方法</li><li>如下指令要重点掌握</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通调用指令:</span><br><span class="line">1.invokestatic: 调用静态方法, 解析阶段确定唯一方法版本;</span><br><span class="line">2.invokespecial: 调用&lt;init&gt;方法、私有及父类方法,解析阶段确定唯一方法版本;</span><br><span class="line">3.invokevirtual: 调用所有虚方法；</span><br><span class="line">4.invokeinterface: 调用接口方法；</span><br><span class="line">动态调用指令(Java7新增):</span><br><span class="line">5.invokedynamic:动态解析出需要调用的方法,然后执行 .</span><br><span class="line">前四条指令固化在虚拟机内部,方法的调用执行不可人为干预,而invokedynamic指令则支持由用户确定方法版本。</span><br><span class="line">    其中invokestatic指令和invokespecial指令调用的方法称为非虚方法</span><br><span class="line"></span><br><span class="line">    其中invokevirtual(final修饰的除外, JVM会把final方法调用也归为invokevirtual指令, 但要注意final方法调用不是虚方法)、invokeinterface指令调用的方法称称为虚方法。</span><br></pre></td></tr></table></figure><ol start="6"><li>关于invokedynamic指令<ol><li>JVM字节码指令集一直比较稳定, 一直到java7才增加了一个invokedynamic指令, 这是Java为了实现【动态类型语言】支持而做的一种改进</li><li>动态类型语言和静态类型语言两者的却别就在于对类型的检查是在编译期还是在运行期, 满足前者就是静态类型语言, 反之则是动态类型语言。</li><li>Java是静态类型语言(尽管lambda表达式为其增加了动态特性), js, python是动态类型语言</li></ol></li></ol><h3 id="方法返回地址-Return-Address"><a href="#方法返回地址-Return-Address" class="headerlink" title="方法返回地址 Return Address"></a>方法返回地址 Return Address</h3><p>存放调用该方法的PC寄存器的值</p><p>执行引擎遇到任意一个方法返回的字节码指令(return), 会有返回值传递给上层的方法调用者, 简称正常完成出口</p><ol><li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</li><li>在字节码指令中, 返回指令包含ireturn(当返回值是boolena、byte、char、short和int类型时使用)、lreturn、freturn、dreturn以及areturn(引用类型的)</li><li>另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用</li></ol><p><img src="image-20220204011302112.png" alt="image-20220204011302112"></p><p>在方法执行的过程中遇到了异常(Exception), 并且这个异常没有在方法内进行处理, 也就是只要在本方法的异常表中没有搜素到匹配的异常处理器, 就会导致方法退出, 简称异常完成出口</p><h3 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h3><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如, 对程序调试提供支持的信息</p><h3 id="问题小结与扩展"><a href="#问题小结与扩展" class="headerlink" title="问题小结与扩展"></a>问题小结与扩展</h3><ol><li>栈溢出的情况? 栈溢出:StackOverflowError<br>栈中是不存在GC的, 存在OOM和StackOverflowError<ul><li>栈的大小可以是固定大小的, 也可以是动态变化(动态扩展)的<br>如果是固定的, 那么会抛出StackOverflowError<br>如果是动态扩展的, 那么会抛出OOM异常(java.lang.OutOfMemoryError)</li></ul></li><li>调整栈大小, 就能保证不出现溢出吗?<ul><li>不能。因为调整栈大小, 只会减少出现溢出的可能, 栈大小不是可以无限扩大的, 所以不能保证不出现溢出</li></ul></li><li>分配的栈内存越大越好吗?<ul><li>不是, 因为增加栈大小 ,会造成每个线程的栈都变的很大, 使得一定的栈空间下, 能创建的线程数量会变小</li></ul></li><li>垃圾回收是否会涉及到虚拟机栈?<ul><li>不会; 垃圾回收只会涉及到方法区和堆中,方法区和堆也会存在溢出的可能。程序计数器, 只记录运行下一行的地址, 不存在溢出和垃圾回收。虚拟机栈和本地方法栈, 都是只涉及压栈和出栈, 可能存在栈溢出, 不存在垃圾回收</li></ul></li></ol><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的概述-共享-垃圾回收"><a href="#堆的概述-共享-垃圾回收" class="headerlink" title="堆的概述(共享|垃圾回收)"></a>堆的概述(共享|垃圾回收)</h3><ol><li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li><li>堆可以在物理上不连续的内存空间中，但在逻辑上是连续的</li><li><strong>Java堆区在JVM启动的时候即被创建，其空间大小也是确定的。是JVM管理最大的一块内存空间</strong></li><li><strong>所有的线程共享Java堆, 在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer,TLAB)</strong></li><li>在方法结束后, 堆中的对象不会马上被移除, 仅仅在垃圾收集的时候才会被移除 (注意: 一个进程就是一个JVM实例, 一个进程中包含多个线程)</li></ol><p>举例，有如下程序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleHeap</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My ID is &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHeap sl = <span class="keyword">new</span> SimpleHeap(<span class="number">1</span>);</span><br><span class="line">        SimpleHeap s2 = <span class="keyword">new</span> SimpleHeap(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20220206204201992.png" alt="image-20220206204201992"></p><h3 id="堆的内存结构"><a href="#堆的内存结构" class="headerlink" title="堆的内存结构"></a>堆的内存结构</h3><ol><li>现在垃圾收集器大部分都基于分带收集理论设计的, 堆空间细分为:</li></ol><p><img src="image-20220206204424256.png" alt="image-20220206204424256"></p><ol start="2"><li>jdk1.7 堆中的结构</li></ol><p><img src="image-20220206204534598.png" alt="image-20220206204534598"></p><ol start="2"><li>jdk 1.8 堆中的结构</li></ol><p><img src="image-20220206204552804.png" alt="image-20220206204552804"></p><h3 id="堆空间大小的设置-Xms-Xmx"><a href="#堆空间大小的设置-Xms-Xmx" class="headerlink" title="堆空间大小的设置 -Xms -Xmx"></a>堆空间大小的设置 -Xms -Xmx</h3><ol><li>Java堆区用于存储Java对象实例, 那么堆的大小在JVM启动时就已经设定好了, 大家可以通过选项”-Xmx 和 -Xms”来设置</li><li>-Xms(默认是物理内存的1/64): 表示堆区的起始内存</li><li>-Xmx(默认是物理内存的1/4): 则用于表示堆区的最大内存</li><li>通常会将-Xms和-Xmx两个参数配置相同的值, 其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新计算堆区的大小, 从而提升性能</li></ol><p>案例演示:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms:600m</span></span><br><span class="line"><span class="comment"> * -Xmx:600m</span></span><br><span class="line"><span class="comment"> * 查看设置的参数:</span></span><br><span class="line"><span class="comment"> * 方式一(cmd中):jps  / jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> * 方式二(XX:+PrintGCDetails)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory()/<span class="number">1024</span>/<span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory()/<span class="number">1024</span>/<span class="number">1024</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms:&quot;</span>+initialMemory+<span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx:&quot;</span>+maxMemory+<span class="string">&quot;M&quot;</span>);</span><br><span class="line">        <span class="comment">//TimeUnit.SECONDS.sleep(1000000);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20220206210426022.png" alt="image-20220206210426022"></p><p>发现在计算堆空间大小时并没有算上元空间</p><h3 id="新生代与老年代参数设置-NewRation-SurvivorRatio"><a href="#新生代与老年代参数设置-NewRation-SurvivorRatio" class="headerlink" title="新生代与老年代参数设置 NewRation SurvivorRatio"></a>新生代与老年代参数设置 NewRation SurvivorRatio</h3><ol><li>配置新生代与老年代在堆结构占比<ul><li>默认: -XX:NewRatio=2, 表示新生代与老年代的比例为1:2，新生代占1, 老年代占2, 新生代占整个堆的1/3</li><li>可以修改 -XX:NewRatio=4, 表示新生代占1, 老年代占4,新生代占整个堆的1/5</li></ul></li></ol><p><img src="image-20220206211817488.png" alt="image-20220206211817488"></p><ol start="2"><li>-XX: SurvivorRatio调整这个空间比例(Eden空间和另外两个Survivor空间所占的比例是8:1:1)</li><li>-Xmn: 设置新生代最大内存大小,一般使用默认值就可以了</li><li>几乎所有的Java对象都是在Eden区被new出来的, 绝大部分的Java对象的销毁都在新生代进行的</li></ol><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ol><li>一般过程(图解)</li></ol><p><img src="image-20220206212005550.png" alt="image-20220206212005550"></p><p>Eden区满后会开始进行垃圾回收(YGC/Minor GC)，此时幸存下来的对象会放入s0/s1中的一个，s0/s1会有一个区域为空，为空的也叫to区，另一个叫from区。每次YGC，都会把Eden和from区中幸存的对象放入to区。from区的对象存活时间达到阈值之后会放入老年代。</p><p><img src="image-20220206215243327.png" alt="image-20220206215243327"></p><ol start="2"><li>复制算法详解</li></ol><p>(Eden满了,就会触发gc(minor gc),而gc就会把标识为垃圾的对象干掉, 不是垃圾的对象就要转移到幸存区, 把Eden让出来给新的对象用)</p><p><img src="image-20220206215639029.png" alt="image-20220206215639029"></p><p><img src="image-20220206215851303.png" alt="image-20220206215851303"></p><p><img src="image-20220206215907928.png" alt="image-20220206215907928"></p><p>每次有对象从eden或from区放到to区，age都会+1</p><h3 id="Minor-GC-Major-GC-Full-GC"><a href="#Minor-GC-Major-GC-Full-GC" class="headerlink" title="Minor GC | Major GC | Full GC"></a>Minor GC | Major GC | Full GC</h3><ol><li><p>YONG GC(minor GC): 发生在新生代</p><ul><li><p>只针对新生代区域的GC, 指发生在新生代的垃圾收集动作, 因为大多数Java对象存活率都不高, 所以Minor GC非常频繁, 一般回收速度也比较快</p></li><li><p>当Eden区满时, 会触发minor GC , Survivor满不会引发GC</p></li><li><p>minor gc 会引发STW,暂停其他用户线程,等垃圾回收结束,用户线程才能恢复</p></li><li><p>```<br>STW (stop the world): 指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应, 有点像卡死的感觉，这个停顿称为STW。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. Major GC: 发生在老年代</span><br><span class="line"></span><br><span class="line">   - major GC 是回收老年代的垃圾；major gc 的速度一般比Minor gc 慢10倍以上,STW时间更长</span><br><span class="line"></span><br><span class="line">3. Full GC: 收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式</span><br><span class="line"></span><br><span class="line">   - full GC是回收老年代和年轻代的垃圾</span><br><span class="line">   - full gc 是开发调优中尽量避免的, 这样暂时时间会短一些</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">### 针对不同年龄阶段的对象分配原则</span><br><span class="line"></span><br><span class="line">1. 优先分配到Eden</span><br><span class="line">2. 大对象直接分配到老年(尽量避免程序中出现过多的大对象)</span><br><span class="line">3. 长期存活的对象分配到老年代</span><br><span class="line">4. 动态对象年龄判断</span><br><span class="line">   - (如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半, 年龄大于或等于该年龄对象可以直接进入老年代, 无须等到MaxTenurningThreshold中要求的年龄)</span><br><span class="line">5. JDK6之后, 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC, 否则将进行Full GC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### TLAB(Thread Local Allocation Buffer)</span><br><span class="line"></span><br><span class="line">1. **从内存模型而不是垃圾收集的角度, 对Eden区域继续进行划分, JVM为每个线程分配了一个私有缓存区域, 它包含在Eden空间内**</span><br><span class="line">2. **尽管不是所有的对象实例都能够在TLAB中成功分配内存, 但JVM确实是将TLAB作为内存分配的首选**</span><br><span class="line">3. 默认情况下, TLAB空间的内存非常小, 仅占有整个Eden空间的1%, 当然可通过选项&quot;-XX:TLABWasteTargetPercent&quot;设置TLAB空间所占用Eden空间的百分比大小</span><br><span class="line">4. 一旦对象在TLAB空间分配内存失败时, JVM就会尝试着通过使用加锁机制确保数据操作的原子性, 从而直接在Eden空间中分配内存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20220206230126092](image-20220206230126092.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20220206230140260](image-20220206230140260.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 堆空间参数总结</span><br><span class="line"></span><br><span class="line">1. **-XX:+PrintFlagsInitial : 查看所有的参数的默认初始值**</span><br><span class="line">2. -XX:+PrintFlagsFinal : 查看所有的参数的最终值(可能会存在修改(:表示修改了),不再是初始值)</span><br><span class="line">3. 具体查看某个参数的指令:</span><br><span class="line">   - jps: 查看当前运行中的进程</span><br><span class="line">   - jinfo -flag SurvivorRatio 进程id</span><br><span class="line">4. **-Xms:初始堆空间内存 (默认为物理内存的1/64)**</span><br><span class="line">5. **-Xmx:最大堆空间内存(默认为物理内存的1/4)**</span><br><span class="line">6. -Xmn:设置新生代的大小。</span><br><span class="line">7. -XX:NewRatio:配置新生代与老年代在堆结构的占比 (默认:-XX:NewRatio=2）</span><br><span class="line">8. -XX:SurvivorRatio:设置新生代中Eden和S0/S1空间的比例 (默认是8)</span><br><span class="line">9. -XX:MaxTenuringThreshold: 设置新生代中对象的年龄阈值</span><br><span class="line">10. -XX:+PrintGCDetails: 输出详细的GC处理日志。如下这两种方式是简单的打印gc简要信息:</span><br><span class="line">    - -XX:+PrintGC </span><br><span class="line">    - -verbose:gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 逃逸分析</span><br><span class="line"></span><br><span class="line">1. **如何将堆上的对象分配到栈,需要使用逃逸分析手段**</span><br><span class="line">   - 当一个对象在方法中被定义后,对象只在方法内部使用(这里关注的是这个对象的实体), 则认为没有发生逃逸。</span><br><span class="line">   - 当一个对象在方法中被定义后, 它被外部方法所引用, 则认为发生逃逸。例如作为调用参数传递到其他地方中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码演示:</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//(1). 没有发生逃逸的对象,则可以分配到栈上,随着方法执行的结束,栈空间就被移除</span><br><span class="line">public void my_method() &#123;</span><br><span class="line">    V v = new V();</span><br><span class="line">    // use v</span><br><span class="line">    // ....</span><br><span class="line">    v = null;</span><br><span class="line">&#125;</span><br><span class="line">//(2). 下面代码中的 StringBuffer sb 发生了逃逸</span><br><span class="line">public static StringBuffer createStringBuffer(String s1, String s2) &#123;</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    return sb;</span><br><span class="line">&#125;</span><br><span class="line">//如果想要StringBuffer sb不发生逃逸,可以这样写</span><br><span class="line">public static String createStringBuffer(String s1, String s2) &#123;</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="2"><li>在JDK1.7版本之后, HotSpot中默认就已经开启了逃逸分析<ul><li>通过选项”-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul></li></ol><ol start="3"><li>使用逃逸分析,编译器可以对代码做如下优化:<ol><li>栈上分配: 将堆分配转化为栈分配。如果一个对象在子程序中被分配, 要使指向该对象的指针永远不会发生逃逸, 对象可能是栈上分配的候选, 而不是堆上分配</li><li>同步省略: 如果一个对象被发现只有一个线程被访问到, 那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换: 有的对象可能不需要作为一个连续的内存结构存在也可以被访问到, 那么对象的部分(或全部)可以不存储在内存, 而是存储在CPU寄存器中</li></ol></li></ol><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>JIT编译器在编译期间根据逃逸分析的结果, 发现如果一个对象并没有逃逸出方法的话, 就可能被优化成栈上分配</p><p>代码举例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx256m -Xms256m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为: &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数,线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(); <span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时未开启逃逸分析，通过日志打印发现发生了GC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 65536K-&gt;560K(76288K)] 65536K-&gt;568K(251392K), 0.0017179 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 66096K-&gt;464K(76288K)] 66104K-&gt;480K(251392K), 0.0017602 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">花费的时间为: 74 ms</span><br></pre></td></tr></table></figure><p>可以通过改变设置开启逃逸分析:</p><ul><li>-Xmx256m -Xms256m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</li></ul><p>此时查看日志，发现并没有发生GC(栈上分配确实快很多)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">花费的时间为: 4 ms</span><br></pre></td></tr></table></figure><h4 id="同步省略-锁消除"><a href="#同步省略-锁消除" class="headerlink" title="同步省略 锁消除"></a>同步省略 锁消除</h4><p>从JIT角度看相当于无视它了, 这个锁对象没有被共享给其他线程</p><p>比如下面的代码，虽然加了同步代码块，但是并没有起到锁的作用。代码中堆hellis这个对象加锁(每个线程都有一个hellis对象的锁)，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在编译阶段就会被优化掉。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) &#123;</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JIT会将它变成这样</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 字节码文件中并没有进行优化,可以看到加锁和释放锁的操作依然存在,同步省略操作是在解释运行时发生的</p><p><img src="image-20220216021139970.png" alt="image-20220216021139970"></p><h4 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h4><p><strong>标量(scalar)是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量</strong></p><p><strong>相对的, 那些还可以分解的数据叫做聚合量(Aggregate), Java中的对象就是聚合量, 因为他可以分解成其他聚合量和标量</strong></p><p>在JIT阶段, 如果经过逃逸分析, 发现一个对象不会被外界访问的话, 那么经过JIT优化, 就会把这个对象拆解成若干个成员变量来代替。这个过程就是标量替换</p><p>举例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上代码,经过标量替换后,就会变成</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol><li><p>方法区在JVM启动的时候被创建, 并且它的实际的物理内存空间和Java堆区一样都可以是不连续的, 关闭Jvm就会释放这个区域的内存</p></li><li><p>方法区是逻辑上是堆的一个组成部分, 但是在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)</p><p>(注意：方法区是一种规范，而永久代和元空间是它的一种实现方式)</p></li><li><p>方法区的大小决定了系统可以保存多少个类, 如果系统定义了太多的类, 导致方法区溢出, 虚拟机同样会抛出内存溢出错误：(java.lang.OutOfMemoryError:PermGen space、java.lang.OutOfMemoryError:Metaspace)</p><ul><li>加载大量的第三方的jar包</li><li>tomcat部署的工程过多(30-50个)</li><li>大量动态的生成反射类</li></ul></li><li><p>对于HotspotJVM而言, 方法区还有一个别名叫非堆(Non-heap),目的就是要和堆分开, 方法区可以看成一块独立于Java堆的内存空间</p></li></ol><h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><ol><li>《深入理解Java虚拟机》书中对方法区存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等</li></ol><p><img src="image-20220220000602864.png" alt="image-20220220000602864"></p><ol start="2"><li><p><strong>类型信息:</strong> 对每个加载的类型(类class、接口interface、枚举enum、注解annotation), JVM必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java. lang.Object，都没有父类）</li><li>这个类型的修饰符（public， abstract， final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul></li><li><p>**域信息:**（成员变量）</p><ul><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li><li>域的相关信息包括：域名称、域类型、域修饰符（public， private， protected， static， final， volatile， transient的某个子集）</li></ul></li><li><p><strong>方法信息：</strong>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public， private， protected， static， final，synchronized， native ， abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract和native 方法除外）</li><li>异常表（ abstract和native方法除外）。每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li><li><p><strong>non-final的类变量</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>对于<a href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a>修饰的变量，如果未被final进行修饰，则在链接阶段的准备阶段进行默认初始化赋值，在初始化阶段进行显式赋值</p><p>对于static+final修饰的变量，有两个地方进行显式赋值：</p><ol><li>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法)通常是在链接阶段的准备环节进行</li><li>对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</li><li>除以上情况外，则在初始化阶段&lt;clinit&gt;()中赋值</li></ol></li></ol><p>以下代码不会报空指针异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h3><ol><li>Jdk 1.6 及之前：有永久代，静态变量及字符串常量池存放在永久代上</li><li>Jdk 1.7: 有永久代，但已经逐步”去永久代”，字符串常量池、静态变量移除, 保存在堆中。运行时常量池仍在永久代中</li><li>jdk 1.8 及之后: 无永久代，运行时常量池在元空间。但静态变量、字符串常量池仍在堆中</li></ol><p><strong>为什么要用元空间取代永久代？</strong></p><ol><li><p>为永久代设置空间大小是很难确定的</p><ul><li>永久代参数设置过小, 在某些场景下, 如果动态加载的类过多, 容易产生Perm区的OOM, 比如某个实际Web工程中, 因为功能点比较多, 在运行过程中, 要不断动态加载很多类, 经常出现致命错误</li><li>永久代参数设置过大,导致空间浪费</li><li>默认情况下,元空间的大小受本地内存限制</li></ul></li><li><p>对永久代进行调优是很困难的</p><p>(方法区的垃圾收集主要回收两部分：常量池中废弃的常量和不再使用的类型, 而不再使用的类或类的加载器回收比较复杂, full gc 的时间长)</p><p><strong>无用的类需要满足3个条件：</strong></p><p>（1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；<br>（2）加载该类的ClassLoader已经被回收；<br>（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>虚拟机可以对满足上述3个条件的无用类进行回收，此处仅仅是<strong>“可以”</strong>，而并不是和对象一样（不使用了就必然回收）</p></li></ol><p><strong>StringTable为什么要调整?</strong></p><ol><li>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低, 在full gc的时候才能触发。而full gc是老年代的空间不足、永久代不足才会触发</li><li>这就导致StringTable回收效率不高,而我们开发中会有大量的字符串被创建, 回收效率低, 导致永久代内存不足, 放到堆里, 能及时回收内存</li></ol><h3 id="设置方法区大小"><a href="#设置方法区大小" class="headerlink" title="设置方法区大小"></a>设置方法区大小</h3><p><strong>jdk7及以前:</strong></p><ol><li>-XX:PermSize=100m(默认值是20.75M)</li><li>-XX:MaxPermSize=100m(32位机器默认是64M,64位机器模式是82M)</li></ol><p><strong>jdk1.8及以后:</strong></p><ol><li>-XX:MetaspaceSize=100m(windows下,默认约等于21M)</li><li>-XX:MaxMetaspaceSize=100m(默认是-1,即没有限制)</li></ol><h3 id="常量池的理解"><a href="#常量池的理解" class="headerlink" title="常量池的理解"></a>常量池的理解</h3><ol><li>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型、字面量等信息</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">7.</span>#<span class="number">23</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Methodref          #<span class="number">24.</span>#<span class="number">25</span>        <span class="comment">// com/xiaozhi/heap/Order.hello:()V</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">26.</span>#<span class="number">27</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = Fieldref           #<span class="number">24.</span>#<span class="number">28</span>        <span class="comment">// com/xiaozhi/heap/Order.count:I</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">29.</span>#<span class="number">30</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br></pre></td></tr></table></figure><ol start="2"><li>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包括各种字面量和对类型域和方法的符号引用。</li><li>每个java源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池</li></ol><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ol><li><strong>运行时常量池，常量池是 <code>*.class</code> 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</strong></li><li>运行时常量池（ Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是Class文件的一部分，<strong>用于存放编译期生成的各种字面量与符号引用</strong>，这部分内容将在<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>后存放到方法区的运行时常量池中。</li><li>运行时常量池中包含多种不同的常量, <strong>包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用</strong>，此时不再是常量池中的符号地址了，这里换为真实地址。</li><li>方法区内常量池之中主要存放的两大类常量：字面量和符号引用。<ul><li>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。</li><li>而符号引用则属于编译原理方面的概念，包括下面三类常量：<ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li></ul></li></ol><h3 id="如何证明静态变量存在哪"><a href="#如何证明静态变量存在哪" class="headerlink" title="如何证明静态变量存在哪"></a>如何证明静态变量存在哪</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> StaticObjTest.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>staticObj随着Test的类型信息存放在方法区，instance0bj 随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hsdb&gt;scanoops 0x00007f32c7800000 0x00007f32c7b50000 JHSDB_ _TestCase$Obj ectHolder</span><br><span class="line">0x00007f32c7a7c458 JHSDB_ TestCase$Obj ectHolder</span><br><span class="line">0x00007f32c7a7c480 JHSDB_ TestCase$Obj ectHolder</span><br><span class="line">0x00007f32c7a7c490 JHSDB_ TestCase$Obj ectHolder</span><br></pre></td></tr></table></figure><ol start="2"><li>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong></li><li>接着，找到了一个引用该staticObj对象的地方，是在一个java. lang.Class的实例里，并且给出了这个实例的地址。通过Inspector查看该对象实例，可以清楚看到这确实是一个<br>java.lang.Class类型的对象实例，里面有一个名为staticObj的实例字段：</li></ol><p><img src="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/image-20220220034645325.png" alt="image-20220220034645325"></p><ol start="4"><li>从《Java 虛拟机规范》所定义的概念模型来看，所有 Class 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java 虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7 及其以后版本的 Hotspot 虚拟机选择把静态变量存储于Java 堆之中，从我们的实验中也明确验证了这一点.</li></ol><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前言：</span><br><span class="line">(1).有些人认为方法区（如Hotspot，虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 ZGC 收集器就不支持类卸载）</span><br><span class="line">(2). 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 Hotspot 虚拟机对此区域未完全回收而导致内存泄漏。</span><br></pre></td></tr></table></figure><ol><li><p>方法区的垃圾收集主要回收两部分内容：常量池中废奔的常量和不再使用的类型</p></li><li><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量</p><ol><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ol></li><li><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。回收废弃常量与回收Java堆中的对象非常类似。</p></li><li><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ol></li><li><p>Java虛拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p></li><li><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</p></li></ol><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><ol><li>new 最常见的方式 <ul><li>变形1: Xxx的静态方法</li><li>变形2: XxBuilder/XxoxFactory的静态方法</li></ul></li><li>class的newInstance(): 反射的方式，只能调用空参的构造器，权限必须是public</li><li>Constructor的newInstance(xxx): 反射的方式，可以调用空参、带参的构造器，权限没有要求</li><li>使用clone(): 不调用任何构造器，当前类需要实现Cloneable接口，实现clone()</li><li>使用反序列化: 从文件中、从网络中获取一个对象的二进制流</li><li>第三方库Objenesis</li></ol><h3 id="从字节码角度看待对象的创建过程"><a href="#从字节码角度看待对象的创建过程" class="headerlink" title="从字节码角度看待对象的创建过程"></a>从字节码角度看待对象的创建过程</h3><ol><li>从最简单的Object ref = new Object()</li></ol><p><img src="image-20220221012830228.png" alt="image-20220221012830228"></p><ol start="2"><li>new: 如果找不到Class对象,则进行类加载。加载成功后, 则在堆中分配内存, 从Object 开始到本类路径上的所有属性值都要分配内存。分配完毕之后, 进行零值初始化。在分配过程中, 注意引用是占据存储空间的, 它是一个变量, 占用4个字节。这个指令完毕后, 将指向实例对象的引用变量压入虚拟机栈顶。</li><li>dup: 在栈顶复制该引用变量, 这时的栈顶有两个指向堆内实例对象的引用变量。如果方法有参数, 还需要把参数压入操作栈中。两个引用变量的目的不同, 其中压至底下的引用用于赋值, 或者保存到局部变量表, 另一个栈顶的引用变量作为句柄调用相关方法。</li><li>invokespecial: 调用对象实例方法, 通过栈顶的引用变量调用init方法。<br><strong>补充:clinit是类初始化时执行的方法, 而init是对象初始化时执行的方法。</strong></li></ol><h3 id="对象的实例化-六个步骤"><a href="#对象的实例化-六个步骤" class="headerlink" title="对象的实例化(六个步骤)"></a>对象的实例化(六个步骤)</h3><ol><li><p>判断对象对应的类是否加载、链接、初始化</p><p>(虚拟机遇到一条new指令, 首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用, 并且检查这个符号引用代表的类是否已经被加载、链接和初始化。(即判断类元信息是否存在)。如果没有, 那么在双亲委派模式下, 使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件, 则抛出ClassNotFoundException异常, 如果找到, 则进行类加载, 并生成对应的Class类对象)</p></li><li><p>为对象分配内存: 首先计算对象占用空间大小, 接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量, 仅分配引用变量空间即可, 即4个字节大小</p><p>(int、float、引用数据类型4个字节大小 | double、long 占八个字节)</p><ol><li><p>如果内存规整,使用指针碰撞:</p><p>如果内存是规整的, 那么虚拟机将采用的是指针碰撞法(BumpThePointer)来为对象分配内存。意思是所有用过的内存在一边, 空闲的内存在另外一边, 中间放着一个指针作为分界点的指示器, 分配内存就是把指针向空闲那边挪动一段与对象大小相等的距离。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的, 虚拟机采用这种分配方式。一般使用带有compact (整理)过程的收集器时,使用指针碰撞。</p></li><li><p>如果内存不规整,虚拟机需要维护一个列表, 使用空闲列表分配(CMS)</p><p>如果内存不是规整的, 已使用的内存和未使用的内存相互交错, 那么虛拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表, 记录上哪些内存块是可用的,再分配的时候从列表中找到一块足够大的空间划分给对象实例, 并更新列表上的内容。这种分配方式成为“空闲列表(Free List)</p></li><li><p>说明：选择哪种分配方式由Java堆是否规整决定, 而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p></li></ol></li></ol><p>指针碰撞：</p><p><img src="image-20220221022434787.png" alt="image-20220221022434787"></p><p>空闲列表:</p><p><img src="image-20220221022509395.png" alt="image-20220221022509395"></p><ol start="3"><li><p>处理并发安全问题</p><p>在分配内存空间时, 另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作, 虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题：</p><ol><li>CAS (Compare And Swap)失败重试、区域加锁：保证指针更新操作的原子性</li><li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行,即每个线程在Java堆中预先分配一小块内存, 称为本地线程分配缓冲区, (TLAB, Thread Local Allocation Buffer)虚拟机是否使用TLAB, 可以通过-XX：+/-UseTLAB参数来设定</li></ol></li><li><p>初始化分配到的空间: 赋予默认的初始化值; 比如int=0| boolean=false(默认的值)</p></li><li><p>设置对象的对象头：将对象的所属类(即类的元数据信息)、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p></li><li><p>执行init方法进行初始化(进行赋值的处理)</p><p>在Java程序的视角看来, 初始化才正式开始。初始化成员变量, 执行实例化代码块, 调用类的构造方法, 并把堆内对象的首地址赋值给引用变量。因此一般来说(由字节码中是否跟随有invokespecial指令所决定), new指令之后会接着就是执行方法, 把对象按照程序员的意愿进行初始化, 这样一个真正可用的对象才算完全创建出来。</p></li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ol><li>对象内部结构分为：对象头、实例数据、对齐填充(保证8个字节的倍数)</li><li>对象头分为对象标记(Mark Word)和类元信息(Class Pointer), 类元信息存储的是指向该对象类元数据(class)的首地址</li></ol><p><img src="image-20220221025110635.png" alt="image-20220221025110635"></p><h4 id="对象头-Header"><a href="#对象头-Header" class="headerlink" title="对象头(Header)"></a>对象头(Header)</h4><ol><li>对象标记Mark Word默认存储 (HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳)等信息<ol><li>这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。</li><li>它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。</li></ol></li></ol><p><img src="image-20220221025550500.png" alt="image-20220221025550500"></p><ol start="2"><li>对象头多大: 在64位系统中, Mark Word占了8个字节, 类型指针占了8个字节, 一共是16个字节</li></ol><p><img src="image-20220221030011151.png" alt="image-20220221030011151"></p><ol start="3"><li>类元信息(又叫类型指针): 对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li></ol><h4 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h4><p>说明: 它是对象真正存储的有效信息, 包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段)规则:</p><ol><li>相同宽度的字段总被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果CompactFields参数为true(默认为true), 子类的窄变量可能插入到父类变量的空隙</li></ol><h4 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h4><ul><li>不是必须的，也没特别含义，仅仅起到占位符作用</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>代码演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Customer cust = <span class="keyword">new</span> Customer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解代码:</p><p><img src="image-20220221030635321.png" alt="image-20220221030635321"></p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？-&gt; 定位, 通过栈上reference访问</p><ol><li>句柄访问</li></ol><p><img src="image-20220221032020637.png" alt="image-20220221032020637"></p><ol start="2"><li>直接指针(HotSpot采用)</li></ol><p><img src="image-20220221032304889.png" alt="image-20220221032304889"></p><h3 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="直接内存(Direct Memory)"></a>直接内存(Direct Memory)</h3><ol><li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</li><li>直接内存是Java堆外的、直接向系统申请的内存区间</li></ol><ol start="3"><li>代码演示：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  IO                  NIO (New IO / Non-Blocking IO)</span></span><br><span class="line"><span class="comment"> *  byte[] / char[]     Buffer</span></span><br><span class="line"><span class="comment"> *  Stream              Channel</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查看直接内存的占用与释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//1GB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//直接分配本地内存空间</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存分配完毕，请求指示！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        scanner.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存开始释放！&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li></ol><p><img src="image-20220221033245551.png" alt="image-20220221033245551"></p><p><img src="image-20220221033655940.png" alt="image-20220221033655940"></p><ol start="5"><li>通常，访问直接内存的速度会优于Java堆。即读写性能高</li><li><strong>直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值-Xmx参数值一致</strong></li><li>简单理解：java process memory = java heap + native memory</li></ol><p><img src="image-20220221034128070.png" alt="image-20220221034128070"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.bilibili.com/video/BV1PJ411n7xZ?spm_id_from=333.934.top_right_bar_window_custom_collection.content.click">尚硅谷宋红康JVM全套教程（详解java虚拟机）_哔哩哔哩_bilibili</a></p><p><a href="https://blog.csdn.net/TZ845195485/article/details/93238857">(13条消息) JVM_虚拟机目所得皆惊喜-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网java面经</title>
      <link href="/2021/12/30/%E7%89%9B%E5%AE%A2%E7%BD%91java%E9%9D%A2%E7%BB%8F/"/>
      <url>/2021/12/30/%E7%89%9B%E5%AE%A2%E7%BD%91java%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2><p><strong>请你讲讲数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？</strong></p><p>Array和ArrayList的不同点：</p><ul><li>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</li><li>Array大小是固定的，ArrayList的大小是动态变化的。</li><li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</li><li>对于基本类型数据，ArrayList使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li></ul><p><strong>请你解释为什么会出现4.0-3.6=0.40000001这种现象？</strong></p><p>浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。<br>这就好像十进制无法精确地表示分数 1/3—样。<br>如果在数值计算中不允许有任何舍入误差， 就应该使用 BigDecimal类。</p><p>例如：<br>0.5能够表示，因为它可以表示成为1/2<br>0.75也能够表示，因为它可以表示成为1/2+1/(2^2)<br>0.875也能够表示，因为它可以表示成为1/2+1/(2^2)+1/(2^3)<br>0.9375也能够表示，因为它可以表示成为1/2+1/(2^2)+1/(2^3)+1/(2^4)<br>但是0.1不能够精确表示，因为它不能表示成为1/(2^n)的和的形式</p><p>任意十进制整数都能转换为有限位的二进制数，但十进制小数不一定可以。</p><p>BigDecimal原理：</p><ul><li>把十进制小数扩大n倍，转成整数后再进行运算</li></ul><p><strong>请你讲讲一个十进制的数在内存中是怎么存的？</strong></p><p>以二进制补码形式存储，最高位是符号位(正数0，负数1)，正数的补码是它的原码，负数的补码是它的反码加1，在求反码时符号位不变，符号位为1，其他位取反</p><p><strong>请你说说Lamda表达式的优缺点</strong></p><p>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。</p><p>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</p><p>lambda表达式的并行计算是底层框架ForkJoin决定的</p><p><strong>你知道java8的新特性吗，请简单介绍一下</strong></p><ul><li><strong>Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</strong></li><li>方法引用− 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong>默认方法− 默认方法就是一个在接口里面有了一个实现的方法。</strong></li><li>新工具− 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li><li><strong>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</strong></li><li><strong>Date Time API − 加强对日期与时间的处理。</strong></li><li><strong>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</strong></li><li>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul><p><strong>请你解释Object若不重写hashCode()的话，hashCode()如何计算出来的？</strong></p><p>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址</p><p><strong>请你解释为什么重写equals还要重写hashcode？</strong></p><p>hashCode 方法用于散列集合的查找，equals 方法用于判断两个对象是否相等。HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的。</p><p>对于HashSet也是同理,如果只重写了equals 方法，两个对象equals 返回了true，但是如果没有重写hashCode 方法，集合还是会插入元素。 这样集合中就出现了重复元素了。</p><p><strong>请你介绍一下map的分类和常见的情况</strong></p><p>java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是<strong>HashMap Hashtable LinkedHashMap 和TreeMap.</strong></p><p>Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</p><p>Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，<strong>可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</strong></p><p>Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p><p>LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p><p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p><ul><li>HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。</li><li>HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</li><li>Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。</li><li>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。</li><li>TreeMap能够把它保存的记录根据键排序，在遍历的时候会比HashMap慢，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。</li></ul><p><strong>请你讲讲Java里面的final关键字是怎么用的？</strong></p><p>当用final修饰一个类时，表明这个类不能被继承。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p><p>final修饰方法，表示方法不能被重写。</p><p>final修饰变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p><p><strong>请你谈谈关于Synchronized和lock</strong></p><ul><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>ynchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到</li></ul><p><strong>请你介绍一下volatile？</strong></p><p><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p><p>volatile关键字是用来保证有序性和可见性的。</p><p>保证有序性：禁止指令重排序</p><p>保证可见性：更新完操作后立刻写入内存，其他线程读取volatile变量的值时也会重新从内存中加载</p><p><strong>请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？</strong></p><p>synchronized的修饰对象有几种：</p><ol><li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分， <strong>作用的对象是这个类的所有对象</strong>；</li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法， <strong>作用的对象是调用这个方法的对象</strong>；</li><li>修改一个静态的方法，其作用的范围是整个静态方法， <strong>作用的对象是这个类的所有对象；</strong></li><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码， <strong>作用的对象是调用这个代码块的对象；</strong></li></ol><p><strong>若对一个类不重写，它的equals()方法是如何比较的？</strong></p><p>比较是对象的地址</p><p><strong>请解释hashCode()和equals()方法有什么联系？</strong></p><p>Java对象的eqauls方法和hashCode方法是这样规定的：</p><p>➀相等（相同）的对象必须具有相等的哈希码（或者散列码）。</p><p>➁如果两个对象的hashCode相同，它们并不一定相同。</p><p><strong>请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</strong></p><ul><li>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的无参构造函数。</li><li>Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</li><li>Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。</li></ul><p><strong>请说明Query接口的list方法和iterate方法有什么区别？</strong></p><ul><li>list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。</li><li>list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题</li></ul><p><strong>请你谈一下面向对象的”六原则一法则”</strong></p><ul><li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”）</li><li>开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：<ul><li>抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；</li><li>封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，</li></ul></li><li>依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）</li><li>里氏替换原则：任何时候都可以用子类型替换掉父类型。（简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。）</li><li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。</li><li>合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码</li><li>迪米特法则：迪米特法则又叫最少知道原则，一个对象应当对其他对象有尽可能少的了解。</li></ul><p><strong>请说明如何通过反射获取和设置对象私有字段的值？</strong></p><p>可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。</p><p><strong>请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</strong></p><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；</p><p>重写发生在子类与父类之间，重写要求子类重写方法的返回类型<strong>小于等于</strong>父类被重写方法，访问权限<strong>大于等于</strong>父类被重写方法，声明的异常<strong>小于等于</strong>父类被重写方法（里氏代换原则）。</p><p>重载对返回类型没有特殊的要求，但是<strong>仅仅只有返回类型不同不算重写，编译器还会报错！</strong></p><p><strong>请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？</strong></p><p>一个内部类对象可以访问创建它的外部类对象的内容</p><ul><li>内部类如果不是static的，那么它可以访问创建它的外部类对象的所有属性</li><li>内部类如果是sattic的，即为nested class，那么它只可以访问创建它的外部类对象的所有static属性</li></ul><p>一般普通类只有public或package的访问修饰，而内部类可以实现static，protected，private等访问修饰。</p><p>当从外部类继承的时候，内部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明确地继承，就可以覆盖原来内部类的方法。</p><p><strong>请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？</strong></p><p>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。</p><p>在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。</p><p>一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。</p><p>用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。throw语句用来明确地抛出一个”异常”。throws用来标明一个成员函数可能抛出的各种”异常”。Finally为确保一段代码不管发生什么”异常”都被执行一段代码。</p><p>可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常“的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。</p><p><strong>请判断当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</strong></p><p>是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</p><p><strong>请你说说Static Nested Class 和 Inner Class的不同</strong></p><p>Static Nested Class静态内部类可以在不创建实例的条件下直接创建，因为它只访问静态方法和成员，它和类直接绑定，并且不能访问任何非静态类型的方法和成员变量。</p><p>但是Inner class内部类是和实例绑定的，他可以访问实例的成员变量和方法，所以在创建他之前必须先创建一个实例，然后通过实例创建它才行。</p><p><strong>请你讲讲abstract class和interface有什么区别?</strong></p><ul><li>抽象类和接口不能被直接实例化，二者实例化涉及到多态。如果抽象类要实例化，那么抽象类定义的变量必须指向一个子类对象，这个子类继承了抽象类并实现类抽象类的所有抽象方法，如果接口要实例化，那么接口定义的变量要指向一个子类对象，这个子类必须实现这个接口所有的方法。</li><li>抽象类要被子类继承，接口要被子类实现。接口（类）可以继承一个或多个接口，但类只能继承一个类</li><li>抽象类既可以对方法进行声明，也可以对方法进行实现。java8后接口里也可以有默认方法</li><li>抽象类里面可以没有抽象方法，如果一个类里面有抽象方法，那么这个类一定是抽象类</li><li>抽象类主要用来抽象类别，接口主要是用来抽象方法功能。当关注事物的本质的时候，用抽象类。当关注某种操作的时候，用接口。</li><li>JDK1.7接口只能有常量(默认public static final)跟抽象方法，JDK1.8开始可以有默认方法和静态方法，JDK1.9在前面版本的基础上新增了私有方法和私有静态方法。<ul><li>默认方法使用default关键字修饰，需要些方法体来实现具体逻辑。实现类可以不重写默认方法，在需要的时候进行重写。</li><li>静态方法使用static关键字修饰、定义，同样需要写方法体，实现具体的逻辑，但静态方法不可以被子类实现或继承。</li><li>默认方法内部可以调用静态方法，但静态方法内部不能调用默认方法，因为静态方法只能调用静态方法。</li><li>私有方法用private关键字修饰、定义，私有静态方法用private static关键字修饰、定义，private与private static方法只能接口自身内部调用，实现类或子类不可重写/重载，两者都需要写方法体，实现具体逻辑。</li></ul></li></ul><p><strong>请说明一下final, finally, finalize的区别</strong></p><ul><li>inal 用于声明属性，方法和类，分别表示属性不可变，方法不可重写，类不可继承。</li><li>finally是异常处理语句结构的一部分，表示总是执行。</li><li>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以重写此方法提供垃圾回收时的其他资源，例如关闭文件等。</li></ul><p><strong>请说明面向对象的特征有哪些方面</strong></p><ul><li>抽象：<ul><li>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</li></ul></li><li>继承：<ul><li>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</li></ul></li><li>封装：<ul><li>就是将客观事物抽象为逻辑实体，<strong>实体的属性和功能相结合</strong>，形成一个有机的整体。并<strong>对实体的属性和功能实现进行访问控制</strong>，向信任的实体开放，对不信任的实体隐藏。，<strong>通过开放的外部接口即可访问</strong>，无需知道功能如何实现。</li></ul></li><li>多态性：<ul><li>是指<strong>一个类实例的相同方法在不同情形有不同表现形式</strong>。</li></ul></li></ul><p><strong>请说明Comparable和Comparator接口的作用以及它们的区别</strong></p><ul><li>Comparable: 自然排序<ul><li>Java提供了只包含一个compareTo()方法的Comparable接口。这个方法有<strong>一个参数</strong>，可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。</li></ul></li><li>Comparator: 定制排序<ul><li>Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给<strong>两个输入</strong>参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要<strong>一个对象</strong>作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</li></ul></li><li>如果要用Comparable接口，则必须实现这个接口，并重写comparaTo()方法；但是Comparator接口可以在类外部使用，通过将该接口的一个匿名类对象当做参数传递给Collections.sort()方法或者Arrays.sort()方法实现排序。Comparator体现了一种策略模式，即可以不用要把比较方法嵌入到类中，而是可以单独在类外部使用，这样我们就可有不用改变类本身的代码而实现对类对象进行排序</li></ul><p><strong>请说明Java是否支持多继承？</strong></p><p>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）</p><p><strong>请你谈谈如何通过反射创建对象？</strong></p><ul><li>方法1：通过类对象调用newInstance()方法，<ul><li>例如：String.class.newInstance()</li></ul></li><li>方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，<ul><li>例如：String.class.getConstructor(String.class).newInstance(“Hello”);</li></ul></li></ul><p><strong>请你说明是否可以在static环境中访问非static变量？</strong></p><p>不可以，因为static变量是属于类的，在类加载的时候就被初始化了，这时候非静态变量并没有加载，故非静态变量不能访问。</p><p><strong>泛型</strong></p><p><a href="https://www.cnblogs.com/coprince/p/8603492.html">https://www.cnblogs.com/coprince/p/8603492.html</a></p><p>在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><p><strong>请说明静态变量存在什么位置?</strong></p><p>方法区</p><p><strong>请你解释一下类加载机制，双亲委派模型，好处是什么？</strong></p><p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p><p>使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</p><p><strong>请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？</strong></p><p>StringBuffer线程安全，StringBuilder线程不安全，底层实现上的话，StringBuffer其实就是比StringBuilder多了Synchronized修饰符。</p><p><strong>请说明String是否能能继承？</strong></p><p>不能，String类是用final修饰的。</p><p>如果问String类为什么不能改变，原因是String类中的char数组是final修饰的</p><p><strong>请说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</strong></p><ul><li>static表示静态成员</li><li>不可以重写private，因为根本不会继承private方法</li><li>不可以重写static方法，因为方法重写是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用</li></ul><p><strong>请列举你所知道的Object类的方法并简要说明</strong></p><ul><li>Object()默认构造方法</li><li>clone() 创建并返回此对象的一个副本</li><li>equals(Object obj) 指示某个其他对象是否与此对象“相等”</li><li>finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法</li><li>getClass()返回一个对象的运行时类</li><li>hashCode()返回该对象的哈希码值</li><li>notify()唤醒在此对象监视器上等待的单个线程</li><li>notifyAll()唤醒在此对象监视器上等待的所有线程</li><li>toString()返回该对象的字符串表示</li><li>wait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。wait(long timeout)、wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。</li></ul><p><strong>请说明类和对象的区别</strong></p><ul><li>类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。<ul><li>比如：“人”是一个类，而“教师”则是“人”的一个实例。</li></ul></li><li>对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性的对象集合体</li></ul><p><strong>请说明List、Map、Set三个接口存取元素时，各有什么特点？</strong></p><ul><li>List以特定索引来存取元素，可以有重复元素。</li><li>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。</li><li>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。<ul><li>Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</li></ul></li></ul><p><strong>阐述ArrayList、Vector、LinkedList的存储性能和特性</strong></p><ul><li>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。</li><li>LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</li><li>Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</li></ul><p><img src="1034884_1581738199162_50125D538C24748FCB1032CB38EEE0A9.jpeg" alt="img"></p><p><strong>请判断List、Set、Map是否继承自Collection接口？</strong></p><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p><p><strong>请说明Collection 和 Collections的区别</strong></p><p>Collection是集合类的上级接口，继承与他的接口主要有Set 和List<br>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作</p><p>**请你说明HashMap和Hashtable的区别？ **</p><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：</p><ul><li>HashMap允许键和值是null，而Hashtable不允许键或者值是null。</li><li>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</li><li>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。</li><li>一般认为Hashtable是一个遗留的类。</li></ul><p><strong>请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？</strong></p><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</p><p>java.util包下面的所有的集合类都是快速失败的(不支持多线程并发修改)，而java.util.concurrent包下面的所有的类都是安全失败的。</p><p>快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p><p><strong>请你说说Iterator和ListIterator的区别？</strong></p><p>Iterator和ListIterator的区别是：</p><ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等</li></ul><p><strong>请简单说明一下什么是迭代器？</strong></p><p>Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口, 每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作。</p><p>有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException 异常。 但是可以通过Iterator接口中的remove()方法进行删除。</p><p><strong>请解释为什么集合类没有实现Cloneable和Serializable接口？</strong></p><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p><p>比如ArrayList实现了这两个接口，但是List没有实现</p><p><strong>请你说明一下ConcurrentHashMap的原理？</strong></p><p><a href="https://zhuanlan.zhihu.com/p/104515829">https://zhuanlan.zhihu.com/p/104515829</a></p><p><strong>请解释一下TreeMap?</strong></p><p>TreeMap是一个有序的key-value集合，基于红黑树（Red-Black tree）的 NavigableMap实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator进行排序，具体取决于使用的构造方法。</p><p>TreeMap的特性：</p><ul><li>根节点是黑色</li><li>每个节点都只能是红色或者黑色</li><li>每个叶节点（NIL节点，空节点）是黑色的。</li><li>如果一个节点是红色的，则它两个子节点都是黑色的，也就是说在一条路径上不能出现两个红色的节点。</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ul><p><strong>请说明ArrayList是否会越界？</strong></p><p>不会，会动态扩容</p><p><strong>请你解释HashMap的容量为什么是2的n次幂？</strong></p><p>HashMap的容量为2^n的原因是：</p><ul><li>对key的hash取余效率更高。因为当length是2的n次方的时候： hash % length == hash &amp; (length - 1)。位运算的效率比直接取余的效率会高很多</li><li>扩容resize()的时候，原来哈希表中，有接近一半的节点的下标是不变的，而另外的一半的下标为 原来的length + 原来的下标。具体要看hash值对应扩容后的某一位是0还是1</li></ul><p><strong>如果hashMap的key是一个自定义的类，怎么办？</strong></p><p>使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()</p><p><strong>请你解释一下hashMap具体如何实现的？</strong></p><p>Hashmap基于数组实现的，通过对key的hashcode &amp; 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。put时在多线程情况下，会形成环从而导致死循环。数组长度一般是2n，从0开始编号，所以hashcode &amp; （2n-1），（2n-1）每一位都是1，这样会让散列均匀。需要注意的是，<strong>HashMap在JDK1.8的版本中引入了红黑树结构做优化</strong>，当链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><p><strong>请你说明一下Map和ConcurrentHashMap的区别？</strong></p><p>hashmap是线程不安全的，put时在多线程情况下，会形成环从而导致死循环。CoucurrentHashMap是线程安全的</p><h2 id="Java高级"><a href="#Java高级" class="headerlink" title="Java高级"></a>Java高级</h2><p><strong>如何保证线程安全？</strong></p><ul><li>使用线程安全的类；</li><li>synchronized同步代码块，或者用Lock锁；</li></ul><p><strong>请你简要说明一下线程的基本状态以及状态之间的关系？</strong></p><p><img src="93694598_1567901669525_2E1604194BEFDDB0EE43167B50B364AB.png" alt="img"></p><p><strong>多线程中的 i++线程安全吗？为什么？</strong></p><p>不安全。i++不是原子性操作。i++分为读取 i 值，对 i 值加一，再赋值给 i，执行期中任 何一步都是有可能被其他线程抢占的。</p><p><strong>线程，进程，然后线程创建有很大开销，怎么优化？</strong></p><p>使用线程池</p><p><strong>线程池运行流程，参数，策略</strong></p><p>线程池主要就是指定线程池核心线程数大小，最大线程数，存储的队列，拒绝策略，空闲线程存活时长。当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列 满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝 策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。</p><p><strong>讲一下 AQS</strong></p><p>AQS 其实就是一个可以给我们实现锁的框架 </p><p>内部实现的关键是：先进先出的队列、volatile修饰的state状态 </p><p>定义了内部类 ConditionObject </p><p>拥有两种线程模式独占模式和共享模式</p><p>在LOCK包中的相关锁(常用的有 ReentrantLock、 ReadWriteLock)都是基于AQS来构建，一般我们叫 AQS 为同步器。</p><p><strong>创建线程的方法，哪个更好，为什么</strong></p><ul><li>继承Java.lang.Thread 类派生一个新的线程类，重写它的 run()方法； </li><li>实现 Runnalbe 接口，实现 Runnalbe接口中的run()方法</li><li>实现Runnable接口更好，避免了java单继承的局限性</li></ul><p><strong>Java 中有几种方式启动一个线程？</strong></p><ul><li>继承Thread类，重写run()方法</li><li>实现Runnable接口，实现run()方法</li><li>通过FutureTask, 实现Callable接口的call()方法，call()方法可以有返回值</li><li>使用线程池，Executors工具类</li></ul><p><strong>Java 中有几种线程池？</strong></p><ol><li>newFixedThreadPool 创建一个指定工作线程数量的线程池。每当提交一个任务就创建一 个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入阻塞队列中。</li><li>newCachedThreadPool 创建一个可缓存的线程池。这种类型的线程池特点是：<ol><li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程</li><li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1 分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个 工作线程。</li></ol></li><li>newSingleThreadExecutor 创建一个单线程化的 Executor，即只创建唯一的工作者线程 来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特 色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个 线程是活动的</li><li>newScheduleThreadPool 创建一个定长的线程池，而且支持定时的以及周期性的任务执 行，类似于 Timer</li></ol><p><strong>线程池有什么好处？</strong></p><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行</li><li>提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li></ol><p><strong>cyclicbarrier 和 countdownlatch的区别</strong></p><p>CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同：</p><ul><li>CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行</li><li>而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行</li><li>另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的</li></ul><p><strong>同步方法和同步代码块的区别是什么？</strong></p><p>同步方法默认用 this 或者当前类 class对象作为锁；</p><p>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</p><p><strong>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同 步？</strong></p><ul><li>在Java虚拟机中，每个对象（object和class）通过某种逻辑关联监视器，每个监视器和一个对象引用相关联，为了实现监视器的互斥功能，每个对象都关联着一把锁。</li><li>一旦方法或者代码块被synchronized修饰，那么这个部分就放入了监视器的监视区域，确保一次只有一个线程执行该部分代码，线程必须在获取锁之前不允许执行该部分代码。</li><li>Java提供了显示监视器（Lock）和隐式监视器（synchronized）两种锁方案。</li></ul><p><strong>sleep() 和 wait() 有什么区别？</strong></p><ul><li>这两个方法来自不同的类分别是Thread和Object，sleep方法属于Thread类中的静态方法，wait属于Object的成员方法。</li><li><strong>sleep()<strong>是线程类（Thread）的方法，不涉及线程通信，调用时会暂停此线程指定的时间，但监控依然保持，</strong>不会释放对象锁</strong>，到时间<strong>自动恢复</strong>；<strong>wait()<strong>是Object的方法，用于线程间的通信，调用时会</strong>放弃对象锁</strong>，进入<strong>等待</strong>队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才进入对象锁定池准备获得对象锁进入运行状态。</li><li>wait，notify和notifyAll只能在<strong>同步控制方法</strong>或者<strong>同步控制块</strong>里面使用，而sleep可以在任何地方使用（使用范围）。</li><li>sleep()方法必须捕获异常InterruptedException，而wait()\notify()以及notifyAll()不需要捕获异常。</li></ul><p><strong>同步和异步有何异同？在什么情况下分别使用他们？举例说明</strong></p><p>Java中交互方式分为同步和异步两种：</p><ul><li>同步交互：指发送一个请求,需要等待返回,然后才能够发送下一个请求，有个等待过程；</li><li>异步交互：指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。</li></ul><p>相同的地方：</p><ul><li>都属于交互方式，都是发送请求。</li></ul><p>不同的地方：</p><ul><li>一个需要等待，一个不需要等待。</li></ul><p>简单而言，同步就是必须一件一件的做事，等前一件事做完后才能做下一件事。而异步这是把事情指派给别人后，接着继续做下一件事，不必等别人返回的结果。</p><p>作用：</p><ul><li>同步可以避免读脏数据的发生，一般共享某一资源的时候用，如果每个人都有修改权限，同时修改一个文件，有可能使一个人读取另一个人已经删除的内容，就会出错，同步就会按顺序来修改。但是同步会造成死锁。</li><li>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</li><li>异步则是可以提高效率了，现在cpu都是双核，四核，异步处理的话可以同时做多项工作，当然必须保证是可以并发处理的。</li></ul><p>举例：</p><ul><li>广播，就是一个异步例子。发起者不关心接收者的状态。不需要等待接收者的返回信息；在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式。</li><li>电话，就是一个同步例子。发起者需要等待接收者，接通电话后，通信才开始。需要等待接收者的返回信息</li><li>比如银行的转账系统，对数据库的保存操作等等，都会使用同步交互操作。</li></ul><p><strong>启动一个线程是用 run()还是 start()?</strong></p><p>启动线程肯定要用start()方法。当用start()开始一个线程后，线程就进入就绪状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。当cpu分配给它时间时，才开始执行run()方法(如果有的话)。如果直接调用run方法，就是执行run方法的内容，按顺序从上向下执行。</p><p><strong>请说出你所知道的线程同步的方法。</strong></p><ul><li>Wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</li><li>Notify(): 唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。</li><li>notityAll(): 唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</li></ul><p><strong>AVA中多线程stop() 和 suspend()方法为何不推荐使用？</strong></p><ul><li>反对使用 stop(),是因为它不安全。它会解除由线程获取的所有锁定,而且如果对象处于一 种不连贯状态,那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。</li><li>suspend()方法容易发生死锁。调用suspend()的时候,目标线程会停下来,但却仍然持有在这之前获得的锁。此时,其他任何线程都不能访问锁定的资源,除非被”挂起”的线程恢复运行。对任何线程来说,如果它们想恢复目标线程,同时又试图使用任何一个锁定的资源,就会造成死锁。所以不应该使用suspend(),而应在自己的Thread类中置入一个标志,指出线程应该活动还是挂起。若标志指出线程应该挂起,便用wait()命其进入等待状态。若标志指出线程应当恢复,则用一个notify()重新启动线程。</li></ul><p><strong>线程的sleep()方法和yield()方法有什么区别?</strong></p><ul><li>sleep()方法给其他线程运行机会时不考虑线程的优先级,因此会给低优先级的线程以运行的机会</li><li>yield()方法只会给相同优先级或更高优先级的线程以运行的机会</li><li>线程执行sleep()方法后转入阻塞(blocked)状态,而执行yield()方法后转入就绪(ready)状态</li><li>sleep()方法声明会抛出InterruptedException,而yield()方法没有声明任何异常</li><li>sleep()方法比yield()方法具有更好的移植性(跟操作系统CPU调度相关)。因为sleep()之后，如果存在其他线程，一定会让其它线程先执行。如果是yield()，线程进入就绪态，可能又抢夺了资源进入运行态，并不能保证其它线程一定得到资源。</li></ul><p><strong>当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进 入此对象的 synchronized 方法 B？</strong></p><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p><p><strong>讲一下非公平锁和公平锁在 reetrantlock 里的实现</strong></p><ul><li>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，FIFO。对于非公平锁，只要 CAS 设置同步状态成功，则表示当前线程获取了锁，而公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</li><li>简言之，非公平锁在想获取锁时可以直接参与锁的竞争，即使前面已经有其他线程想要获取锁资源。</li></ul><p><strong>讲一下 synchronized，可重入怎么实现。</strong></p><p>每个锁关联一个线程持有者和一个计数器。当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM 会记下持有锁的线程，并将计数器计为 1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个 synchronized 方法/块时，计数器会递减，如果计数器为 0 则释放该锁</p><p><strong>锁和同步的区别</strong></p><p>用法上的不同：</p><ul><li>synchronized 既可以加在方法上，也可以加载特定代码块上，而 lock 需要显示地指定起始位置和终止位置。</li><li>synchronized 是托管给 JVM 执行的，lock的锁定是通过代码实现的，它有比 synchronized 更精确的线程语义。</li></ul><p>性能上的不同：</p><ul><li>lock 接口的实现类 ReentrantLock，不仅具有和 synchronized 相同的并发性和内存语义，还多了超时的获取锁、定时锁、等候和中断锁等。</li><li>在竞争不是很激烈的情况下，synchronized 的性能优于 ReentrantLock，竞争激烈的情况下 synchronized 的性能会下降的非常快，而 ReentrantLock 则基本不变。</li></ul><p>锁机制不同：</p><ul><li>synchronized 获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁。而 Lock 则需要开发人员手动释放，并且必须在 finally 中释放，否则会引起死锁。</li></ul><p><strong>什么是死锁(deadlock)？</strong></p><ul><li>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。</li><li>例如，如果线程 1 锁住了 A，然后尝试对 B 进行加锁，同时线程 2 已经锁住了 B，接着尝试 对 A 进行加锁，这时死锁就发生了。线程 1 永远得不到 B，线程 2 也永远得不到 A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A 和 B），它们将永远阻塞下去。这种情况就是一个死锁。</li></ul><p><strong>如何确保 N 个线程可以访问 N 个资源同时又不导致死锁</strong></p><p>多线程产生死锁的四个必要条件： </p><ol><li>互斥条件：一个资源每次只能被一个进程使用。    </li><li>保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。    </li><li>不可剥夺：进程已获得资源，在未使用完成前，不能被剥夺。    </li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>只要破坏其中任意一个条件，就可以避免死锁。</p><ol><li>指定加锁顺序。所有线程按照相同的顺序获得资源的锁，不先获得顺序靠前的锁，无法获得后续的锁。则<strong>先获得锁</strong>的线程不会请求<strong>后获得锁</strong>的线程占用的资源，因为<strong>后获得锁</strong>的线程还没能获得<strong>先获得锁</strong>的线程未释放的锁，更无法占用<strong>先获得锁</strong>的线程还没获得的顺序靠后的锁。缺点：需要手动对锁的获得顺序进行分析。   </li><li>指定加锁时限：线程指定超时时间，若无法获得锁的占用权，进行回退操作，并释放已占用的锁，经一段延时后再尝试进行任务。<ol><li>缺点 ：线程过多的话，可能造成频繁回退，运行效率不高。   </li></ol></li><li>死锁检测：将线程和已获得锁的情况记录下来，定时检测是否所有死锁现象（线程循环等待现象），回退处于死锁状态的线程，延时后，重试这些线程，与添加加锁时限类似，缺点也同。</li></ol><p><strong>Java 中的 LongAdder 和 AtomicLong的区别</strong></p><ul><li>AtomicLong 是基于 CAS 方式自旋更新的；LongAdder 是把 value 分成若干cell，并发量低的时候，直接 CAS 更新值，成功即结束。并发量高的情况，CAS更新某个cell值和需要时对cell数据扩容，成功结束；更新失败自旋 CAS 更新 cell值。取值的时候，调用 sum() 方法进行每个cell累加。</li><li>AtomicLong 包含有原子性的读、写结合的api；LongAdder 没有原子性的读、写结合的api，能保证结果最终一致性。</li><li>低并发场景AtomicLong 和 LongAdder 性能相似，高并发场景 LongAdder 性能优于 AtomicLong。</li></ul><p><strong>JDK 和 JRE 的区别是什么？</strong></p><p>Java 运行时环境(JRE)是将要执行 Java 程序的 Java 虚拟机。它同时也包含了执行 applet 需要的浏览器插件。Java 开发工具包(JDK)是完整的 Java 软件开发包，包含了 JRE，编译器和其 他的工具(比如：JavaDoc，Java 调试器)，可以让开发者开发、编译、执行 Java 应用程序</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA无法启动</title>
      <link href="/2021/12/25/IDEA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
      <url>/2021/12/25/IDEA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>双击打开IDEA发现无法启动，显示Start Failed后无任何提示信息。</p><p>一番尝试后发现是端口被占用。</p><p>解决方案：</p><p>在命令行中执行以下命令(需要管理员权限)：</p><ul><li>免重启方案<ul><li>net stop winnat</li><li>net start winnat</li></ul></li><li>需要重启的方案<ul><li>netsh winsock reset</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题-数据结构与算法篇</title>
      <link href="/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><h3 id="1-整数除法"><a href="#1-整数除法" class="headerlink" title="#1 整数除法"></a>#1 整数除法</h3><p>输入两个int型整数，它们进行除法计算并返回商，**要求不得使用乘号*，除号/以及求余符号%**，当发出溢出时，返回最大的整数值。假设除数不为0。例如，输入15和2，输出15/2，即7。（注意：int型范围是-2^31 ~ -2^31-1）</p><p>分析：</p><p>只基于减法实现是可以的，但是此情况的最坏时间复杂度为O(n)，需要对效率进一步提升。</p><p>当被除数大于出除数时，继续比较判断被除数是否大于除数的2倍，如果是，则继续判断被除数是否大于除数的4倍、8倍等。如果被除数最多大于除数的2^k倍，那么将被除数减去除数的2^k倍，然后将剩余的被除数重复前面的步骤。由于每次将除数翻倍，因此优化后的时间复杂度是O(logn)。</p><p>细节：</p><ol><li>最小的整数是-2^31, 最大的整数是2^31-1。因此，如果将负整数直接转换为正整数可能导致溢出。可以先将正整数都转换成负整数，再根据需要调整商的符号。</li><li>直接溢出的情况，被除数为-2^31，除数为-1</li><li>防止被除数在扩大一倍时溢出，所以需要提前判断</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 辅助判断符号,奇数为负，偶数为正</span></span><br><span class="line">        <span class="keyword">int</span> negative = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            negative--;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            negative--;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = divideCore(dividend, divisor);</span><br><span class="line">        <span class="keyword">return</span> negative == <span class="number">1</span> ? -result : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divideCore</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dividend &lt;= divisor) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = divisor;</span><br><span class="line">        <span class="keyword">int</span> quotient = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个判断条件很重要，防止后面value扩大一倍时溢出</span></span><br><span class="line">        <span class="keyword">while</span> (value &gt;= Integer.MIN_VALUE / <span class="number">2</span> &amp;&amp; dividend &lt;= value + value) &#123;</span><br><span class="line">            quotient += quotient;</span><br><span class="line">            value += value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result += quotient;</span><br><span class="line">        dividend -= value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-二进制加法"><a href="#2-二进制加法" class="headerlink" title="#2 二进制加法"></a>#2 二进制加法</h3><p>给定两个表示二进制的字符串，请计算它们的和，并以二进制字符串的形式输出。例如，输入的二进制字符串分别是”11”和”10”，则输出”101”</p><p>注意：不能直接将二进制字符串转换成整数运算，因为并没有限定二进制字符串的长度，可能会造成溢出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a_length = a.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b_length = b.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (a_length &gt;= <span class="number">0</span> || b_length &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> digitA = a_length &gt;= <span class="number">0</span> ? a.charAt(a_length--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digitB = b_length &gt;= <span class="number">0</span> ? b.charAt(b_length--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = digitA + digitB + carry;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">            sum -= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑最后是否存在进位</span></span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">        result.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为存储顺序是从右至左，所以需要逆序输出</span></span><br><span class="line">    <span class="keyword">return</span> result.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-前n个数字二进制形式中1的个数"><a href="#3-前n个数字二进制形式中1的个数" class="headerlink" title="#3 前n个数字二进制形式中1的个数"></a>#3 前n个数字二进制形式中1的个数</h3><p>输入一个非负数n，请计算0到n之间每个数字的二进制形式中1的个数，并输出一个数组。例如，输入的n为4，由于0、1、2、3、4的二进制形式中1的个数分别为0、1、1、2、1，因此输出数组[0,1,1,2,1]。</p><p>简单分析：最直观的解法，就是用for循环来计算从0到n的每个整数i的二进制形式中1的个数。于是问题转换成如何求一个整数i的二进制形式中1的个数。</p><p>思路</p><ol><li><p>根据<code>i&amp;(i-1)</code>计算</p><p>此公式的核心思想是把i最右面的1变成0。可以通过for循环，不断地把最右边的1变成0，变化了几次就说明有几个1。其中页暗藏动态规划的思想，数字i中1的个数比i&amp;(i-1)中1的个数多1。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于思路<span class="number">1</span>实现:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countBits_1(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result[i] = result[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>根据<code>i/2</code>计算</p><p>通过观察发现，如果正整数i是偶数，那么i相当于’i/2’左移一位的结果，因此它们的二进制形式中1的个数是相同的。如果i是奇数，那么i相当于’i/2’左移一位之后，再将最右边一位设成1的结果，因此奇数i的二进制形式中1的个数比’i/2’中的1的个数多1。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于思路<span class="number">2</span>实现:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countBits_2(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// i &amp; 1, i为奇数则结果为1, 偶数为0</span></span><br><span class="line">        result[i] = result[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上述代码用’i &gt;&gt; 1’计算’i/2’，用’i &amp; 1’计算’i%2’，因为位运算比除法运算和求余运算更高效。</p><h3 id="4-只出现一次的数字"><a href="#4-只出现一次的数字" class="headerlink" title="#4 只出现一次的数字"></a>#4 只出现一次的数字</h3><p>输入一个整数数组，书注重只有一个数字出现了一次，而其他数字都出现了3次。请找出那个只出现一次的数字。例如，如果输入的数组为[0,1,0,1,0,1,100]，则只出现一次的数字是100。</p><p>思路：一个整数是由32个0或1组成的。我们可以将数组中所有数字的同一位置的数位相加。因此，<strong>如果数组中所有数字的第i个数位相加之和能被3整除，那么只出现一次的数字的第i个位数一定是0；如果数组中所有数字的第i个数位相加之和被3除余1，那么只出现一次的数字的第i个数位一定是1。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代表整数的长度为32bit</span></span><br><span class="line">    <span class="keyword">int</span>[] bitSums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把数组中所有数字按对应的bit位累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            bitSums[i] += (num &gt;&gt; (<span class="number">31</span> - i)) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断累加后对应的bit位能否被三整除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        result = (result &lt;&lt; <span class="number">1</span>) + bitSums[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举一反三：</strong>如果数组中只有一个数字出现m次，其他数字都出现n次，m不能被n整除，找出唯一出现m次的数字。</p><p>用同样的思路解决此问题，最后验证累加后的整数对应bit位能否被m整除。</p><h3 id="5-单词长度的最大乘积"><a href="#5-单词长度的最大乘积" class="headerlink" title="#5 单词长度的最大乘积"></a>#5 单词长度的最大乘积</h3><p>给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p><p>例如：输入的字符串数组words为[“abcw”,”foo”,”bar”,”fxyz”,”abcdef”], 最后返回的应该是16。</p><p>思路1：</p><p>假设两字符串长度分别为p,q。</p><ol><li>最直观的解法就是蛮力法。如果蛮力法比较两个字符串是否有相等字符，比较的时间复杂度为O(pq)。</li><li>通过哈希表来优化时间效率。对于每个字符串，用一个哈希表记录该字符串中的所有字符。因为题目假设的所有字符都是英文小写字母，只有26个可能的字符，因此最多只需要在每个字符串对应的哈希表中查询26次就能判断两个字符串是否包含相同的字符，因此比较的时间复杂度为O(1)。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct_1</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[words.length][<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 生成哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">            flags[i][c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 判断word i 和 word j是否有相同的字符</span></span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flags[i][k] == <span class="keyword">true</span> &amp;&amp; flags[j][k] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// k = 26说明没有相同字符</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> prod = words[i].length() * words[j].length();</span><br><span class="line">                result = Math.max(result, prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>进一步分析此方法的时间和空间复杂度。</p><p>第一步，初始化每个字符串对应的哈希表。如果words的长度为n，凭均每个字符串的长度为k，那么初始化哈希表的时间复杂度为O(nk)。</p><p>第二步，根据哈希表判断每对字符串是否包含相同的字符。总共有O(n^2)对字符串，每次判断需要的时间为O(1)，因此这一步的时间复杂度为O(n^2)。</p><p><strong>于是这种解法的整体时间复杂度为O(nk + n^2)。</strong></p><p>为每一个字符串创建一个数组，所以<strong>空间复杂度为O(n)</strong></p></li></ol><p>思路2：用整数的二进制数位记录字符串中出现的字符</p><p>前面的解法是用一个长度为26的布尔型数组记录字符串中出现的字符。布尔值只有两种可能，true or false。这与二进制有些类似。因此，可以将长度为26的布尔型数组用26个二进制的数位代替，二进制的0对应布尔值的false，1对应true。</p><p>26bit就足以表示一个字符串中可能出现的字符，所以我们可以用int(32bit)来表示。<strong>用二进制数位表示的好处是可以更快地判断两个字符串是否包含相同的字符。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct_2</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] flags = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : words[i].toCharArray()) &#123;</span><br><span class="line">            flags[i] |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 说明两个字符串没有相同的字符</span></span><br><span class="line">            <span class="keyword">if</span> ((flags[i] &amp; flags[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> prod = words[i].length() * words[j].length();</span><br><span class="line">                result = Math.max(result, prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>与思路1时间空间复杂度均相同。</p><p>但是在比较是否存在相等字符时，只需要一次运算即可。而思路1中可能需要26次布尔运算，所以<strong>新的解法时间效率更高</strong>。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="#双指针"></a>#双指针</h3><p>方向相反的双指针经常用来求排序数组中的两个数字之和。</p><p>方向相同的双指针通常用来求正数数组中子数组的和或乘积。</p><h3 id="6-排序数组中的两个数字之和"><a href="#6-排序数组中的两个数字之和" class="headerlink" title="#6 排序数组中的两个数字之和"></a>#6 排序数组中的两个数字之和</h3><p>考点 <code>双指针</code></p><p>输入一个递增序列的数组和一个值k，请问如何在数组中找出两个和为k的数字并返回它们的下标？假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。</p><p>例如：输入数组[1,2,4,6,10], k的值为8，应该返回[1,3]</p><p>分析：</p><ol><li><p>最直观的暴力解法，固定数组中的一个数字，然后判断数组中其余数字与他的和是不是等于k。可以看成是用两个for循环遍历数组，<strong>时间复杂度为O(n^2)</strong></p></li><li><p>上述解法可以用二分查找优化。还是先固定一个数字i，然后用二分查找寻找k-i。时间复杂度为O(nlogn)。</p></li><li><p>上述解法还可以用空间换时间进行优化。可以先将数组中所有的数字都放入一个哈希表，然后逐一扫描数组中的每个数字。扫描i, 就在哈希表里找k-i。判断哈希表中是否存在一个数字的时间复杂度为O(1)，因此新解法的**时间复杂度为O(n)<strong>。同时它需要一个大小为O(n)的哈希表，因此</strong>空间复杂度也是O(n)**。</p></li><li><p>存在时间复杂度是O(n)，空间复杂度是O(1)的解法，就是我们最后要引出的<code>双指针</code>。</p><p>两个指针一个从前向后移动，一个从后向前移动。如果小于target前指针后移，如果大于target后指针前移。如果相等则返回指针对应的索引。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// 双指针，一个从前向后移动，一个从后向前移动</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = numbers.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] != target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] + numbers[j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-数组中和为0的3个数字"><a href="#7-数组中和为0的3个数字" class="headerlink" title="#7 数组中和为0的3个数字"></a>#7 数组中和为0的3个数字</h3><p>输入一个数组，如何找出数组中所有和为0的3个数字的三元组？需要注意的是，返回值中不得包含重复的三元组。</p><p>例如：在数组[-1,0,1,2,-1,-4]中有两个三元组的和为0，它们分别是[-1,0,1]和[-1,-1,2]。</p><p>分析：</p><p>这是上一题的加强版。如果输入的数组是排序的，我们就可以先固定一个数字i，然后再排序数组中查找和为-i的两个数字。我们已经有了用O(n)时间在排序数组中找出和为给定值的两个数字的方法，由于需要固定数组中的每个数字，因此查找此三元组的时间复杂度是O(n^2)。</p><p>但是这个题目并没有说给出的数组是排序的，因此需要先对数组排序。排序算法的时间复杂度通常是O(nlogn)，因此这种解法的总时间复杂度是O(logn + n^2), <strong>最后还是O(n^2)</strong></p><p>最后要注意去除重复的三元组。在指针移动时跳过所有相同的值即可。需要跳过相同值的地方共有两处，第一处是固定i的时候，第二处是双指针移动的时候。移动前指针和后指针都可以，移动的那个指针要考虑跳过重复值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length - <span class="number">2</span>) &#123;</span><br><span class="line">            twoSum(nums, i, result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过重复的数字</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">while</span> (nums[i] == temp &amp;&amp; i &lt; nums.length - <span class="number">2</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class="line">    <span class="comment">// 双指针，一个从前向后移动，一个从后向前移动</span></span><br><span class="line">    <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过重复的数字</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">            <span class="keyword">while</span> (nums[j] == temp &amp;&amp; j &lt; k) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-和大于或等于k的最短子数组"><a href="#8-和大于或等于k的最短子数组" class="headerlink" title="#8 和大于或等于k的最短子数组"></a>#8 和大于或等于k的最短子数组</h3><p>输入一个正整数组成的数组和一个正整数k，请问数组中和大于或等于k的连续子数组的最短长度是多少？如果不存在所有数字之和大于或等于k的子数组，则返回0。</p><p>例如：输入数组[5,1,4,3]，k的值为7，最后输出2。</p><p>考点 <code>双指针</code></p><p>分析：</p><p>用两个指针P1，P2来锁定子数组，子数组由两个指针之间所有数字组成。</p><p>初始化时两指针都指向数组的第一个元素。</p><p>如果子数组和大于等于k，则P1右移，相当于从子数组的最左边删除一个数字，子数组长度减1。如果子数组和小于k，则P1右移，相当于在子数组的最右边添加一个新的数字，子数组长度加1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; right &lt; nums.length; right++) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>尽管代码中有两个嵌套的循环，但是**时间复杂度仍然是O(n)**。因为left和right都只加不减，变化范围都是[0~n-1]。</p><h3 id="9-乘积小于k的子数组"><a href="#9-乘积小于k的子数组" class="headerlink" title="#9 乘积小于k的子数组"></a>#9 乘积小于k的子数组</h3><p>输入一个由正整数组成的数组和一个正整数k，请问数组中有多少个数字乘积小于k的连续子数组？</p><p>例如：输入数组[10,5,2,6]，k的值为100，有8个子数组的所有数字的乘积小于100。</p><p>考点 <code>双指针</code></p><p>分析：</p><p>与上一题思路类似，用双指针P1，P2锁定子数组，如果子数组中所有数字的乘积小于k，那么右移P2；反之则右移P1。当指针P1到某个位置时子数组的乘积小于k，就不需要再向右移动指针P1。因为只要保持指针P2不动，向右移动指针P1形成的所有子数组的数字乘积就一定小于k。<strong>此时两个指针之间有多少个数字，就找到了多少个数字乘积小于k的子数组。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; right &lt; nums.length; right++) &#123;</span><br><span class="line">        product *= nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; product &gt;= k) &#123;</span><br><span class="line">            product /= nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        result += right &gt;= left ? right - left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>和上一题同理，<strong>时间复杂度为O(n)</strong></p><h3 id="累加数组数字求子数组之和"><a href="#累加数组数字求子数组之和" class="headerlink" title="#累加数组数字求子数组之和"></a>#累加数组数字求子数组之和</h3><p>使用双指针解决子数组之和问题有一个前提条件：数组中的所有数字都是正数。如果数组中有正数、负数和零，那么双指针的思路并不适用。因为当数组中有负数时在子数组中添加数字不一定能增加子数组之和，从子数组中删除数字也不一定能减少子数组之和。</p><p>所以引出求子数组和的另一种思路：<code>累加数组数字</code></p><p>首先需要预处理。假设数组长度为n，从头到尾扫描一次，就能求出从下标0开始到下标0结束的所有子数组之和S_0，从下标0开始到下标1结束的子数组之和S_1，以此类推，直到求出从下标0开始到最后一个数字的子数组之和S_n-1。因此，<strong>从下标为i开始到下标为j结束的子数组的和就是S_j - S_i-1</strong>。</p><h3 id="10-和为k的子数组"><a href="#10-和为k的子数组" class="headerlink" title="#10 和为k的子数组"></a>#10 和为k的子数组</h3><p>输入一个整数数组和一个整数k，请问数组中有多少个数字之和等于k的连续子数组？</p><p>例如：输入数组[1,1,1]，k的值为2，有2个连续子数组之和等于2。</p><p>分析：</p><p>最先想到暴力解法。在一个长度为n的数组中有O(n^2)个子数组，如果求出每个子数组的和需要O(n)的时间，那么总共需要O(n^3)的时间就能求出所有子数组的和。</p><p>对暴力解法进一步优化。在计算长度为i的子数组数字之和时，应该把子数组堪称长度为i-1的子数组的基础上添加一个新的数字。因此，如果已经求出了长度为i-1的子数组的数字之和，那么只要再加上新添加的数字就能得出长度为i的子数组的数字之和。因为只需要1次加法，需要O(1)时间，优化后的时间复杂度为O(n^2)。</p><p>再换一种思路，我们从头到尾扫描数组中的数字时求出前i个数字之和，并将结果保存下来。当扫描到数组的第i个数字时并求得前i个数字之和是x时，需要知道在i之前存在多少个j，满足前j个数字之和等于x-k。<strong>所以，对于每个i，不但要保存前i个数字之和，还要保存每个和出现的次数。</strong> 分析到这儿就知道我们需要一个哈希表，键是前i个数字之和，值是每个和出现的次数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; sumToCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刚开始累加和为0</span></span><br><span class="line">    sumToCount.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        result += sumToCount.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">        sumToCount.put(sum, sumToCount.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>只需要从头至尾扫描数组一次，所以**时间复杂度为O(n)<strong>。需要一个哈希表保存前i个数字的和及出现的次数，所以</strong>空间复杂度为O(n)**。</p><h3 id="11-0和1个数相同的子数组"><a href="#11-0和1个数相同的子数组" class="headerlink" title="#11 0和1个数相同的子数组"></a>#11 0和1个数相同的子数组</h3><p>输入一个只包含0和1的数组，请问如何求0和1个数相同的最长连续子数组的长度？</p><p>例如：在数组[0,1,0]中有两个子数组包含相同个数的0和1，分别是[0,1]和[1,0]，他们的长度都是2，因此输出2。</p><p>分析：</p><p><strong>如果题目中所有的0都变成-1，那么01个数相同的子数组和必为1。这样此题就转换成了一个求和为k的子数组的问题。</strong>想要完成这样的转换也很简单，只需要在每次累加时，判断当前数字时否为0，如果为0则累加-1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; sumToIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果累加和为0，说明01数量已经相等，长度=索引+1</span></span><br><span class="line">    sumToIndex.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i] == <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sumToIndex.containsKey(sum)) &#123;</span><br><span class="line">            result = Math.max(result, i - sumToIndex.get(sum));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sumToIndex.put(sum, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>与求和为k的子数组同理，<strong>时间复杂度空间复杂度都为O(n)</strong></p><h3 id="12-左右两边子数组的和相等"><a href="#12-左右两边子数组的和相等" class="headerlink" title="#12 左右两边子数组的和相等"></a>#12 左右两边子数组的和相等</h3><p>输入一个整数数组，如果一个数字左边的子数组的数字之和等于右边的子数组的数字之和，那么返回该数字的下标。如果存在多个这样的数字，则返回最左边一个数字的下标。如果不存在这样的数字，则返回-1。</p><p>例如：在数组[1,7,3,6,2,9]中，下标为3的数字左右两边子数组之和相等，因此应该输出3。</p><p>分析：</p><p>当扫描到第i个数字时，可以算出前i个数字的累加和。此时，i左边子数组的和等于前i个数字的和减i，i右边子数组的和等于整个数组的和total减前i个数字的累加和。所以此题还得求整个数组的累加和total。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pivotIntex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; nums.length; i++) &#123;</span><br><span class="line">        total += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum - nums[i] == total - sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>共有两个时间复杂度为O(n)的循环，因此**时间复杂度为O(n)<strong>。并没有使用数组、哈希表等辅助数据容器，因此</strong>空间复杂度为O(1)**。</p><h3 id="13-二维子矩阵的数字之和"><a href="#13-二维子矩阵的数字之和" class="headerlink" title="#13 二维子矩阵的数字之和"></a>#13 二维子矩阵的数字之和</h3><p>输入一个二维矩阵，如何计算给定左上角坐标和右下角坐标的子矩阵的数字之和？对于同一个二维矩阵，计算子矩阵的数字之和的函数可能由于输入不同的坐标而被反复调用多次。</p><p>例如：输入如下矩阵和坐标(2,1),(4,3)，应该返回8</p><p>[[3,0,1,4,2],</p><p>[5,6,3,2,1],</p><p>[1,2,0,1,5],</p><p>[4,1,0,1,7],</p><p>[1,0,3,0,5]]    </p><p>分析：</p><p>如果不考虑时间复杂度，采用蛮力法用两个嵌套的循环总是可以求出一个二维矩阵的数字之和。如果矩阵的行数和列数分别是m和n，那么这种蛮力法的时间复杂度是O(mn)。但是由于题目提到，计算函数可能被反复调用多次，因此应该优化求和的过程，尽快地实现子矩阵求和函数。</p><p>我们用[(r1,c1)(r2,c2)]来表示左上角坐标为(r1,c1)，右下角坐标为(r2,c2)的子矩阵的数字之和。通过观察发现，此矩阵的数字之和可以用4个左上角坐标为(0,0)的子矩阵的数字之和求得。[(r1,c1)(r2,c2)] = [(0,0)(r2,c2)] - [(0,0)(r2,c1-1)] - [(0,0)(r1-1,c2)] + [(0,0)(r1-1,c1-1)]。</p><p>再进一步思考，只要在预处理阶段求出(0,0)到每个右下角坐标的子矩阵的数字之和，然后存到一个辅助矩阵中，目标子矩阵的数字之和就可以在常数时间内计算完毕。 </p><p>那要怎么计算子矩阵呢？可以把[(0,0),(i,j)]看成两部分。第一部分是[(0,0),(i-1,j)],第二部分是矩阵中第i行中列号从0到j的所有数字。<strong>为了计算方便，可以在初始化时创建一个比原数组行列多1的辅助矩阵。这样在计算辅助矩阵的第一行时也可以在循环中进行。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] NumMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] sums = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length+<span class="number">1</span>][matrix[<span class="number">0</span>].length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> rowSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            rowSum += matrix[i][j];</span><br><span class="line">            sums[i+<span class="number">1</span>][j+<span class="number">1</span>] = sums[i][j+<span class="number">1</span>] + rowSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> sums[][], <span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sums[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] </span><br><span class="line">        - sums[row1][col2 + <span class="number">1</span>] </span><br><span class="line">        - sums[row2 + <span class="number">1</span>][col1] </span><br><span class="line">        + sums[row1][col1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>用两个嵌套的for循环计算辅助矩阵，时间复杂度为O(mn)。同时，辅助矩阵需要的空间也为O(mn)。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>java中String类型所表达的字符串时无法改变的。如果对字符串进行写操作，那么修改的内容在返回值的字符串中，原来的字符串保持不变。</p><p>由于每次对String实例进行修改将创建一个新的String实例，因此如果连续多次对String实例进行修改将连续创建多个新的String实例，不必要的内存开销较大。所以可以借助StringBuilder或StringBuffer(线程安全效率低)来容纳修改后的结果。</p><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="#双指针"></a>#双指针</h3><p>如果将字符串看成一个由字符串组成的数组，那么也可以用两个指针来定位一个子字符串。</p><p>可以在移动这两个指针的同时，统计两个指针之间的字符串中字符出现的次数，这样可以解决很多常见的面试题，如定位变位词等。</p><p>由于这种类型的面试题都与统计字母出现的次数有关，我们经常使用哈希表来存储每个元素出现的次数，因此解决这种类型的面试题通常需要同时使用<strong>双指针和哈希表</strong>。</p><h3 id="14-字符串中的变位词"><a href="#14-字符串中的变位词" class="headerlink" title="#14 字符串中的变位词"></a>#14 字符串中的变位词</h3><p>输入字符串s1和s2，如何判断字符串s2中是否包含字符串s1的某个变位词？如果字符串s2中包含字符串s1的某个变位词，则字符串s1至少有一个变位词是字符串s2的子字符串。假设两个字符串中只包含英文小写字母。</p><p>例如：</p><ol><li>字符串s1为”ac”, s2为”dgcaf”, 输出true</li><li>字符串s1为”ab”, s2为”dgcaf”, 输出false</li></ol><p>分析：</p><p>还是最先想到暴力法。可以先求出字符串s1的所有排列，然后判断每个排列是不是字符串s2的子字符串。如果一个字符串有n个字符，那么它一共有n!个排列，因此这种解法的时间复杂度不会低于O(n!)。</p><p>下面尝试更高效的解法。我们可以以用一个哈希表来存储每个字符出现的次数。首先扫描s1，每扫描到一个字符，就找到它在哈希表中的位置并把对应的值加1。然后考虑s2中是否有s1的变位词。假设字符串s2中有一个子字符串是s1的变位词，逐个扫描这个变位词中的字母，并把字母在哈希表中对应的值减1。<strong>如果同位词存在，最后操作完，哈希表中所有的值应该都是0。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s2.length() &lt; s1.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 先判断第一组和s1等长的子字符串是否是其变位词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i 为第一个指针的索引， i - s1.length() + 1为第二个指针的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s1.length(); i &lt; s2.length(); i++) &#123;</span><br><span class="line">            counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            counts[s2.charAt(i - s1.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areAllZero</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：需要扫描字符串s1和s2各一次，如果他们的长度分别是m和n，那么**时间复杂度是O(m+n)<strong>。这种解法用到了一个长度为26的数组，是一个常数，所以</strong>空间复杂度是O(1)**。</p><h3 id="15-字符串中所有的变位词"><a href="#15-字符串中所有的变位词" class="headerlink" title="#15 字符串中所有的变位词"></a>#15 字符串中所有的变位词</h3><p>输入字符串s1和s2，如何找出字符串s2的所有变位词在字符串s1中的起始下标？假设两个字符串中只包含英文小写字母。</p><p>例如：字符串s1为”cbadabacg”, 字符串s2为”abc”，应该输出0和5。</p><p>分析：就是上一题的变种。在成功找到变位词时返回对应子字符串第一个字符的索引即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; indices = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s1.length() &lt; s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 方便添加进列表</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先判断第一组子字符串</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s2.length(); i++) &#123;</span><br><span class="line">        counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">        indices.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = s2.length(); i &lt; s1.length(); i++) &#123;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        counts[s1.charAt(i - s2.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">            <span class="comment">// 注意: 前一个指针的索引是 i - s2.length() + 1</span></span><br><span class="line">            indices.add(i - s2.length() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areAllZero</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：与上一题同理，<strong>时间复杂度为O(n)</strong>, **空间复杂度为O(1)**。</p><h3 id="16-不含重复字符的最长子字符串"><a href="#16-不含重复字符的最长子字符串" class="headerlink" title="#16 不含重复字符的最长子字符串"></a>#16 不含重复字符的最长子字符串</h3><p>输入一个字符串，求该字符串中不含重复字符的最长子字符串的长度。</p><p>例如：输入字符串”babcca”，其最长的不含重复字符的子字符串是”abc”，长度为3。</p><p>分析：</p><p>用左右两个指针锁定子字符串，用哈希表存放字符出现的次数。如果两指针之间的子字符串不包含重复字符，则向前移动右指针，否则向前移动左指针。两指针初始化时都在起始位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ASCII码一共256个字符</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 用字符标识索引时，字符会自动转换成对应的ASCII码</span></span><br><span class="line">        counts[s.charAt(i)]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hasGreaterThan1(counts)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            counts[s.charAt(j)]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的j并不是左指针的位置，而是左指针前面的位置，所以不需要i-j+1</span></span><br><span class="line">        longest = Math.max(longest, i - j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasGreaterThan1</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步分析：</p><p>每次移动指针的时候都要扫描一次哈希表，虽然哈希表的长度固定，但是这个常数还是有点大。所以最好能有一个不需要多次遍历整个哈希表的解法。</p><p>其实我们真正关心的是哈希表中有没有比1大的数字，因为如果有大于的数字就说明子数组中包含重复的数字。可以定义一个变量countDup来存储哈希表中大于1的数字的个数**(其实这个值最大就是1，用boolean变量存也可以)**。当移动右指针导致哈希表中某个数字从1变成2时，变量countDup加1。当移动左指针导致哈希表中某个数字从2变成1时，变量countDup减1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ASCII码一共256个字符</span></span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> countDup = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 用字符标识索引时，字符会自动转换成对应的ASCII码</span></span><br><span class="line">            counts[s.charAt(i)]++;</span><br><span class="line">            <span class="keyword">if</span> (counts[s.charAt(i)] == <span class="number">2</span>) &#123;</span><br><span class="line">                countDup++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (countDup &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                counts[s.charAt(j)]--;</span><br><span class="line">                <span class="comment">// 检查是否有数字从2变成1</span></span><br><span class="line">                <span class="keyword">if</span> (counts[s.charAt(j)] == <span class="number">1</span>) &#123;</span><br><span class="line">                    countDup--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里的j并不是左指针的位置，而是左指针前面的位置，所以不需要i-j+1</span></span><br><span class="line">            longest = Math.max(longest, i - j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="17-包含所有字符串的最短字符串"><a href="#17-包含所有字符串的最短字符串" class="headerlink" title="#17 包含所有字符串的最短字符串"></a>#17 包含所有字符串的最短字符串</h3><p>输入两个字符串s和t，请找出字符串s中包含字符串t的所有字符的最短子字符串。</p><p>例如：输入的字符串s为”ADDBANCAD”，字符串t为”ABC”，则字符串s中包含字符’A’, ‘B’, ‘C’的最短子字符串是”BANC”。如果不存在符合条件的子字符串，则返回空字符串””。如果存在多个符合条件的子字符串，则返回任意一个。</p><p>分析：</p><p>用两个指针定位子字符串。如果某一时刻两个指针之间之间的子字符串还没有包含字符串t的所有字符，则在子字符串中添加新的字，于是向右移动第二个指针。如果已经包含字符串t的所有字符，则向右移动第一个指针。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; charToCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : t.toCharArray()) &#123;</span><br><span class="line">        charToCount.put(ch, charToCount.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当count等于0时，两指针之间的子字符串就包含t中的所有字符</span></span><br><span class="line">    <span class="keyword">int</span> count = charToCount.size();</span><br><span class="line">    <span class="comment">// start, end分别为两个指针</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, minStart = <span class="number">0</span>, minEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; s.length() || (count == <span class="number">0</span> &amp;&amp; end == s.length())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">// end &lt; s.length()</span></span><br><span class="line">            <span class="keyword">char</span> endCh = s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span> (charToCount.containsKey(endCh)) &#123;</span><br><span class="line">                charToCount.put(endCh, charToCount.get(endCh) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (charToCount.get(endCh) == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向右移动第二个指针</span></span><br><span class="line">            end++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// count == 0 &amp;&amp; end == s.length()</span></span><br><span class="line">            <span class="keyword">if</span> (end - start &lt; minLength) &#123;</span><br><span class="line">                minLength = end - start;</span><br><span class="line">                minStart = start;</span><br><span class="line">                minEnd = end;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> startCh = s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (charToCount.containsKey(startCh)) &#123;</span><br><span class="line">                charToCount.put(startCh, charToCount.get(startCh) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (charToCount.get(startCh) == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向右移动第一个指针</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minLength &lt; Integer.MAX_VALUE ? s.substring(minStart, minEnd) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>只有一个while循环，把两个变量从0增加到字符串s的长度。所以**时间复杂度为O(n)<strong>。哈希表的键为字符，假设字符串中只有英文字母，所以哈希表的大小不会超过256。因此</strong>空间复杂度为O(1)**。</p><h3 id="18-有效的回文"><a href="#18-有效的回文" class="headerlink" title="#18 有效的回文"></a>#18 有效的回文</h3><p>给定一个字符串，请判断它是不是回文。假设只需考虑字母和数字字符，并忽略大小写。</p><p>例如：”Was it a cat I saw”是一个回文字符串，而”race a car”不是回文字符串。</p><p>分析：</p><p>可以用双指针，一个从前向后移动，另一个从后向前移动。如果两指针指向的字符相同，则继续移动，直到两个指针相遇。<strong>注意：题目只考虑字母和数字字符，所以如果指针指向的字符既不是字母也不是数字，则跳过该字符。同时，由于忽略大小写，所以要把所有字母转换成相同的形式再做比较。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = s.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> ch2 = s.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (!Character.isLetterOrDigit(ch1)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isLetterOrDigit(ch2)) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ch1 = Character.toLowerCase(ch1);</span><br><span class="line">            ch2 = Character.toLowerCase(ch2);</span><br><span class="line">            <span class="keyword">if</span> (ch1 != ch2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在改变字母大小写时，建议操作字符而不是字符串。因为java中字符串不可变，修改字符串会创建新的字符串，造成内存浪费。</strong></p><p>复杂度分析：</p><p>两个指针遍历字符串，**时间复杂度为O(n)**。</p><h3 id="19-最多删除一个字符得到回文"><a href="#19-最多删除一个字符得到回文" class="headerlink" title="#19 最多删除一个字符得到回文"></a>#19 最多删除一个字符得到回文</h3><p>给定一个字符串，请判断如果最多从字符串中删除一个字符能不能得到一个回文字符串。</p><p>例如：如果输入字符串”abca”，由于删除字符串’b’或’c’就能得到一个回文字符串，因此输出为true。</p><p>分析：</p><p>与上一题类似，还是用双指针从两侧开始向里逐步比较。如果字符相同，则继续比较。如果字符不同，则按题目要求，删除一个字符后比较剩下的字符。因为不知道删除两个不同字符中的哪一个，因此都可以进行尝试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当start == s.length() / 2说明是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(; start &lt; s.length() / <span class="number">2</span>; start++, end--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start) != s.charAt(end)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> start == s.length() / <span class="number">2</span></span><br><span class="line">                || isPalindrome(s, start, end - <span class="number">1</span>)</span><br><span class="line">                || isPalindrome(s, start + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) != s.charAt(end)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start &gt;= end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：最坏情况，从左右两端第一个字符开始就出现分歧，需要判断删除的情况。此时需要遍历字符串两遍，**时间复杂度O(n)**。</p><h3 id="20-回文子字符串的个数"><a href="#20-回文子字符串的个数" class="headerlink" title="#20 回文子字符串的个数"></a>#20 回文子字符串的个数</h3><p>给定一个字符串，请问该字符串中有多少个回文连续子字符串？</p><p>例如：字符串”aaa”有6个回文子字符串，分别为”a”, “a”, “a”, “aa”, “aa” 和 “aaa”。</p><p>分析：</p><p>同样用双指针来求解，但是思路略有不同。我们考虑从字符串的中心开始向两端延申。<strong>注意：回文的长度可以是奇数也可以是偶数。长度为奇数的回文对称中心只有一个字符，而长度为偶数的回文对称中心有两个字符。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        count+= countPalindrome(s, i, i);</span><br><span class="line">        count+= countPalindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.length()</span><br><span class="line">           &amp;&amp; s.charAt(start) == s.charAt(end)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        start--;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>for循环嵌套while循环，**时间复杂度为O(n^2)**。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单向链表的简单定义"><a href="#单向链表的简单定义" class="headerlink" title="#单向链表的简单定义"></a>#单向链表的简单定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哨兵节点"><a href="#哨兵节点" class="headerlink" title="#哨兵节点"></a>#哨兵节点</h3><p>哨兵节点是为了简化处理链表边界条件而引入的附加链表节点。哨兵节点通常位于链表的头部，它的值没有任何意义。在一个有哨兵节点的链表中，从第2个节点开始才真正保存有意义的信息。</p><p><strong>用哨兵节点简化链表的插入操作</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">append</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode newNode = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="comment">// 索引到链表的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.next = newNode;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码需要用if语句来单独处理输入头节点head为null的情形。可以用哨兵节点简化代码的逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">append</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode newNode = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">    ListNode node = dummy;</span><br><span class="line">    <span class="comment">// 索引到链表的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.next = newNode;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用哨兵节点简化链表的删除操作</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">delete</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断删除的节点是否是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head.val == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next.val == value) &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码用两条if语句来处理两个特殊情况</p><ol><li>输入的链表为空</li><li>被删除的节点是原始链表的头节点</li></ol><p>可以用哨兵节点简化代码逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">delete</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode node = dummy;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next.val == value) &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合理应用哨兵节点，就不再需要单独处理这些特殊的输入。</strong></p><h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="#双指针"></a>#双指针</h3><p>按移动方式可以细分成两种不同的方法。</p><ol><li>前后双指针，即一个指针在链表中提前朝着指向下一个节点的指针移动若干步，然后移动第二个指针。<strong>前后双指针的经典应用是查找链表的倒数第k个节点。</strong></li><li>快慢双指针，即两个指针在链表中移动的速度不一样，通常是快的指针朝着指向下一个节点的指针一次移动两步，慢的指针一次只移动一步。<strong>采用这种方法，在一个没有环的链表中，当快的指针到达链表尾节点的时候慢的指针正好指向链表的中间节点。</strong></li></ol><h3 id="21-删除倒数第k个节点"><a href="#21-删除倒数第k个节点" class="headerlink" title="#21 删除倒数第k个节点"></a>#21 删除倒数第k个节点</h3><p>如果给定一个链表，请问如何删除链表中的倒数第k个节点？假设链表中节点的总数为n，那么1&lt;=k&lt;=n。要求只能遍历链表一次。</p><p>例如：</p><p>输入链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，删除倒数第2个节点之后的链表为</p><p>1-&gt;2-&gt;3-&gt;4-&gt;6</p><p>分析：</p><p>如果可以遍历链表两次，那么这个问题就会变得简单。在第1次遍历链表时，可以得出链表的节点总数n。在第2次遍历链表时，可以找出链表的第n-k个节点(即倒数第k+1个节点)，然后通过修改指针，即可删除倒数第k个节点。</p><p>但是题目要求只能遍历链表一次。我们可以定义两个指针，来遍历一次就找到倒数第k+1个节点。第一个指针P1从链表头节点开始先走k步，第二个指针P2保持不动；从第k+1步开始指针P2也从链表的头节点开始和指针P1以相同的速度遍历。由于两个指针的距离始终保持为k，当指针P1指向链表的尾节点时指针P2正好指向倒数第k+1个节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode front = head, back = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        front = front.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为前指针是从head开始，相当于开始时多走了一步</span></span><br><span class="line">    <span class="comment">// 所以判断条件为front != null 而不是 front.next != null</span></span><br><span class="line">    <span class="keyword">while</span> (front != <span class="keyword">null</span>) &#123;</span><br><span class="line">        front = front.next;</span><br><span class="line">        back = back.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    back.next = back.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：遍历列表一边，**时间复杂度为O(n)**。</p><h3 id="22-链表中环的入口节点"><a href="#22-链表中环的入口节点" class="headerlink" title="#22 链表中环的入口节点"></a>#22 链表中环的入口节点</h3><p>如果一个链表中包含环，那么应该如何找出环的入口节点？从链表的头节点开始顺着next指针方向进入环的第1个节点为环的入口节点。</p><p>例如：下图所示的链表中，环的入口节点是3。</p><p><img src="image-20211102122856262.png" alt="image-20211102122856262"></p><p>分析：</p><ol><li><p>第一步是确定一个链表中是否包含环。如果链表中没有环，自然不存在环的入口节点，此时应该返回null。</p><p>可以用两个指针来判断链表中是否有环。指针P1，P2同时从头节点出发，P1一次走一步，P2一次走两步。如果链表中不包含环，P2指针直至抵达链表的尾节点都不会和走得慢的指针相遇。如果链表中包含环，走得快的指针在环里绕了一圈之后将会追上走得慢的指针。因此，<strong>可以根据一快一慢两个指针能否相遇来判断链表中是否包含环。</strong></p></li><li><p>第二步是如何找到环的入口节点，还是可以用两个指针来解决。先定义两个指针P1，P2指向指向链表的头节点。如果链表中的环有n个节点，指针P1先在链表中向前移动n步，然后两个指针以相同的速度向前移动。当指针P2指向环的入口时，指针P1已经围绕环走了一圈又回到了入口节点。</p><p><img src="image-20211102124559505.png" alt="image-20211102124559505"></p></li><li><p>最后一个问题是如何得到环中节点的数目。前面用一快一慢两个指针判断链表中是否存在环时，两个指针相遇的节点一定在环中。可以从这个相遇的节点出发一边继续向前移动一边计数，当再次回到这个节点时就可以得到环中节点的数目。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">getNodeInLoop</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实两个指针不是必须都从头节点出发</span></span><br><span class="line">    <span class="comment">// 只要一快一慢两个指针相遇，即可判断成环</span></span><br><span class="line">    ListNode slow = head.next;</span><br><span class="line">    ListNode fast = slow.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle1</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode inLoop = getNodeInLoop(head);</span><br><span class="line">    <span class="keyword">if</span> (inLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到环中的节点数量n</span></span><br><span class="line">    <span class="keyword">int</span> loopCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ListNode n = inLoop; n.next != inLoop; n = n.next) &#123;</span><br><span class="line">        loopCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针先向前移动n步</span></span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopCount; i++) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针一起移动直至相遇</span></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><ol start="4"><li><p>上述解法需要求出链表的环中节点的数目。但是如果仔细分析，就会发现没必要求出环中节点的数目。慢的指针一次走一步，假设在相遇时慢的指针走了k步。由于快的指针一次走两步，因此在相遇时快的指针一共走了2k步。因此相遇时慢的指针比快的指针多走了k步。另外，两指针相遇时快的指针比慢的指针在环中多转了若干全，也就是说，<strong>快指针多走的步数k一定是环中节点数目的整数倍。满指针走过的步数k也是环中节点数目的整数倍。</strong></p><p>基于此思想，可以让一个指针指向相遇的节点，该指针的位置是之前慢的指针走了k步到达的位置。接着让另一个指针指向链表的头节点，然后两个指针以相同的速率一起移动，<strong>此时两指针相遇，前指针比后指针多走k步，相遇的节点刚好是环的入口节点</strong>。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode inLoop = getNodeInLoop(head);</span><br><span class="line">    <span class="keyword">if</span> (inLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inLoop提前移动了k步，node指向头节点</span></span><br><span class="line">    <span class="comment">// 然后两者以相同速率一起移动</span></span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != inLoop) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        inLoop = inLoop.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-两个链表的第1个重合节点"><a href="#23-两个链表的第1个重合节点" class="headerlink" title="#23 两个链表的第1个重合节点"></a>#23 两个链表的第1个重合节点</h3><p>输入两个单向链表，如何找出它们的第1个重合节点。</p><p>例如：</p><p><img src="image-20211102144127782.png" alt="image-20211102144127782"></p><p>此时两个链表的第1个重合节点的值是4。</p><p>分析：</p><p>很直观地想到暴力法求解。在第1个链表中按顺序遍历每个节点，每遍历到一个节点时，在第2个链表中顺序遍历每个节点，然后进行比较。如果第1个链表的长度为m，第2个链表的长度为n，那么该方法的时间复杂度是O(mn)。蛮力法一般不是最好的解法， 所以进一步分析此种链表的特点以求突破。</p><p>特点1：可以在重合的两个链表的基础上构造一个包含环的链表。</p><p><img src="image-20211102145829302.png" alt="image-20211102145829302"></p><p>此时，环的入口节点即是两个链表的第1个重合节点。可以利用上一题的方法解决。</p><p>特点2：如果两个单向链表有重合节点，那么从某个节点开始这两个链表的next指针都指向同一个节点。</p><p>那么如果我们可以从链表的尾部开始比较，最后一个相同的节点就是我们要找的节点。想要实现从尾部开始比较，可以利用栈这种先进后出的结构。将两个链表分别入栈，然后比较栈顶结点。如果两链表的长度分别为m，n，此种方法的**时间复杂度为O(m+n)<strong>。</strong>空间复杂度也为O(m+n)**。</p><p>上述方法之所以要用栈，是因为我们希望能同时到达两个链表的尾节点。当两个链表的长度不同时，如果从头开始遍历，到达尾节点的时间就不一致。其实解决这个问题有更简单的方法：首先遍历两个链表得到它们的长度，这样就能知道哪个链表比较长，以及长链表比短链表多几个节点。假设长链表比短链表多k个节点。第2次遍历时，指针P1，P2分别指向长短链表的头部。指针P1先在长链表中移动k步，然后两指针同时移动，此时两指针相遇的节点即是第一个公共节点。此种方法的**时间复杂度也是O(m+n)<strong>，</strong>由于不需要用栈，空间复杂度为O(1)**。</p><p><img src="image-20211102151210407.png" alt="image-20211102151210407"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count1 = countList(headA);</span><br><span class="line">    <span class="keyword">int</span> count2 = countList(headB);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> delta = Math.abs(count1 - count2);</span><br><span class="line">    ListNode longer = count1 &gt; count2 ? headA : headB;</span><br><span class="line">    ListNode shorter = count1 &gt; count2 ? headB : headA;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++) &#123;</span><br><span class="line">        longer = longer.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (longer != shorter) &#123;</span><br><span class="line">        shorter = shorter.next;</span><br><span class="line">        longer = longer.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="#24 反转链表"></a>#24 反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>例如：</p><p><img src="image-20211102152116962.png" alt="image-20211102152116962"></p><p>分析：</p><p>在调整节点指针时，除了需要知道节点本身，还要知道它的前一个节点和后一个节点。所以在遍历链表逐个反转每个节点的next指针时需要用到3个指针。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：遍历链表一边，**时间复杂度O(n)<strong>，</strong>空间复杂度O(1)**。</p><h3 id="25-链表中的数字相加"><a href="#25-链表中的数字相加" class="headerlink" title="#25 链表中的数字相加"></a>#25 链表中的数字相加</h3><p>给定两个表示非负整数的单向链表，请问如何实现这两个整数的相加并把它们的和仍然用单向链表表示？链表中的每个节点表示整数十进制的一位，并且头节点对应整数的最高位而尾节点对应整数的个位。</p><p>例如：</p><p><img src="image-20211102154056177.png" alt="image-20211102154056177"></p><p>分析：</p><p>第一反应是，根据链表求出整数，然后将整数相加，最后把结果用链表表示。<strong>这种思路最大的问题是没考虑到整数有可能会溢出</strong>，当链表较长时，可能会超出int甚至long的范围。</p><p>通常两整数相加，都是先算低位再算高位，因为还要考虑进位的问题。所以想到可以把链表反转，然后在逐个节点上实现加法。最后把表示和的链表反转。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    head1 = reverseList(head1);</span><br><span class="line">    head2 = reverseList(head2);</span><br><span class="line">    ListNode reversedHead = addReversed(head1, head2);</span><br><span class="line">    <span class="keyword">return</span> reverseList(reversedHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">addReversed</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode sumNode = dummy;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> || head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (head1 == <span class="keyword">null</span> ? <span class="number">0</span> : head1.val)</span><br><span class="line">            + (head2 == <span class="keyword">null</span> ? <span class="number">0</span> : head2.val) + carry;</span><br><span class="line">        carry = sum &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        sum = sum &gt;= <span class="number">10</span> ? sum - <span class="number">10</span> : sum;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line"></span><br><span class="line">        sumNode.next = newNode;</span><br><span class="line">        sumNode = sumNode.next;</span><br><span class="line"></span><br><span class="line">        head1 = head1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : head1.next;</span><br><span class="line">        head2 = head2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : head2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后的进位</span></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sumNode.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-重排链表"><a href="#26-重排链表" class="headerlink" title="#26 重排链表"></a>#26 重排链表</h3><p>给定一个链表，链表中节点的顺序是L0-&gt;L1-&gt;L2-&gt;…-&gt;Ln-1-&gt;Ln，请问如何重排链表使节点的顺序变成L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;L2-&gt;Ln-2…</p><p>例如：</p><p><img src="image-20211102160234120.png" alt="image-20211102160234120"></p><p>分析：</p><p>观察输入链表和输出链表之间的关系，发现重排链表实际上是把链表分成前后两半。在示例链表中，前半段包含1、2、3三个节点，后半段包含4、5、6三个节点。然后把后半段链表反转，再与前半段链表拼接。</p><p>首先需要解决的问题是如何把一个链表分成两半，即找到链表的中间节点。可以一快一慢两个指针实现。两个指针同时从链表的头节点出发，快的指针一次走两步，慢的指针一次走一步，当快的指针走到链表的尾节点时，慢的指针刚好走到链表的中间节点。要注意：链表的节点总数可能是奇数也可能是偶数。当链表的节点总数是奇数时，要确保链表的前半段比后半段多一个节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode fast = dummy;</span><br><span class="line">    ListNode slow = dummy;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode temp = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    link(head, reverseList(temp), dummy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(ListNode node1, ListNode node2, ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = head;</span><br><span class="line">    <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = node1.next;</span><br><span class="line"></span><br><span class="line">        prev.next = node1;</span><br><span class="line">        node1.next = node2;</span><br><span class="line">        prev = node2;</span><br><span class="line"></span><br><span class="line">        node1 = temp;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.next = node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，当变量fast指向尾节点时，变量slow指向前半段的最后一个节点。</p><h3 id="27-回文链表"><a href="#27-回文链表" class="headerlink" title="#27 回文链表"></a>#27 回文链表</h3><p>如何判断一个链表是不是回文？要求解法的时间复杂度是O(n)，并且不得使用超过O(1)的辅助空间。</p><p>例如：</p><p><img src="image-20211107151640955.png" alt="image-20211107151640955"></p><p>分析：</p><p>如果不考虑辅助空间的限制，直观的解法是创建一个新的链表，链表中的节点顺序和输入链表的节点顺序正好相反。二者比较即可判断是否是回文链表，此时需要O(n)的辅助空间。</p><p>分析回文链表的特点以找出更好的解法。回文链表的一个特性是对称性，也就是说，如果把链表分为前后两半，那么前半段链表反转之后与后半段链表是相同的。因此可以想到把链表分成前后两半，然后把其中一半反转。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode secondHalf = slow.next;</span><br><span class="line">    <span class="comment">// 如果fast.next != null，说明链表中节点个数为奇数</span></span><br><span class="line">    <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 跳过中间节点</span></span><br><span class="line">        secondHalf = slow.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> equals(secondHalf, reverseList(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.val != head2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head1 = head1.next;</span><br><span class="line">        head2 = head2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head1 == <span class="keyword">null</span> &amp;&amp; head2 == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，不管链表的节点总数是奇数还是偶数，变量slow都指向链表前半段的最后一个节点。</p><h3 id="双向链表和循环链表"><a href="#双向链表和循环链表" class="headerlink" title="双向链表和循环链表"></a>双向链表和循环链表</h3><p>由于单向链表只能从头节点开始遍历到尾节点，遍历的顺序受到限制，在很多场景下使用起来不太方便，因此双向链表应运而生。双向链表在单向链表节点的基础上增加了指向前一个节点的指针，这样一来，既可从前往后遍历，也可以从后向前遍历。</p><p>如果把链表尾节点的下一个节点的指针指向链表的头节点，那么此时链表就变成一个循环链表。循环链表既可以是单向链表，也可以是双向链表。</p><h3 id="28-展平多级双向链表"><a href="#28-展平多级双向链表" class="headerlink" title="#28 展平多级双向链表"></a>#28 展平多级双向链表</h3><p>在一个多级双向链表中，节点除了有两个指针分别指向前后两个节点，还有一个指针指向它的子链表，并且子链表也是一个双向链表，它的节点也有指向子链表的指针。请将这样的多级双向链表展成普通的双向链表，即所有节点都没有子链表。</p><p>例如：</p><p><img src="image-20211107160039114.png" alt="image-20211107160039114"></p><p>分析：</p><p>展平的规则是一个节点的子链表展平之后将插入该节点和它的下一个节点之间。由于子链表中的节点也有可能有子链表，<strong>因此这里的链表是一个递归的结构</strong>。在展平子链表时，如果它也有自己的子链表，那么它嵌套的子链表也要一起展平。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    flattenGetTail(head);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">flattenGetTail</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node node = head;</span><br><span class="line">    Node tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        <span class="keyword">if</span> (node.child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node child = node.child;</span><br><span class="line">            Node childTail = flattenGetTail(node.child);</span><br><span class="line"></span><br><span class="line">            node.child = <span class="keyword">null</span>;</span><br><span class="line">            node.next = child;</span><br><span class="line">            child.prev = node;</span><br><span class="line">            childTail.next = next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                next.prev = childTail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tail = childTail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，递归函数flattenGetTail在展平以head为头节点的链表之后返回链表的尾节点。在该函数中需要逐一扫描链表中的节点。如果一个节点node有子链表，由于子链表也可能有嵌套的子链表，因此先递归调用flattenGetTail函数展平子链表，子链表展平之后头节点时child，尾节点是childTail。最后将展平的子链表插入节点node和它的下一个节点next之间，即把展平的子链表头节点child插入节点node之后，并将尾节点childTail插入节点next之前。</p><p>这种解法每个节点都会遍历一次，如果链表总共有n个节点，那么时间复杂度时O(n)。函数flattenGetTail的递归调用次数取决于链表嵌套的次数，因此，如果链表的层数为k，那么该节点的空间复杂度是O(k)。</p><h3 id="29-排序的循环链表"><a href="#29-排序的循环链表" class="headerlink" title="#29 排序的循环链表"></a>#29 排序的循环链表</h3><p>在一个循环链表中节点的值递增排序，请设计一个算法在该循环链表中插入节点，并保证插入节点之后循环链表仍然是排序的。</p><p>例如：</p><p><img src="image-20211107163817220.png" alt="image-20211107163817220"></p><p>分析：</p><p>再插入节点4时，新的节点位于3，5节点之间。为了使插入新节点后循环链表仍然是排序的，新节点的前一个节点的值应该比新节点的值小，后一个节点的值应该比新节点大。</p><p>但是特殊情况需要特殊处理。</p><p>特殊情况1：如果新节点是链表中最大或最小的节点，新的节点将被插入到最大值和最小值之间。</p><p>特殊情况2：如果链表中的节点数小于2，那么应该有两种可能。第1种可能是开始的时候链表是空的，一个节点都没有，此时插入一个新的节点，该节点成为循环链表中唯一的节点，那么next指针指向节点自己。第2种可能是开始的时候链表中只有一个节点，插入一个新的节点之后，两个节点的next指针互相指向对方。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">insert</span> <span class="params">(Node head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(insertVal);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        head.next = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == head) &#123;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.next = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertCore(head, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertCore</span><span class="params">(Node head, Node node)</span> </span>&#123;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = head.next;</span><br><span class="line">    Node biggest = head;</span><br><span class="line">    <span class="comment">// 如果是因为不满足next != head退出，表示新节点是链表中最大或最小的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!(cur.val &lt;= node.val &amp;&amp; next.val &gt;= node.val &amp;&amp; next != head)) &#123;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; biggest.val) &#123;</span><br><span class="line">            biggest = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur.val &lt;= node.val &amp;&amp; next.val &gt;= node.val) &#123;</span><br><span class="line">        cur.next = node;</span><br><span class="line">        node.next = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.next = biggest.next;</span><br><span class="line">        biggest.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="30-插入、删除和随机访问都是O-1-的容器"><a href="#30-插入、删除和随机访问都是O-1-的容器" class="headerlink" title="#30 插入、删除和随机访问都是O(1)的容器"></a>#30 插入、删除和随机访问都是O(1)的容器</h3><p>设计一个数据结构，使如下3个操作的时间复杂度都是O(1)。</p><ul><li>insert(value)：如果数据集种不包含一个数值，则把它添加到数据集中。</li><li>remove(value)：如果数据集中包含一个数值，则把它删除。</li><li>getRandom()：随机返回数据集中的一个数值，要求数据集中每个数字被返回的概率都相同。</li></ul><p>分析：</p><p>由于要求插入和删除的时间复杂度都是O(1)，因此需要用哈希表来实现。</p><p>如果只用哈希表，则不能等概率地返回其中的每个数值。如果数值是保存在数组中的，那么很容易实现等概率地返回其中的每个数值。假设数组的长度是n，那么等概率生成从0到n-1的一个数字。如果生成的随机数是i，则返回数组中下标为i的数值。由此可以发现，需要结合哈希表和数组来设计这个数据容器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; numToLocation;</span><br><span class="line">    ArrayList&lt;Integer&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        numToLocation = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numToLocation.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        numToLocation.put(val, nums.size());</span><br><span class="line">        nums.add(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!numToLocation.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用数组中最后一个元素覆盖要删除的元素，并修改哈希表中对应位置的键值对</span></span><br><span class="line">        <span class="keyword">int</span> location = numToLocation.get(val);</span><br><span class="line">        numToLocation.put(nums.get(nums.size() - <span class="number">1</span>), location);</span><br><span class="line">        numToLocation.remove(val);</span><br><span class="line">        nums.set(location, nums.get(nums.size() - <span class="number">1</span>));</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> r = random.nextInt(nums.size());</span><br><span class="line">        <span class="keyword">return</span> nums.get(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31-最近最少使用缓存"><a href="#31-最近最少使用缓存" class="headerlink" title="#31 最近最少使用缓存"></a>#31 最近最少使用缓存</h3><p>设计实现一个最近最少使用(Least Recently Used, LRU)缓存，要求如下两个操作的时间复杂度都是O(1)。</p><ul><li>get(key)：如果缓存中存在键key，则返回它对应的值，否则返回-1</li><li>put(key,value)：如果缓存中之前包含key，则它的值设为value；否则添加键key及对应的值value。在添加一个键时，如果缓存容量已经满了，则在添加新键之前删除最近最少使用的键(缓存中最长时间没有被使用过的元素)。</li></ul><p>分析：</p><p>哈希表的get和put操作的时间复杂度都是O(1)，但普通的哈希表无法找出最近最少使用的键，因此需要在哈希表的基础上进行改进。</p><p>由于需要知道缓存中最近最少使用的元素，因此可以把缓存中的元素存入链表中。每次访问一个元素(无论是通过get还是put操作)，该元素都被移到链表的尾部。这样，<strong>位于链表头部的元素就是最近最少使用的。</strong></p><p>如果这个链表是单向链表，那么找到一个节点的前一个节点需要从链表的头节点开始遍历链表，需要O(n)的时间。因此可以用双向链表来存储缓存中的元素。在双向链表中查找一个结点的前一个节点，只需要顺着prev指针向前走一步，时间复杂度为O(1)。</p><p>首先定义双向链表中的节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    <span class="keyword">public</span> ListNode prev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义最近最少使用缓存的数据结构。缓存中包含一个哈希表，哈希表的键就是缓存的键，哈希表的值是双向链表中的节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line">    <span class="keyword">private</span> ListNode tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ListNode&gt; map;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个容量为cap的缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line"></span><br><span class="line">        capacity = cap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于在双向链表中添加和删除节点，上述代码创建了两个哨兵节点，即head和tail，他们分别位于双向链表的头部和尾部。函数put所添加的节点将位于这两个节点之间。</p><p>接下来实现get，put及辅助函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    ListNode node = map.get(key);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    moveToTail(node, node.value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">        moveToTail(map.get(key), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">            ListNode toBeDelete = head.next;</span><br><span class="line">            deleteNode(toBeDelete);</span><br><span class="line"></span><br><span class="line">            map.remove(toBeDelete.key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(key, value);</span><br><span class="line">        insertToTail(node);</span><br><span class="line"></span><br><span class="line">        map.put(key, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToTail</span><span class="params">(ListNode node, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    deleteNode(node);</span><br><span class="line"></span><br><span class="line">    node.value = newValue;</span><br><span class="line">    insertToTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.prev.next = node.next;</span><br><span class="line">    node.next.prev = node.prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertToTail</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    tail.prev.next = node;</span><br><span class="line">    node.prev = tail.prev;</span><br><span class="line">    node.next = tail;</span><br><span class="line">    tail.prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-有效的变位词"><a href="#32-有效的变位词" class="headerlink" title="#32 有效的变位词"></a>#32 有效的变位词</h3><p>给定两个字符串s和t，请判断它们是不是一组变位词。在一组变位词中，他们中的字符及每个字符出现的次数都相同， 但字符的顺序不能相同。</p><p>例如：</p><p>“anagram”和”nagaram”就是一组变位词。</p><p>分析：</p><p>由于变位词和字符出现的次数相关，因此可以用一个哈希表来存储每个字符出现的次数。哈希表的键是字符，而值是对应字符出现的次数。<strong>如果哈希表的键取值范围是固定的，而且范围不是很大，则可以用数组来模拟哈希表。</strong></p><p>如果只考虑英文字母，则用数组来模拟哈希表：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram1</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 长度不同一定不是同位词</span></span><br><span class="line">    <span class="keyword">if</span> (str1.length() != str2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符顺序相同也不是同位词</span></span><br><span class="line">    <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str1.toCharArray()) &#123;</span><br><span class="line">        counts[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str2.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counts[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入字符串的长度为n，上述解法的**时间复杂度为O(n)<strong>。不管字符串的长度如何，辅助数组的长度都是固定的，因此</strong>空间复杂度是O(1)**。</p><p>如果考虑用字符串表示中文或其他非英语语言，那么ASCII码字符集是不够的。因为一个ASCII码字符的长度为8位，所以ASCII码字符集能包含256个不同的字符，中文及很多语言的字符集都远远超过这个数字。为了包含更多的字符，需要其他编码的字符集，目前使用最多的是Unicode编码。一个Unicode的字符的长度为16位，这样就能表示65536个字符。此种情况下，如果还和之前一样，创建一个长度为65536的数组，似乎会浪费内存。所以此时就可以创建一个类型为HashMap的真正的哈希表。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram2</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1.length() != str2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str1.toCharArray()) &#123;</span><br><span class="line">        counts.put(ch, counts.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str2.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counts.containsKey(ch) || counts.get(ch) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counts.put(ch, counts.get(ch) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的**时间复杂度仍然是O(n)<strong>。但是如果输入的字符串中不同字符的数目越多，HashMap就需要越多的空间。因此，可以认为使用HashMap的</strong>空间复杂度是O(n)**。</p><h3 id="33-变位词组"><a href="#33-变位词组" class="headerlink" title="#33 变位词组"></a>#33 变位词组</h3><p>给定一组单词，请将他们按照变位词分组。假设单词中只包含英文小写字母。</p><p>例如：输入一组单词[“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]，这组单词可以分成三组，分别是[“eat”, “tea”, “ate”]、[“tan”, “nat”]、[“bat”]。</p><p>分析：</p><p>解决这个问题，就需要找出一组变位词共同的特性，然后依据此特性把它们分到一组。这里主要介绍两种方法：</p><ol><li><p>将单词映射到数字。把每个英文小写字母映射到一个质数，如把字母’a’映射到数字2，字母’b’映射到数字3，以此类推。字母’z’映射到第26个质数101。每给出一个单词，就把单词中的所有字母对应的数字相乘，于是每个单词都可以算出一个数字。例如，单词’eat’可以映射到数字1562(11*2*71)。’</p><p>如果两个单词护卫变位词，那么它们中每个字母出现的次数都对应相同，由于乘法满足交换律，因此上述算法把一组变位词映射到同一个数值。由于每个字母都是映射到一个质数，因此不互为变位词的两个单词一定会映射到不同的数字。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams1(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">int</span> hash[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Map&lt;Long, List&lt;String&gt;&gt; groups = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="keyword">long</span> wordHash = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            wordHash *= hash[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        groups.putIfAbsent(wordHash, <span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">        groups.get(wordHash).add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(groups.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入n个单词，平均每个单词有m个字母，那么该算法的时间复杂度是O(mn)。</p><p>该算法有一个潜在的问题：<strong>由于把单词映射到数字用到了乘法，因此当单词非常长时，乘法就有可能溢出</strong>。</p><ol start="2"><li>将单词的字母排序。互为变位词的单词排序后会得到相同的字符串。因此可以定义一个哈希表，哈希表的键是把单词字母排序得到的字符串，而值是一组变位词。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams2(String[] strs) &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; groups = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        Arrays.sort(charArray);</span><br><span class="line">        String sorted = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">        groups.putIfAbsent(sorted, <span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">        groups.get(sorted).add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(groups.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每个单词平均有m个字母，排序一个单词需要O(mlogm)的时间，假设总共有n个单词，该算法总的时间复杂度是<strong>O(nmlogm)<strong>。</strong>虽然该方法的时间效率不如前一种方法，但是该方法不用担心乘法可能带来的溢出问题。</strong></p><h3 id="34-外星语言是否排序"><a href="#34-外星语言是否排序" class="headerlink" title="#34 外星语言是否排序"></a>#34 外星语言是否排序</h3><p>y偶一门外星语言，它的子目标刚好包含所有的英文小写字母，只是字母表的顺序不同。给定一组单词和字母表顺序，请判断这些单词是否按照字母表的顺序排序。</p><p>例如：输入一组单词[“offer”, “is”, “comming”]，以及字母表顺序”zyxwvutsrqponmlkjihgfedcba”，由于字母’o’在字母表中位于’i’的前面，因此单词”offer”排在”is”的前面；同理，单词”is”排在”comming”的前面。因此，这一组单词是按照字母表顺序排序的，应该输出true。</p><p>分析：</p><p>为了方便查找每个字母在字母表中的顺序，可以创建一个哈希表，哈希表的键为字母表的每个字母，而值为字母在字母表中的顺序。字母表中字母的数目是固定的，一共26个。所以可以用数组来模拟哈希表。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlienSorted</span><span class="params">(String[] words, String order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] orderArray = <span class="keyword">new</span> <span class="keyword">int</span>[order.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.length(); i++) &#123;</span><br><span class="line">            orderArray[order.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSorted(words[i], words[i + <span class="number">1</span>], orderArray)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(String word1, String word2, <span class="keyword">int</span>[] order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; word1.length() &amp;&amp; i &lt; word2.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = word1.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> ch2 = word2.charAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (order[ch1 - <span class="string">&#x27;a&#x27;</span>] &lt; order[ch2 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (order[ch1 - <span class="string">&#x27;a&#x27;</span>] &gt; order[ch2 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i == word1.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入n个单词，每个单词的平均长度为m，那么该算法的**时间复杂度是O(mn)<strong>，</strong>空间复杂度是O(1)**。</p><h3 id="35-最小时间差"><a href="#35-最小时间差" class="headerlink" title="#35 最小时间差"></a>#35 最小时间差</h3><p>给定一组范围在00:00至23:59的时间，求任意两个时间之间的最小时间差。</p><p>例如：输入时间数组[“23:50”, “23:59”, “00:00”]，”23:59”和”00:00”之间只有1分钟的间隔，是最小的时间差。</p><p>分析：</p><p>最直观的解法是求出任意两个时间的间隔，然后得出最小的是价差。如果输入n个时间，这种蛮力法需要O(n^2)的时间。</p><p>上述解法的一个优化是把n个时间排序，排序后只需要计算两相邻时间之间的间隔，这样就只需要计算O(n)个时间差。由于对n个时间进行排序通常需要O(nlogn)的时间，因此这种优化算法的总体时间复杂度是O(nlogn)。</p><p>一个特殊情况需要考虑：”00:00”也有可能是第二天的00:00，所以在计算时要考虑到两种情况: </p><ol><li>最小时间间隔出现在同一天</li><li>最小时间间隔需要和第二天00:00比较</li></ol><p>一天有24小时，即1440分钟。如果用一个长度为1440的数组表示一天的时间，那么数组的下标为0的位置对应时间00:00，下表为1的位置对应时间00:01。数组中的每个元素是true或false标识。由于数组的下标对应的是时间，因此两个时间之间的时间差就是他们在数组中对应的下标之差。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 列表长度大于1440，则一定出现了两个相同时间，所以最小时间间隔为0</span></span><br><span class="line">    <span class="keyword">if</span> (timePoints.size() &gt; <span class="number">1440</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> minutesFlags[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1440</span>];</span><br><span class="line">    <span class="keyword">for</span> (String time : timePoints) &#123;</span><br><span class="line">        String t[] = time.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> min = Integer.parseInt(t[<span class="number">0</span>]) * <span class="number">60</span> + Integer.parseInt(t[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 如果为true，则列表中出现了两个相同时间，即最小时间间隔为0</span></span><br><span class="line">        <span class="keyword">if</span> (minutesFlags[min]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        minutesFlags[min] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(minutesFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">boolean</span> minuteFlags[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minDiff = minuteFlags.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> first = minuteFlags.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minuteFlags.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minuteFlags[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                minDiff = Math.min(i - prev, minDiff);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prev = i;</span><br><span class="line">            first = Math.min(i, first);</span><br><span class="line">            last = Math.max(i, last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minDiff = Math.min(minuteFlags.length - last + first, minDiff);</span><br><span class="line">    <span class="keyword">return</span> minDiff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设输入时间的数目是n。上述代码中有两个for循环，主函数for的时间复杂度是O(n)；辅助函数helper的for循环执行次数为minuteFlags的长度1440，所以时间复杂度为O(1)。因此**总时间复杂度为O(n)<strong>。该方法需要创建一个长度为常数的辅助数组，</strong>空间复杂度为O(1)**。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="Java中stack的常用操作"><a href="#Java中stack的常用操作" class="headerlink" title="# Java中stack的常用操作"></a># Java中stack的常用操作</h3><table><thead><tr><th>序号</th><th>函数</th><th>函数功能</th></tr></thead><tbody><tr><td>1</td><td>push(e)</td><td>元素e入栈</td></tr><tr><td>2</td><td>pop</td><td>位于栈顶的元素出栈，并返回该元素</td></tr><tr><td>3</td><td>peek</td><td>返回位于栈顶的元素，该元素不出栈</td></tr></tbody></table><h3 id="36-后缀表达式"><a href="#36-后缀表达式" class="headerlink" title="#36 后缀表达式"></a>#36 后缀表达式</h3><p>后缀表达式是一种算术表达式，它的操作符在操作数的后面。输入一个用字符串数组表示的后缀表达式，请输出该后缀表达式的计算结果。假设输入的一定是有效的后缀表达式。</p><p>例如：后缀表达式[“2”, “1”, “3”, “*”, “+”]对应的算术表达式是”2+1*3”，因此输出它的计算结果5。</p><p>分析：</p><p>先将操作数入栈，遇到操作符时从栈中取出两个操作数进行运算，运算结果再入栈。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    <span class="keyword">int</span> num1 = stack.pop();</span><br><span class="line">                    <span class="keyword">int</span> num2 = stack.pop();</span><br><span class="line">                    <span class="comment">// 注意: 先取出来的是第二个操作数</span></span><br><span class="line">                    stack.push(calculate(num2, num1, token));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    stack.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, String operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 + num2;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 - num2;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 * num2;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 / num2;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在进行减法(除法)运算时，注意先出栈的是减数(除数)，后出栈的是被减数(被除数)。</strong></p><p>如果输入数组的长度是n，那么对其中的每个字符串都有一次push操作：如果是操作符，那么还需要进行数学计算和两次pop操作。由于每个push操作、pop操作和数学计算都是O(1)，因此总体**时间复杂度是O(n)<strong>。由于栈中可能有O(n)个操作数，因此</strong>空间复杂度也是O(n)**。</p><h3 id="37-小行星碰撞"><a href="#37-小行星碰撞" class="headerlink" title="#37 小行星碰撞"></a>#37 小行星碰撞</h3><p>输入一个表示小行星的数组，数组中每个数字的绝对值表示行星的大小，数字的正负号表示小行星运动的方向，正号表示向右飞行，负号表示向左飞行。如果两颗小行星相撞，那么体积较小的小行星将会爆炸最终消失，体积较大的小行星不受影响。如果相撞的两颗小行星大小形同，那么他们都会爆炸消失。飞行方向相同的小行星永远不会相撞。求最终剩下的小行星。</p><p>例如：有6颗小行星[4,5,-6,4,8,5]，它们相撞之后最终剩下3颗小行星[-6,4,8]。</p><p>分析：</p><p>根据题设总结小行星相撞的规律。如果一颗小行星向右飞行，可以将它入栈。如果一颗小行星向左飞行，而位于栈顶的小行星向右飞行，那么它将与位于栈顶的小行星相撞。如果位于栈顶的小行星较小，那么它将爆炸消失(出栈)。然后判断它是否将与下一刻位于栈顶的小行星相撞。如果小行星与栈中所有小行星相撞之后仍然没有爆炸消失，那么将它入栈。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] asteroidCollision(<span class="keyword">int</span>[] asteroids) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> as : asteroids) &#123;</span><br><span class="line">        <span class="comment">// 栈中有向右飞行的小行星，当前小行星向左飞行，且体积更大</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() &gt; <span class="number">0</span> &amp;&amp; stack.peek() &lt; -as) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈中有向右飞行的小行星，与当前向左飞行的小行星体积相等</span></span><br><span class="line">        <span class="keyword">if</span> (!stack.empty() &amp;&amp; as &lt; <span class="number">0</span> &amp;&amp; stack.peek() == -as) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (as &gt; <span class="number">0</span> || stack.empty() || stack.peek() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            stack.push(as);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，每颗小行星只可能入栈、出栈一次，因此**时间复杂度是O(n)，空间复杂度也是O(n)**。</p><h3 id="38-每日温度"><a href="#38-每日温度" class="headerlink" title="#38 每日温度"></a>#38 每日温度</h3><p>输入一个数组，它的每个数字是某天的温度。请计算每天需要等几天才会出现更高的温度。</p><p>例如：输入数组[35,31,33,36,34]，那么输出为[3,1,1,0,0]。由于第1天的温度是35℃，要等3天才会出现更高的温度36℃，因此对应的输出为3。第4天的温度为36℃，后面没有更高的温度，它对应的输出是0。其他的以此类推。</p><p>分析：</p><p>用一个栈保存每天的温度在数组中的下标。每次从数组中读取一个温度，然后将其与栈中保存的温度(根据下标可以得到温度)进行比较。如果当前温度比位于栈顶的温度高，那么就能知道位于栈顶那一天需要等待几天才会出现更高的温度。然后出栈1次，将当前温度与下一个位于栈顶的温度进行比较。如果栈中已经没有比当前温度低的温度，则将当前温度在数组中的下标入栈。</p><table><thead><tr><th>步骤</th><th>温度/℃</th><th>栈</th><th>等待天数</th><th>注释</th></tr></thead><tbody><tr><td>1</td><td>35</td><td>[0]</td><td>[0,0,0,0,0]</td><td>0入栈</td></tr><tr><td>2</td><td>31</td><td>[0,1]</td><td>[0,0,0,0,0]</td><td>比较31，35，1入栈</td></tr><tr><td>3</td><td>33</td><td>[0,2]</td><td>[0,1,0,0,0]</td><td>比较33, 31, 1出栈; 比较33, 35, 2入栈</td></tr><tr><td>4</td><td>36</td><td>[3]</td><td>[3,1,1,0,0]</td><td>比较36, 33, 2出栈; 比较36, 35, 1出栈; 3入栈</td></tr><tr><td>5</td><td>34</td><td>[3,4]</td><td>[3,1,1,0,0]</td><td>比较34, 36, 4入栈</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[temperatures.length];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = stack.pop();</span><br><span class="line">            result[prev] = i - prev;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设数组的长度是n，虽然有一个嵌套的二重循环，但它的**时间复杂度是O(n)<strong>，这是因为数组中每个温度入栈、出栈各1次。这种解法的</strong>空间复杂度也是O(n)**。</p><h3 id="39-直方图最大矩形面积"><a href="#39-直方图最大矩形面积" class="headerlink" title="#39 直方图最大矩形面积"></a>#39 直方图最大矩形面积</h3><p>直方图是由排列在同一基线上的相邻柱子组成的图形。输入一个由非负数组成的数组，数组中的数字是直方图中柱子的高。求直方图中最大矩形的面积。假设直方图中柱子的宽都为1。</p><p>例如：输入数组[3,2,5,4,6,1,4,2]，该直方图中最大矩形面积为12。(已4为顶, 宽为3的矩形)</p><p>分析：</p><p>如果直方图中一个矩形的下标从i开始，到j结束，那么这两根柱子之间的矩形(含两端的柱子)的宽是j-i+1。矩形的高是两根柱子之间所有主子最矮的高度。</p><p>这里介绍三种解法：</p><ol><li>蛮力法。如果能逐一找出直方图中所有的矩形并比较他们的面积，就能得到最大矩形面积。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea1</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = heights[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; heights.length; j++) &#123;</span><br><span class="line">            min = Math.min(min, heights[j]);</span><br><span class="line">            <span class="keyword">int</span> area = min * (j- i + <span class="number">1</span>);</span><br><span class="line">            maxArea = Math.max(maxArea, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入数组的长度为n，直方图中总共有O(n^2)个矩形，则计算每个矩形的面积需要O(1)的时间，这种解法的**时间复杂度是O(n^2)<strong>。此解法没用到额外的内存开销，因此</strong>空间复杂度是O(1)**。</p><ol start="2"><li>分治法。仔细观察直方图矩阵可以发现，直方图中最矮的柱子在数组中的下标是5，它的高度是1。这个直方图的最大矩形有3种可能。<strong>第1种</strong>是矩形通过这根最矮的柱子。通过最矮的柱子的最大举行的高为1，宽为7。<strong>第2种</strong>是矩形的起始柱子和终止柱子都在最矮的柱子左侧，也就是从下标为0的柱子到下标为4的柱子的直方图的最大矩形。<strong>第3种</strong>是矩形的起始柱子和终止柱子都在最矮的柱子右侧，也就是从下标为6的柱子到下标为7的柱子的直方图的最大矩形。第2种和第3种从本质上来说和求整个直方图的最大矩形面积是同一个问题，可以调用递归函数解决。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea2</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(heights, <span class="number">0</span>, heights.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果相等，代表只有一列</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">1</span> == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> heights[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minIndex = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heights[i] &lt; heights[minIndex]) &#123;</span><br><span class="line">            minIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为预设的范围不包括end，所以这里end-start不需要加1</span></span><br><span class="line">    <span class="keyword">int</span> area = (end - start) * heights[minIndex];</span><br><span class="line">    <span class="keyword">int</span> left = helper(heights, start, minIndex);</span><br><span class="line">    <span class="keyword">int</span> right = helper(heights, minIndex + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    area = Math.max(area, left);</span><br><span class="line">    <span class="keyword">return</span> Math.max(area, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>单调栈法</p><p>非常高效、巧妙的解法。这种解法用一个栈保存直方图的柱子，并且栈中的柱子高度是递增排序的。为了方便计算矩形的宽度，栈中保存的是柱子在数组中的下标，可以根据下标得到柱子的高度。</p><p>这种解法的基本思想是确保保存在栈中的直方图的柱子的高度是递增排序的。假设从左到右逐一扫描数组中的每根柱子，如果当前柱子的高度大于位于栈顶的柱子的高度，那么将该柱子的下标入栈；否则，将位于栈顶的下标出栈，并且计算以位于栈顶的柱子为顶的最大矩形的面积。</p><p>一番操作过后，以每个柱子为顶的最大直方图面积都会被计算。</p><p><strong>细节：如果某下标为i的柱子左侧没有柱子，这意味着它的左侧所有的柱子都比它高。因此，可以想象在下标为-1的位置有一根比它矮的柱子。</strong></p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea3</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">            <span class="comment">// 因为不包括第i根柱子，所以要-1</span></span><br><span class="line">            <span class="keyword">int</span> width = i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            maxArea = Math.max(maxArea, height * width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">        <span class="keyword">int</span> width = heights.length - stack.peek() - <span class="number">1</span>;</span><br><span class="line">        maxArea = Math.max(maxArea, height * width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同方法二，**时间复杂度和空间复杂度都为O(n)**。</p><h3 id="40-矩阵中国的最大矩形"><a href="#40-矩阵中国的最大矩形" class="headerlink" title="#40 矩阵中国的最大矩形"></a>#40 矩阵中国的最大矩形</h3><p>请在一个由0、1组成的矩阵中找出最大只包含1的矩形并输出它的面积。</p><p>例如：</p><p>[[1,0,1,0,0],</p><p>[0,0,1,1,1],</p><p>[1,1,1,1,1],</p><p>[1,0,0,1,0]]</p><p>此矩阵中最大的只包含1的矩阵面积为6。</p><p>分析：</p><p>可以把一个有n行的矩阵转换成n个直方图，进而转换成求直方图最大矩形面积的问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    heights[i] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    heights[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxArea = Math.max(maxArea, largestRectangleArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">            <span class="comment">// 因为不包括第i根柱子，所以要-1</span></span><br><span class="line">            <span class="keyword">int</span> width = i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            maxArea = Math.max(maxArea, height * width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">        <span class="keyword">int</span> width = heights.length - stack.peek() - <span class="number">1</span>;</span><br><span class="line">        maxArea = Math.max(maxArea, height * width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设输入矩阵的大小为mxn，该矩阵可以转换成m个直方图，如果采用单调栈法，那么求每个直方图的最大矩形面积需要O(n)的时间，因此这种解法的**时间复杂度为O(mn)<strong>。使用单调栈法计算直方图中最大矩阵的面积需要O(n)的空间，同时要一个长度为n的数组heights，用于记录直方图中主子的高度，因此这种解法的</strong>空间复杂度是O(n)**。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="Java中Queue的常用操作"><a href="#Java中Queue的常用操作" class="headerlink" title="#Java中Queue的常用操作"></a>#Java中Queue的常用操作</h3><table><thead><tr><th>操作</th><th>抛异常</th><th>不抛异常</th></tr></thead><tbody><tr><td>插入元素</td><td>add(e)</td><td>offer(e)</td></tr><tr><td>删除元素</td><td>remove</td><td>poll</td></tr><tr><td>返回最前面的元素</td><td>element</td><td>peek</td></tr></tbody></table><p>在Java中实现了接口Queue的常用类型有LinkedList, ArrayDeque和PriorityQueue等。但PriorityQueue并不是真正的队列。</p><h3 id="41-滑动窗口的平均值"><a href="#41-滑动窗口的平均值" class="headerlink" title="#41 滑动窗口的平均值"></a>#41 滑动窗口的平均值</h3><p>请实现如下类型MovingAverage，计算滑动窗口中所有数字的平均值，该类型构造函数的参数确定滑动窗口的大小，每次调用成员函数next时都会在滑动窗口中添加一个整数，并返回滑动窗口中所有数字的平均值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><p>滑动窗口满足先进先出的特点，因此可以用队列来实现。记录当前窗口的所有数字之和(用sum表示)，那么插入一个新的数字v1之后，窗口中的所有数字之和就是sum+v1。如果此时窗口的大小超出了限制，还需要删除一个数字v2，那么窗口中的所有数字之和是sum+v1-v2。因此，最多只需要一次假发和一次减法就能求出窗口中所有数字之和，**时间复杂度为O(1)**。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        nums = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        nums.offer(val);</span><br><span class="line">        sum += val;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &gt; capacity) &#123;</span><br><span class="line">            sum -= nums.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) sum / nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="42-最近请求次数"><a href="#42-最近请求次数" class="headerlink" title="#42 最近请求次数"></a>#42 最近请求次数</h3><p>请设计如下实现类型RecentCounter，它是统计过去3000ms内的请求次数的计数器。该类型的构造函数RecentCounter初始化计数器，请求数初始化为0; 函数ping(int t)在时间t添加一个新请求(t表示以毫秒为单位的时间)，并返回过去3000ms内(时间范围为[t-3000,t])发生的所有请求数。假设每次调用函数ping的参数t都比之前调用的参数值大。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><p>最近请求次数，同样符合先进先出原则，可以用队列来实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; times;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> windowSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.times = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.windowSize = <span class="number">3000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        times.offer(t);</span><br><span class="line">        <span class="keyword">while</span> (times.peek() &lt; t - windowSize) &#123;</span><br><span class="line">            times.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> times.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设计数器的时间窗口大小是w毫秒，其中记录的时间的递增的，那么时间窗口中记录的时间的数目是O(w)，因此**空间复杂度是O(w)<strong>。每当收到一个新的请求ping时，由于可能需要删除O(w)个已经滑出时间窗口的请求，因此</strong>时间复杂度也是O(w)**。由于此题中w是个常数，因此可以认为时间复杂度和空间复杂度都是O(1)。</p><h3 id="二叉树的广度优先搜索"><a href="#二叉树的广度优先搜索" class="headerlink" title="#二叉树的广度优先搜索"></a>#二叉树的广度优先搜索</h3><p>通常基于队列来实现二叉树的广度优先搜索。从二叉树的根节点开始，先把根节点放入一个队列之中，然后每次从队列中取出一个节点遍历。如果该节点有左右子节点，则分别将他们添加到队列当中。重复此过程直到所有节点都遍历完位置，此时队列为空。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        result.add(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设一棵二叉树有n个节点。由于逐层遍历每个节点，因此上述代码的时间复杂度时O(n)。如果把父节点已经遍历到但自身尚未到达的节点存储在队列之中，那么最多需要存储一层的节点。在一棵满的二叉树中，最下面一层的节点数最多，最多可能有(n+1)/2个节点，因此二叉树广度优先搜索的空间复杂度时O(n)。</p><h3 id="43-在完全二叉树中添加节点"><a href="#43-在完全二叉树中添加节点" class="headerlink" title="#43 在完全二叉树中添加节点"></a>#43 在完全二叉树中添加节点</h3><p>在完全二叉树中，除最后一层之外其他层的节点都是满的。最后一层的节点可能不满，该层所有的节点尽可能向左边靠拢。</p><p>实现数据结构CBTInserter有如下三种方法。</p><ul><li>构造函数CBTiNSERTER(TreeNode root)，用一棵完全二叉树的根节点初始化该数据结构。</li><li>函数insert(int v)在完全二叉树中添加一个值为v的节点，并返回被插入节点的父节点。</li><li>函数get_root()返回完全二叉树的根节点。</li></ul><p>分析：</p><p>按照广度优先搜索的思路，找出第一个缺少子节点的节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CBTInserter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;TreeNode&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CBTInserter</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line"></span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.peek().left != <span class="keyword">null</span> &amp;&amp; queue.peek().right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        TreeNode parent = queue.peek();</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.left = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = node;</span><br><span class="line"></span><br><span class="line">            queue.poll();</span><br><span class="line">            queue.offer(parent.left);</span><br><span class="line">            queue.offer(parent.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parent.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">get_root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造函数本质上来说是按照广度优先搜索的顺序找出二叉树中所有既有左子节点又有右子节点的节点，因此**时间复杂度是O(n)<strong>。调用函数insert在完全二叉树中每添加一个节点最多只需要在队列中删除一个节点并添加两个节点。通常，队列的插入、删除操作的时间复杂度都是O(1)，因此函数</strong>insert的时间复杂度是O(1)<strong>。最后，</strong>get_root的时间复杂度是O(1)<strong>。需要一个队列来实现广度优先搜索算法保存缺少左子节点或右子节点的节点，</strong>空间复杂度是O(n)**。</p><h3 id="44-二叉树中每层的最大值"><a href="#44-二叉树中每层的最大值" class="headerlink" title="#44 二叉树中每层的最大值"></a>#44 二叉树中每层的最大值</h3><p>输入一棵二叉树，请找出二叉树中每层的最大值。</p><p>分析：</p><p>这个题目提到了二叉树的层。既然要找出二叉树中每层的最大值，就要逐层遍历二叉树，也就是说，按照广度优先的顺序遍历二叉树。这里介绍两种解法：</p><ol><li><p>用一个队列实现二叉树的广度优先搜索：</p><p>由于要找出二叉树中每层的最大值，因此在遍历时需要知道每层什么时候开始、什么时候结束。如果还是和前面一样只用一个队列来保存尚未遍历到的节点，那么有可能位于不同的两层的节点同时在队列之中。此时，每次从队列之中取出节点来遍历时就需要知道这个节点位于哪一层。解决办法之一是计数，<strong>用current记录当前层节点的数量，用next记录下一层节点的数量</strong>。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">largestValues1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            current = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 取出当前层节点并更新计数变量</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            current--;</span><br><span class="line">            max = Math.max(max, node.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前层节点遍历完毕，更新变量值</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(max);</span><br><span class="line">                max = Integer.MIN_VALUE;</span><br><span class="line">                current = next;</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>用两个队列实现二叉树的广度优先搜索：</p><p>用两个队列分别存放不同层的节点。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">largestValues2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue1.offer(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue1.poll();</span><br><span class="line">        max = Math.max(max, node.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            result.add(max);</span><br><span class="line">            max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过比较上述两种思路的代码不难发现，是用两个队列的代码逻辑稍微简单一些。</p><p>每个节点需要入队一次，**时间复杂度为O(n)<strong>。队列中最多存储一层的全部节点，如果是满二叉树，则</strong>最坏空间复杂度为O(n)**。</p><h3 id="45-二叉树最低层最左边的值"><a href="#45-二叉树最低层最左边的值" class="headerlink" title="#45 二叉树最低层最左边的值"></a>#45 二叉树最低层最左边的值</h3><p>如何在一棵二叉树中找出它最低层最左边节点的值？假设二叉树中最少有一个节点。</p><p>分析：</p><p>利用广度优先搜索的思路，遍历所有节点。用一个变量bottomLeft来保存每一层最左边的节点的值。在遍历二叉树时，每当遇到新的一层时就将变量bottomLeft的值更新为该层第1个节点的值。当整颗二叉树都被遍历完之后，变量bottomLeft的值就是最后一层的第1个节点的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue1.offer(root);</span><br><span class="line">    <span class="keyword">int</span> bottomLeft = root.val;</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue1.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">                bottomLeft = queue1.peek().val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bottomLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="46-二叉树的右侧视图"><a href="#46-二叉树的右侧视图" class="headerlink" title="#46 二叉树的右侧视图"></a>#46 二叉树的右侧视图</h3><p>给定一棵二叉树，如果站在该二叉树的右侧，那么从上到下看到的节点构成二叉树的右侧试图。(每层最右边的节点)</p><p>分析：</p><p>广度优先搜索遍历二叉树，存储每层最后一个节点的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; view = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue1.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue1.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            view.add(node.val);</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树的深度优先搜索"><a href="#二叉树的深度优先搜索" class="headerlink" title="#二叉树的深度优先搜索"></a>#二叉树的深度优先搜索</h3><p>二叉树的深度优先搜索又可以细分为中序遍历、前序遍历和后序遍历。</p><p><img src="image-20211112175208698.png" alt="image-20211112175208698"></p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>遍历顺序：4，2，5，1，6，3，7</p><p>中序遍历的递归实现很直观：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    dfs(root, nodes);</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; nodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dfs(root.left, nodes);</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        dfs(root.right, nodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归有固有的局限性。如果二叉树的深度(从根节点到叶节点的最长路径的长度)太大，那么递归的代码可能会导致调用栈溢出的问题。<strong>可以用栈把递归的代码改写成迭代的代码。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        nodes.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量cur表示当前遍历的节点。如果该节点有左子节点，按照中序遍历的顺序，应该先遍历它的左子树。于是顺着指向左子节点的指针一直向下移动，并将沿途遇到的每个节点都添加到栈stack之中。第二个while循环结束之后，最左子节点(顺着指向左子节点的指针到达的最远的节点)位于栈顶，将它从栈顶出栈并遍历。按照中序遍历的顺序，在遍历一个节点之后再遍历它的右子树，因此把变量cur指向它的右子节点，开始下一轮的遍历，直到所有的节点都遍历完为止。</p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>遍历顺序: 1, 2, 4, 5, 3, 6, 7</p><p>递归实现前序遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preorderTraversal1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    dfs(root, nodes);</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; nodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        dfs(root.left, nodes);</span><br><span class="line">        dfs(root.right, nodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈实现前序遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.add(cur.val);</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>遍历顺序：4，5，2，6，7，3，1</p><p>递归实现后序遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postorderTraversal1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    dfs(root, nodes);</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; nodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dfs(root.left, nodes);</span><br><span class="line">        dfs(root.right, nodes);</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈实现后序遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前遍历的节点</span></span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="comment">// 上一个遍历的节点</span></span><br><span class="line">    TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span> &amp;&amp; cur.right != prev) &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            result.add(cur.val);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，变量prev就是遍历过的前一个节点，它初始化为null。在准备便利下一个节点时，就把它指向当前遍历的节点。</p><p>变量cur表示当前到达的节点。如果该节点有右子节点并且右子节点不是前一个遍历的节点，则表示它有右子树并且右子树还没有遍历过。按照后序遍历的顺序，应该先遍历它的右子树，因此把变量指向它的右子节点。</p><h4 id="三种遍历方法小结"><a href="#三种遍历方法小结" class="headerlink" title="三种遍历方法小结"></a>三种遍历方法小结</h4><p>不管哪种深度优先算法，也不管是递归代码还是迭代代码，如果二叉树有n个节点，那么它们的**时间复杂度都是O(n)<strong>。如果二叉树的深度为h，那么它们的</strong>空间复杂度都是O(h)**。在二叉树中，二叉树的深度h的最小值是log2(n+1)。</p><h3 id="47-二叉树剪枝"><a href="#47-二叉树剪枝" class="headerlink" title="#47 二叉树剪枝"></a>#47 二叉树剪枝</h3><p>一棵二叉树的所有节点的值要么是0要么是1，请剪除该二叉树中所有节点的值全部都是0的子树。</p><p>例如：</p><p><img src="image-20211113222017322.png" alt="image-20211113222017322"></p><p>分析：</p><p>首先总结什么样的节点可以被删除。首先，这个节点的值应该是0。其次，如果它有子树，那么它的子树的所有节点的值都为0。也就是说，如果一个节点可以被删除，那么它的子树的所有节点都可以被删除。</p><p>由此发现，后序遍历最适合用来解决这个问题。如果用后序遍历的顺序遍历到某个节点，那么它的左右子树的节点一定已经遍历过了。每遍历到一个节点，就要确定它是否有左右子树，如果左右子树都是空的，并且节点的值是0，那么也就可以删除这个节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root.left = pruneTree(root.left);</span><br><span class="line">    root.right = pruneTree(root.right);</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="48-序列化和反序列化二叉树"><a href="#48-序列化和反序列化二叉树" class="headerlink" title="#48 序列化和反序列化二叉树"></a>#48 序列化和反序列化二叉树</h3><p>请设计一个算法将二叉树序列化成一个字符串，并能将该字符串反序列化出原来二叉树的算法。</p><p>分析：</p><p>以前序遍历的顺序遍历二叉树最适合序列化。如果采用前序遍历的顺序，那么二叉树的根节点最先序列化到字符串中，然后是左子树，最后是右子树。这样做的好处是在反序列化时最方便，从字符串中读出的第1个数值一定是根节点的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String leftStr = serialize(root.left);</span><br><span class="line">    String rightStr = serialize(root.right);</span><br><span class="line">    <span class="keyword">return</span> root.val + <span class="string">&quot;,&quot;</span>+ leftStr + <span class="string">&quot;,&quot;</span> + rightStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    String[] nodeStrs = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span>[] i = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> dfs(nodeStrs, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">dfs</span><span class="params">(String[] strs, <span class="keyword">int</span>[] i)</span> </span>&#123;</span><br><span class="line">    String str = strs[i[<span class="number">0</span>]];</span><br><span class="line">    i[<span class="number">0</span>]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str.equals(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(Integer.valueOf(str));</span><br><span class="line">    node.left = dfs(strs, i);</span><br><span class="line">    node.right = dfs(strs, i);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中定义了一个长度为1的整数数组i。这是因为递归函数dfs每反序列化一个节点时下标就会增加1，并且函数的调用者需要直到下标增加了。</p><h3 id="49-从根节点到叶节点的路径数字之和"><a href="#49-从根节点到叶节点的路径数字之和" class="headerlink" title="#49 从根节点到叶节点的路径数字之和"></a>#49 从根节点到叶节点的路径数字之和</h3><p>在一棵二叉树中，所有的节点都在0~9的范围之内，从根节点到叶节点的路径表示一个数字。求二叉树中所有路径表示的数字之和。</p><p>例如：</p><p><img src="image-20211114220905216.png" alt="image-20211114220905216"></p><p>此二叉树中有3条从根节点到叶节点的路径，它们分别表示数字395, 391, 302。这三个数字之和是1088。</p><p>分析：</p><p>首先考虑如何计算路径表示的数字。顺着指向子节点的指针路径向下遍历二叉树，每到达一个节点，相当于在路径表示的数字末尾添加一位数字。例如，在最开始到达根节点时，它表示数字3。然后到达节点9，此时路径表示数字39(3*10+9)。然后向下到达节点5，此时路径表示数字395(39*10+5)。<strong>这是典型的二叉树前序遍历。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断非叶子节点并返回0</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path = path * <span class="number">10</span> + root.val;</span><br><span class="line">    <span class="comment">// 只有是叶子节点时才会返回</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(root.left, path) + dfs(root.right, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="50-向下的路径节点之和"><a href="#50-向下的路径节点之和" class="headerlink" title="#50 向下的路径节点之和"></a>#50 向下的路径节点之和</h3><p>给定一棵二叉树和一个值sum，求二叉树中节点值之和等于sum的路径的数目。路径的定义为二叉树中顺着指向叶子节点的指针向下移动所经过的结点，但不一定从根节点开始，也不一定到叶节点结束。</p><p>例如：下图所示的二叉树中有两条路径的节点值之和等于8，其中第1条路径从节点5开始经过节点2到达节点1。第2条路径从节点2开始到节点6。</p><p><img src="image-20211118002034535.png" alt="image-20211118002034535"></p><p>分析：</p><p>如果在路径上移动时把所有累加的节点值之和都保存下来，就容易知道是否存在从任意节点出发的值为给定sum的路径。</p><p>当遍历到一个节点时，先累加从根节点开始的路径上的节点值之和，再计算到它的左右子节点的路径的节点值之和。这是典型的前序遍历顺序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.putIfAbsent(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(root, sum, map, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, Map&lt;Integer, Integer&gt; map, <span class="keyword">int</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path += root.val;</span><br><span class="line">    <span class="keyword">int</span> count = map.getOrDefault(path - sum, <span class="number">0</span>);</span><br><span class="line">    map.put(path, map.getOrDefault(path, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    count += dfs(root.left, sum, map, path);</span><br><span class="line">    count += dfs(root.right, sum, map, path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数结束之前要将当前节点从路径中删除</span></span><br><span class="line">    map.put(path, map.get(path) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="51-节点值之和最大的路径"><a href="#51-节点值之和最大的路径" class="headerlink" title="#51 节点值之和最大的路径"></a>#51 节点值之和最大的路径</h3><p>在二叉树中将路径定义为顺着节点之间的连接从任意一个节点开始到达任意一个节点所经过的所有节点。路径中至少包含一个节点，不一定经过二叉树的根节点，也不一定经过叶节点。给定非空的一棵二叉树，请求出二叉树所有路径上节点值之和的最大值。</p><p>例如，下图所示的二叉树中，从节点15开始经过节点20到达节点7的路径的节点值之和为42，是节点值之和最大的路径。</p><p><img src="image-20211118003721763.png" alt="image-20211118003721763"></p><p>分析：当路径到达某个节点时，该路径既可以前往它的左子树，也可以前往它的右子树。但如果路径同时经过它的左右子树，那么就不能经过它的父节点。所以需要先求出左右子树中路径节点值之和的最大值(左右子树中的路径不经过当前节点)，再求出经过根节点的路径节点值之和的最大值，最后对三者进行比较得到最大值。<strong>这是典型的后序遍历。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] maxSum = &#123;Integer.MIN_VALUE&#125;;</span><br><span class="line">    dfs(root, maxSum);</span><br><span class="line">    <span class="keyword">return</span> maxSum[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] maxSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] maxSumLeft = &#123;Integer.MIN_VALUE&#125;;</span><br><span class="line">    <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, dfs(root.left, maxSumLeft));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] maxSumRight = &#123;Integer.MIN_VALUE&#125;;</span><br><span class="line">    <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, dfs(root.right, maxSumRight));</span><br><span class="line"></span><br><span class="line">    maxSum[<span class="number">0</span>] = Math.max(maxSumLeft[<span class="number">0</span>], maxSumRight[<span class="number">0</span>]);</span><br><span class="line">    maxSum[<span class="number">0</span>] = Math.max(maxSum[<span class="number">0</span>], root.val + left + right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要包含当前节点并经过其父节点，就不能同时经过当前节点的左右子树</span></span><br><span class="line">    <span class="keyword">return</span> root.val + Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="#二叉搜索树"></a>#二叉搜索树</h3><p>二叉搜索树是一类特殊的二叉树，它的左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点。例如：</p><p><img src="image-20211119115312448.png" alt="image-20211119115312448"></p><p>二叉树的3种不同的深度优先搜索算法都适用于二叉搜索树，但中序遍历是解决二叉搜索树相关面试题最常用的思路，因为中序遍历按照节点值递增的顺序遍历二叉搜索树的每个节点。</p><p>在普通的二叉搜索树中根据节点的值查找对应节点需要遍历这棵二叉树，因此需要O(n)的时间。但如果是二叉搜索树就可以根据其特性进行优化。类似二分查找，如果二叉搜索树的高度为h，那么在二叉搜索树中根据节点值查找对应节点的时间复杂度是O(h)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; val) &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.val &lt; val) &#123;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="52-展平二叉搜索树"><a href="#52-展平二叉搜索树" class="headerlink" title="#52 展平二叉搜索树"></a>#52 展平二叉搜索树</h3><p>给定一棵二叉搜索树，请调整节点的指针使每个节点都没有左子节点。调整后的树看起来像一个链表，但仍然是二叉搜索树。</p><p>分析：</p><p>调整后的二叉搜索树从根节点开始顺着指向右子节点的指针向下经过的结点的值将是递增排序的。因此需要按照节点的值递增的顺序遍历二叉搜索树中的每个节点，并将节点用指向右子节点的指针连接起来。这就很容易联想到二叉树的<strong>中序遍历</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 调整后二叉树的根节点</span></span><br><span class="line">    TreeNode first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev.right = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            first = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur.left = <span class="keyword">null</span>;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="53-二叉搜索树的下一个节点"><a href="#53-二叉搜索树的下一个节点" class="headerlink" title="#53 二叉搜索树的下一个节点"></a>#53 二叉搜索树的下一个节点</h3><p>给定一棵二叉搜索树和它的一个节点p，请找出按中序遍历的顺序该节点p的下一个节点。假设二叉搜索树中节点的值都是唯一的。</p><p>分析：</p><p>从不同的角度看待二叉搜索树中的节点的下一个节点，有不同的解决方法。</p><ol><li><p>时间复杂度O(n)的解法：</p><p>最直观的思路就是采用二叉树的中序遍历。可以用一个布尔变量found来记录已经遍历到节点p。该变量初始化为false，遍历到节点p就将它设为true。在这个变量变成true之后遍历到的第一个节点就是要找的节点。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">inorderSuccessor1</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == cur) &#123;</span><br><span class="line">            found = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>时间复杂度为O(h)的解法：</p><p>如果当前节点小于或等于p，那么p的下一个节点应该在它的右子树上。如果当前节点大于p，那p的下一个节点可能是当前节点，也可能在当前节点的左子树上。我们重复这样的比较，直至找到最后一个大于p的节点，就是p的下一个节点。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">inorderSuccessor2</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; p.val) &#123;</span><br><span class="line">            result = cur;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-所有大于或等于节点的值之和"><a href="#54-所有大于或等于节点的值之和" class="headerlink" title="#54 所有大于或等于节点的值之和"></a>#54 所有大于或等于节点的值之和</h3><p>给定一棵二叉搜索树，请将它的每个节点的值替换成树中大于或等于该节点的所有节点值之和。假设二叉搜索树中节点的值唯一。</p><p>例如：</p><p><img src="image-20211120214235348.png" alt="image-20211120214235348"></p><p>分析：</p><p>此题与节点值的大小顺序有关。在二叉搜索树的常用遍历算法中，只有中序遍历是按照节点值递增的顺序遍历所有节点的。当遍历到某个节点时，比该节点的值小的节点都已经遍历过，因此也就知道了所有比该节点的值小的所有节点的值之和sum。因此，可以先遍历一边二叉树求出所有节点的值之和total，再用total-sum即可。此思路需要遍历二叉搜索树两次，第一次不管用什么算法只要遍历所有节点即可，第二次则必须采用中序遍历。</p><p><strong>是否可以只遍历二叉搜索树一次？</strong>答案是肯定的。只需要改变中序遍历的顺序，先遍历右子树再遍历根节点，最后遍历左子树，这昂遍历的顺序就颠倒过来了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        sum += cur.val;</span><br><span class="line">        cur.val = sum;</span><br><span class="line">        cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="55-二叉搜索树迭代器"><a href="#55-二叉搜索树迭代器" class="headerlink" title="#55 二叉搜索树迭代器"></a>#55 二叉搜索树迭代器</h3><p>请实现二叉搜索树的迭代器BSTIterator，它主要有如下三个函数。</p><ul><li>构造函数：输入二叉搜索树的根节点初始化该迭代器</li><li>函数next：返回二叉搜索树中下一个最小的节点的值</li><li>函数hasNext：返回二叉搜索树是否还有下一个节点</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    TreeNode cur;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cur = root;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur != <span class="keyword">null</span> || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> val = cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="56-二叉搜索树中两个节点的值之和"><a href="#56-二叉搜索树中两个节点的值之和" class="headerlink" title="#56 二叉搜索树中两个节点的值之和"></a>#56 二叉搜索树中两个节点的值之和</h3><p>给定一棵二叉搜索树和一个值k，请判断该二叉搜索树中是否存在值之和等于k的两个节点。假设二叉搜索树中节点的值均唯一。</p><p>分析：</p><p>解决这个问题自然需要遍历二叉树中的所有节点，因此这是一个关于二叉树遍历的问题。这里给出两种解法</p><ol><li><p>利用哈希表，空间复杂度为O(n)的解法。</p><p>解决这个问题最直观的思路是利用哈希表保存节点的值。可以采用任意遍历算法遍历输入的二叉搜索树，每遍历到一个节点(节点值记为v)，就在哈希表中查看是否存在值为k-v的节点。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findTarget1</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (set.contains(k - cur.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>应用双指针，空间复杂度为O(h)的解法。</p><p>面试题6介绍了如何利用双指针判断在排序数组中是否包含两个和为k的数字。实际上，在某种程度上可以把二叉搜索树看成一个排序的数组。采用55题BSTIterator，则可以每次按照从小到大的顺序从二叉搜索树中取出一个节点。<strong>此时BSTIterator就相当于第一个指针</strong>。受54题启发，我们可以实现从大到小遍历二叉搜索树。因此可以用类似的思路实现<strong>一个颠倒顺序的二叉搜索树的迭代器，相当于第二个指针</strong>。</p></li></ol><p>迭代器如下图所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIteratorReversed</span> </span>&#123;</span><br><span class="line">    TreeNode cur;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIteratorReversed</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cur = root;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur != <span class="keyword">null</span> || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> val = cur.val;</span><br><span class="line">        cur = cur.left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于双指针的思路，代码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findTarget2</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BSTIterator iterNext = <span class="keyword">new</span> BSTIterator(root);</span><br><span class="line">    BSTIteratorReversed iterPrev = <span class="keyword">new</span> BSTIteratorReversed(root);</span><br><span class="line">    <span class="keyword">int</span> next = iterNext.next();</span><br><span class="line">    <span class="keyword">int</span> prev = iterPrev.prev();</span><br><span class="line">    <span class="keyword">while</span> (next != prev) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next + prev == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next + prev &lt; k) &#123;</span><br><span class="line">            next = iterNext.next();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = iterPrev.prev();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多数情况下，二叉树的深度远小于二叉树的节点数，因此第2种算法的总体空间效率要优于第1种算法。</p><h3 id="TreeSet和TreeMap的应用"><a href="#TreeSet和TreeMap的应用" class="headerlink" title="#TreeSet和TreeMap的应用"></a>#TreeSet和TreeMap的应用</h3><p>二叉搜索树是一种很有用的数据结构。实现一棵平衡的二叉搜索树对于面试来说不是一件容易的事情。Java根据红黑树这种平衡的二叉树实现TreeSet和TreeMap两种数据结构。</p><h4 id="TreeSet的常用函数"><a href="#TreeSet的常用函数" class="headerlink" title="TreeSet的常用函数"></a>TreeSet的常用函数</h4><table><thead><tr><th>序号</th><th>函数</th><th>函数功能</th></tr></thead><tbody><tr><td>1</td><td>ceiling</td><td>返回键大于或等于给定值的最小键: 如果没有则返回null</td></tr><tr><td>2</td><td>floor</td><td>返回键小于或等于给定值的最大键: 如果没有则返回null</td></tr><tr><td>3</td><td>higher</td><td>返回键大于等于给定值的最小键: 如果没有则返回null</td></tr><tr><td>4</td><td>lower</td><td>返回键小于给定值的最大键: 如果没有则返回null</td></tr></tbody></table><h4 id="TreeMap的常用函数"><a href="#TreeMap的常用函数" class="headerlink" title="TreeMap的常用函数"></a>TreeMap的常用函数</h4><table><thead><tr><th>序号</th><th>函数</th><th>函数功能</th></tr></thead><tbody><tr><td>1</td><td>ceilingEntry/ceilingKey</td><td>返回键大于或等于给定值的最小映射/键: 如果没有则返回null</td></tr><tr><td>2</td><td>floorEntry/floorKey</td><td>返回键小于或等于给定值的最大映射/键: 如果没有则返回null</td></tr><tr><td>3</td><td>higherEntry/higherKey</td><td>返回键大于给定值的最小映射/键: 如果没有则返回null</td></tr><tr><td>4</td><td>lowerEntry/lowerKey</td><td>返回键小于给定值的最大映射/键: 如果没有则返回null</td></tr></tbody></table><p>由于TreeSet或TreeMap能够保证其内部的二叉搜索树是平衡的，因此它们的查找、添加和删除操作的时间复杂度都是O(logn)，综合来看他们比动态排序数组更加高效。</p><h3 id="57-值和下标之差都在给定的范围内"><a href="#57-值和下标之差都在给定的范围内" class="headerlink" title="#57 值和下标之差都在给定的范围内"></a>#57 值和下标之差都在给定的范围内</h3><p>给定一个整数数组nums和两个正数k、t，请判断是否存在两个不同的下标i和j满足i和j之差的绝对值不大于给定的k，并且两个数值nums[i]和nums[j]的差的绝对值不大于给定t。</p><p>分析：</p><p>首先考虑最直观的解法。可以逐一扫描数组中的每个数字，对于每个数字nums[i]，需要逐一检查在他前面的k个数字是否存在从nums[i]-t到nums[i]+t范围内的数字。如果存在则返回true。这种思路很容易用两个嵌套的循环实现。由于数组中的每个数字都要和k个数字进行比较，如果数组的长度为n，那么这种解法的时间复杂度是O(nk)。</p><p>下面尝试优化时间复杂度。</p><ol><li><p>时间复杂度为O(nlogk)的解法。</p><p>逐一扫描数组中的每个数字。对于每个数字nums[i]，应该先从它前面的k个数字中找出小于或等于nums[i]的最大的数字，如果这个数字与nums[i]的差的绝对值不大于t，那么就找到了一组符合条件的两个数字。否则，就再找出大于或等于nums[i]的最小的数字进行比较。</p><p>需要从一个大小为k的数据容器中找出小于或等于某个数字的最大值及大于或等于某个数字的最小值，这正是TreeSet或TreeMap适用的场景。因为这个容器只需要保存数字，所以可以用TreeSet来保存每个数字nums[i]前面的k个数字。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containNearbyAlmostDuplicate1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        Long lower = set.floor((<span class="keyword">long</span>) nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (lower != <span class="keyword">null</span> &amp;&amp; lower &gt;= (<span class="keyword">long</span>)nums[i] - t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long upper = set.ceiling((<span class="keyword">long</span>) nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (upper != <span class="keyword">null</span> &amp;&amp; upper &lt;= (<span class="keyword">long</span>)nums[i] + t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set.add((<span class="keyword">long</span>) nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">            set.remove((<span class="keyword">long</span>)nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，变量set是一个TreeSet，它的大小是k，因此空间复杂度是O(k)。对它做查找、添加和删除操作的时间复杂度都是O(logk)，因此对一个长度为n的数组而言，它的时间复杂度是O(nlogk)。</p><ol start="2"><li><p>时间复杂度为O(n)的解法。</p><p>可以将数字放入若干大小为t+1的桶中。例如将从0到t的数字放入编号为0的桶中，从t+1到2t+1的数字放入编号为1的桶中。这样做的好处是如果两个数字被放入同一个桶中，那么他们的差的绝对值一定小于或等于t。如果桶中之前没有数字，则再判断编号为id-1和id+1这两个相邻的桶中是否存在与num的差的绝对值小于或等于t的数字。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containNearbyAlmostDuplicate2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; buckets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> bucketSize = t + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i];</span><br><span class="line">        <span class="keyword">int</span> id = getBucketID(num, bucketSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buckets.containsKey(id)</span><br><span class="line">            || (buckets.containsKey(id-<span class="number">1</span>) &amp;&amp; buckets.get(id-<span class="number">1</span>) + t &gt;= num)</span><br><span class="line">            || (buckets.containsKey(id+<span class="number">1</span>) &amp;&amp; buckets.get(id+<span class="number">1</span>) - t &lt;= num)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buckets.put(id, num);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">            buckets.remove(getBucketID(nums[i-k], bucketSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBucketID</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &gt;= <span class="number">0</span> ? num / bucketSize : (num + <span class="number">1</span>) / bucketSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希表buckets的大小是k，因此，空间复杂度是O(k)。哈希表中的查找/添加和删除操作的时间复杂度都是O(1)，因此，对于一个长度为n的数组而言，它的时间复杂度是O(n)。</p><h3 id="58-日程表"><a href="#58-日程表" class="headerlink" title="#58 日程表"></a>#58 日程表</h3><p>请实现一个类型MyCalendar用来记录自己的日程安排，该类型用方法book(int start, int end)在日程表中添加一个时间区域为[start, end)的事项(这是一个半开半闭区间)。如果[start, end)中之前没有安排其他事项，则成功添加该始想并返回true；否则，不能添加该事项并返回false。</p><p>分析：</p><p>如果添加的事项占用的时间区间是[m, n), 就需要找出开始时间小于m的所有事项中开始最晚的一个，以及开始时间大于m的所有事项中开始最早的一个。如果待添加的事项和这两个事项都没有重叠，那么该事项可以添加在日程表中。由于每个时间区间都有开始时间和结束时间，也就是说树的每个节点需要保存两个数字。一个简单的办法是用TreeMap。可以把时间区间的开始作为映射的键，把结束时间作为映射的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;Integer, Integer&gt; events;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        events = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; event = events.floorEntry(start);</span><br><span class="line">        <span class="keyword">if</span> (event != <span class="keyword">null</span> &amp;&amp; event.getValue() &gt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        event = events.ceilingEntry(start);</span><br><span class="line">        <span class="keyword">if</span> (event != <span class="keyword">null</span> &amp;&amp; event.getKey() &lt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        events.put(start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的基础知识"><a href="#堆的基础知识" class="headerlink" title="#堆的基础知识"></a>#堆的基础知识</h3><p>堆是一种特殊的树形数据结构。根据根结点的值与子节点的值的大小关系，堆又分为最大堆和最小堆。在最大堆中，每个节点的值总是大于或等于其任意子节点的值，因此最大堆的根节点就是整个堆的最大值。在最小堆中，每个节点的值总是小于或等于其任意子节点的值，因此最小堆的根节点就是整个堆的最小值。</p><p>堆通常用完全二叉树实现。完全二叉树又可以用数组实现，因此堆也可以用数组实现。</p><p>如果数组中的一个元素的下标为i，那么它在堆中对应节点的父节点在数组中的下标为(i-1)/2，而它的左右子节点在数组中的下标分别为2i+1和2i+2。</p><p>为了在最大堆中添加新的节点，应该先从上到下、从左到右找出第1个空缺的位置，并将新节点添加到该空缺的位置。如果新结点的值比它的父节点的值大，那么交换它和它的父节点。重复这个过程，直到新节点的值小于或等于它的父节点，或者它已经到达堆顶部的位置。在最小堆中添加新节点的过程与此类似。</p><p>通常只删除位于堆顶部的元素。如果删除最大堆的顶部节点，则将堆最低层最右边的节点移到堆的顶部。如果此时它的左子节点或右子节点的值大于它，那么它和左右子节点中值较大的节点交换。如果交换之后节点的值仍然小于它的子节点的值，则再次交换，直到该节点的值大于或等于它的左右子节点的值，或者到达最低层为止。删除最小堆的顶部节点的过程与此类似。</p><p>Java提供了类型PriorityQueue实现数据结构堆。PriorityQueue在默认情况下是一个最小堆，如果使用最大堆调用构造函数就需要传入Comparator改变比较排序的规则。PriorityQueue实现了接口Queue，它常用的函数如下：</p><table><thead><tr><th>操作</th><th>抛异常</th><th>不抛异常</th></tr></thead><tbody><tr><td>插入元素</td><td>add(e)</td><td>offer(e)</td></tr><tr><td>删除堆顶元素</td><td>remove</td><td>poll</td></tr><tr><td>返回堆顶元素</td><td>element</td><td>peek</td></tr></tbody></table><h3 id="堆的应用"><a href="#堆的应用" class="headerlink" title="#堆的应用"></a>#堆的应用</h3><p>如果需要求出一个动态数据集合中的最大值或最小值，那么可以考虑使用堆来解决问题。</p><p>堆经常用来求取一个数据集合中值最大或最小的k个元素。通常，最小堆用来求取数据集合中k个值最大的元素，最大堆用来求取数据集合中k个值最小的元素。</p><h3 id="59-数据流的第k大数字"><a href="#59-数据流的第k大数字" class="headerlink" title="#59 数据流的第k大数字"></a>#59 数据流的第k大数字</h3><p>请设计一个类型KthLargest，它每次从一个数据流中读取一个数字，并得出数据流已经读取的数字中第k(k&gt;=1)大的数字。该类型的构造函数有两个参数: 一个是整数k，另一个是包含数据流中最开始数字的整数数组nums(假设数组nums)的长度大于k。该类型还有一个函数add，用来添加数据流中的新数字并返回数据流中已经读取的数字的第k大数字。</p><p>分析：</p><p>如果能够找出k个最大的数字，那么第k大的数字就是这k个最大数字中最小的一个。由于每次都需要找出k个数字中的最小值，因此可以把这k个数字保存到最小堆中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = k;</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() &lt; size) &#123;</span><br><span class="line">            minHeap.offer(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; minHeap.peek()) &#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">            minHeap.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="60-出现频率最高的k个数字"><a href="#60-出现频率最高的k个数字" class="headerlink" title="#60 出现频率最高的k个数字"></a>#60 出现频率最高的k个数字</h3><p>请找出数组中出现频率最高的k个数字。</p><p>例如：当k等于2时，输入数组[1,2,2,1,3,1]，由于数字1出现了3次，数字2出现了2次，数字3出现了1次，因此出现频率最高的2个数字时1和2。</p><p>分析：</p><p>首先想到解决这个题目要用到哈希表。哈希表可以用来统计数组中数字出现的频率，哈希表的键时数组中出现的数字，值是数字出现的频率。</p><p>接下来找出出现频率最高的k个数字。可以用一个最小堆存储频率最高的k个数字，堆中的每个元素是数组中的数字及其在数组中出现的次数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; numToCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        numToCount.put(num, numToCount.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (e1, e2) -&gt; e1.getValue() - e2.getValue()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : numToCount.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() &lt; k) &#123;</span><br><span class="line">            minHeap.offer(entry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() &gt; minHeap.peek().getValue()) &#123;</span><br><span class="line">                minHeap.poll();</span><br><span class="line">                minHeap.offer(entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : minHeap) &#123;</span><br><span class="line">        result.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码需要一个大小为O(n)的哈希表和一个大小为O(k)的最小堆，因此**总空间复杂度为O(n)<strong>。在大小为k的堆中进行添加或删除操作的时间复杂度是O(logk)，因此</strong>总时间复杂度是O(nlogk)**。</p><h3 id="61-和最小的k个树对"><a href="#61-和最小的k个树对" class="headerlink" title="#61 和最小的k个树对"></a>#61 和最小的k个树对</h3><p>给定两个递增排序的整数数组，从两个数组中各取一个数字u和v组成一个数对(u,v)，请找出最小的k个数对。</p><p>例如两个数组[1,5,13,21]和[2,4,9,15]，和最小的3个数对为(1,2)、(1,4)和(2,5)。</p><p>分析：</p><p>假设第一个数组nums1的长度为m，第二个数组nums2的长度为n，那么从两个数组中各取一个数字能组成mxn个数对。</p><ol><li><p>使用最大堆</p><p>用最大堆存储这k个和最小的数对。</p><p>因为输入的数组是递增排序的，因此，不管数组nums1有多长，最多只需要考虑前k个数字。同理，不管输入的数组nums2有多长，最多也只需要考虑前k个数字。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs1(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (p1, p2) -&gt; p2[<span class="number">0</span>] + p2[<span class="number">1</span>] - p1[<span class="number">0</span>] - p1[<span class="number">1</span>]</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(k, nums1.length); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Math.min(k, nums2.length); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxHeap.size() &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] root = maxHeap.peek();</span><br><span class="line">                <span class="keyword">if</span> (root[<span class="number">0</span>] + root[<span class="number">1</span>] &gt; nums1[i] + nums2[j]) &#123;</span><br><span class="line">                    maxHeap.poll();</span><br><span class="line">                    maxHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] vals = maxHeap.poll();</span><br><span class="line">        result.add(Arrays.asList(vals[<span class="number">0</span>], vals[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(k^2logk)。</p><ol start="2"><li><p>使用最小堆</p><p>我们先用nums1的前k个数字和nums2的第1个数字组成数对，存入最小堆中。如果和最小的数对的两个数字在两个数组中的下标分别为i1和i2，将该数对添加到结果中并将其从最小堆中删除，再将燥起两个数组中分下标分别为i1和i2+1的两个新数字作为新的候选数对添加到最小堆中。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs2(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (p1, p2) -&gt; nums1[p1[<span class="number">0</span>]] + nums2[p1[<span class="number">1</span>]] - nums1[p2[<span class="number">0</span>]] - nums2[p2[<span class="number">1</span>]]</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (nums2.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(k, nums1.length); i++) &#123;</span><br><span class="line">            minHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 只需要k次操作就可以得出最小的k组数对</span></span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !minHeap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ids = minHeap.poll();</span><br><span class="line">        result.add(Arrays.asList(nums1[ids[<span class="number">0</span>]], nums2[ids[<span class="number">1</span>]]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ids[<span class="number">1</span>] &lt; nums2.length - <span class="number">1</span>) &#123;</span><br><span class="line">            minHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;ids[<span class="number">0</span>], ids[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(klogk)。</p><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><h3 id="前缀树的基础知识"><a href="#前缀树的基础知识" class="headerlink" title="#前缀树的基础知识"></a>#前缀树的基础知识</h3><p>前缀树，又称为字典树，它用一个树状的数据结构存储一个字典中的所有单词。如果一个字典中包含单词”can”、”cat”、”come”、”do”、”i”、”in”和”inn”，那么保存该字典所有单词的前缀树如图所示：</p><p><img src="image-20211124150911045.png" alt="image-20211124150911045"></p><p>前缀树是一棵多叉树，一个节点可能有多个子节点。本章中如果没有特殊说明，那么前缀树中都只包含英文小写字母。</p><h3 id="62-实现前缀树"><a href="#62-实现前缀树" class="headerlink" title="#62 实现前缀树"></a>#62 实现前缀树</h3><p>请设计一棵前缀树Tire，它有如下操作。</p><p>函数insert，在前缀树中添加一个字符串</p><p>函数search，查找字符串。如果前缀树中包含该字符串，则返回true，否则返回false。</p><p>函数startWith，查找字符串前缀。如果前缀树中包含以该前缀开头的字符串，则返回true，否则返回false。</p><p>分析：</p><p>如果只考虑英文小写字母，那么字符可能是从’a’到’z’的任意一个，因此前缀树中的节点可能有26个子节点。可以将26个子节点放到一个数组中，数组中的第1个元素是对应字母’a’的子节点，第2个元素是对应字母’b’的子节点，其余的以此类推。</p><p>节点中还需要一个布尔类型的字段表示到达该节点的路径对应的字符串是否为字典中一个完整的单词。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        TrieNode children[];</span><br><span class="line">        <span class="keyword">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node.isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="63-替换单词"><a href="#63-替换单词" class="headerlink" title="#63 替换单词"></a>#63 替换单词</h3><p>英语中有一个概念叫词根。在词根后面加上若干字符就能拼出更长的单词。例如”an”是一个词根，在它后面加上”other”就能得到另一个单词”another”。现在给定一个由词根组成的字典和一个英语句子，如果句子中的单词在字典中有它的词根，则用它的词根替换该单词；如果单词没有词根，则保留该单词。请输出替换后的句子。</p><p>例如：如果词根字典包含[“cat”, “bat”, “rat”]，英语句子为”the catle was ratled by the battery”，则替换之后的句子为”the cat was rat by the bat”.</p><p>分析：</p><p>这个题目中的词根其实就是前缀，因此很容易想到用前缀树来解决。用前缀树解决问题通常分为两步，第1步是创建前缀树，第2步是在前缀树中查找。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Trie.<span class="function">TrieNode <span class="title">buildTrie</span><span class="params">(List&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">        Trie.TrieNode root = <span class="keyword">new</span> Trie.TrieNode();</span><br><span class="line">        <span class="keyword">for</span> (String word : dict) &#123;</span><br><span class="line">            Trie.TrieNode node = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Trie.TrieNode();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">findPrefix</span><span class="params">(Trie.TrieNode root, String word)</span> </span>&#123;</span><br><span class="line">    Trie.TrieNode node = root;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.isWord || node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        builder.append(ch);</span><br><span class="line">        node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有最后node.isWord == true，才说明满足前缀</span></span><br><span class="line">    <span class="keyword">return</span> node.isWord ? builder.toString() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> </span>&#123;</span><br><span class="line">    Trie.TrieNode root = buildTrie(dict);</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    String[] words = sentence.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        String prefix = findPrefix(root, words[i]);</span><br><span class="line">        <span class="keyword">if</span> (!prefix.isEmpty()) &#123;</span><br><span class="line">            words[i] = prefix;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, words);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="64-神奇的字典"><a href="#64-神奇的字典" class="headerlink" title="#64 神奇的字典"></a>#64 神奇的字典</h3><p>请实现有如下两个操作的神奇字典。</p><ul><li>函数buildDict，输入单词数组用来创建一个字典</li><li>函数search，输入一个单词，判断能否修改该单词中的一个字符，使修改之后的单词使字典中的一个单词。</li></ul><p>例如：</p><p>输入[“happy”, “new”, “year”]创建神奇字典。输入单词”now”进行查找操作，返回true。</p><p>分析：</p><p>可以根据深度优先的顺序搜索前缀树的每条路径。如果到达的节点与字符串中的字符不匹配，则表示此时修改了字符串中的一个字符以匹配前缀树中的路径。如果到达对应字符串最后一个字符对应的节点时该节点的isWord字段的值为true，而且此时正好修改了字符串中的一个字符，那么就找到了修改字符串中一个字符对应的路径，符合题目的条件，可以返回true。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> TrieNode[] children;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MagicDictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(String[] dict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : dict) &#123;</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, word, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 当前查找的字符串中字符的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> edit 字符串中当前已经修改的字符的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TrieNode root, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> edit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.isWord &amp;&amp; i == word.length() &amp;&amp; edit == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; word.length() &amp;&amp; edit &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span> &amp;&amp; !found; j++) &#123;</span><br><span class="line">                <span class="comment">// 判断当前字符是否与第i个字母相同，若不相同则更新edit+1</span></span><br><span class="line">                <span class="keyword">int</span> next = j == word.charAt(i) - <span class="string">&#x27;a&#x27;</span> ? edit : edit + <span class="number">1</span>;</span><br><span class="line">                found = dfs(root.children[j], word, i + <span class="number">1</span>, next);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> found;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="65-最短的单词编码"><a href="#65-最短的单词编码" class="headerlink" title="#65 最短的单词编码"></a>#65 最短的单词编码</h3><p>输入一个包含n个单词的数组，可以把它们编码成一个字符串和n个下标。</p><p>例如：单词数组[“time”, “me”, “bell”]可以编码成一个字符串”time#bell#”, 然后这些单词就可以通过下标[0,2,5]得到。给定一个单词数组，请问按照上述规则把这些单词编码之后得到的最短字符串的长度是多少？</p><p>分析：</p><p>如果一个单词A是另一个单词B的后缀，那么单词A在编码字符串中就不需要单独出现，这是因为单词A可以通过在单词B中偏移下标得到。</p><p>可以把字符串的后缀转换成前缀，存储在前缀树中。然后统计路径长度即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        TrieNode root = buildTrie(words);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] total = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dfs(root, <span class="number">1</span>, total);</span><br><span class="line">        <span class="keyword">return</span> total[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> TrieNode <span class="title">buildTrie</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = word.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TrieNode root, <span class="keyword">int</span> length, <span class="keyword">int</span>[] total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isLeaf = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TrieNode child : root.children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            isLeaf = <span class="keyword">false</span>;</span><br><span class="line">            dfs(child, length + <span class="number">1</span>, total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">        total[<span class="number">0</span>] += length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="66-单词之和"><a href="#66-单词之和" class="headerlink" title="#66 单词之和"></a>#66 单词之和</h3><p>qing设计实现一个类型MapSum，它有如下两个操作</p><ul><li>函数insert，输入一个字符串和一个整数，在数据集合中添加一个字符串及其对应的值。如果数据集合中已经包含该字符串，则将该字符串对应的值替换成新值。</li><li>函数sum，输入一个字符串，返回数据集合中所有以该字符串为前缀的字符串对应的值之和。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> TrieNode[] children;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getSum(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(TrieNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = node.value;</span><br><span class="line">        <span class="keyword">for</span> (TrieNode child : node.children) &#123;</span><br><span class="line">            result += getSum(child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="67-最大的异或"><a href="#67-最大的异或" class="headerlink" title="#67 最大的异或"></a>#67 最大的异或</h3><p>输入一个整数数组(每个数字都大于或等于0)，请计算其中任意两个数字的异或的最大值。</p><p>例如，在数组[1,3,4,7]中，3和4的异或结果最大，异或结果为7。</p><p>分析：</p><p>整数的异或有一个特点，如果两个相同数位异或的结果是0，那么两个相反的数位异或的结果为1。如果想找到某个整数k和其他整数的最大异或值，那么尽量找和k的数位不同的整数。</p><p>因此，这个问题可以转化为查找的问题，而且还是按照整数的二进制数位进行查找的问题。需要将整数的每个数位都保存下来。前缀树可以实现这种思路，前缀树的每个节点对应整数的一个数位，路径对应一个整数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> TrieNode[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TrieNode <span class="title">buildTrie</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[bit] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[bit] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[bit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    TrieNode root = buildTrie(nums);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[<span class="number">1</span>-bit] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                xor = (xor &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                node = node.children[<span class="number">1</span>-bit];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                xor = xor &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                node = node.children[bit];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        max = Math.max(max, xor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="二分查找的基础知识"><a href="#二分查找的基础知识" class="headerlink" title="#二分查找的基础知识"></a>#二分查找的基础知识</h3><p>在递增排序数组中进行二分查找的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分查找的时间复杂度为O(logn)</strong></p><h3 id="68-查找插入的位置"><a href="#68-查找插入的位置" class="headerlink" title="#68 查找插入的位置"></a>#68 查找插入的位置</h3><p>输入一个排序的整数数组nums和一个目标值t，如果数组nums中包含t，则返回t在数组中的下标；如果数组nums中不包含t，则返回将t按顺序插入数组nums中的下标。假设数组中没有相同的数字。</p><p>例如：输入数组nums[1,3,6,8]，如果目标值t为3，则输出1；如果t为5，则返回2。</p><p>分析：</p><p>当数组中包含目标值时，返回它在数组中的位置。由于数组中没有相同的数字，因此它前一个数字一定小于目标值。于是可以将目标值t是否在数组中出现的两种情况统一起来，即查找满足两个条件的位置：一是该位置上的数字大于或等于t，二是该位置的前一个数字小于t。</p><p>要注意两个特殊情况。</p><ol><li>当mid等于0时如果nums[mid]依然大于目标值t，则意味着数组中的所有数字都比目标值大，应该返回0。</li><li>当数组中不存在大于或等于目标值t的数字时，那么t应该添加到所有数组的值的后面，即返回数组的长度。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="69-山峰数组的顶部"><a href="#69-山峰数组的顶部" class="headerlink" title="#69 山峰数组的顶部"></a>#69 山峰数组的顶部</h3><p>在一个长度大于或等于3的数组，任意相邻的两个数字都不相等。该数组的前若干个数字时递增的，之后的数字时递减的，因此它的值看起来像一座山峰。请找出山峰顶部，即数组中最大值的位置。</p><p>例如：</p><p>在数组[1,3,5,4,2]中，最大值是5，输出它在数组中的下标2。</p><p>分析：</p><p>根据山峰数组的特点，最大值是数组中唯一一个比它左右两边数字都大的数字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="70-排序数组中只出现一次的数字"><a href="#70-排序数组中只出现一次的数字" class="headerlink" title="#70 排序数组中只出现一次的数字"></a>#70 排序数组中只出现一次的数字</h3><p>在一个排序的数组中，除一个数字只出现一次之外，其他数字都出现了两次，请找出这个唯一只出现一次的数字。</p><p>例如：</p><p>在数组[1,1,2,2,3,4,4,5,5]中，数字3只出现了一次。</p><p>分析：</p><p>如果题目稍加改动，输入的数组没有经过排序，其他条件不变，那么这就是另一类很经典的面试题。由于两个相同的数字异或的结果是0，因此如果将数组中所有数字异或，最终的结果就是那个唯一只出现一次的数字。这种解法的时间复杂度是O(n)。</p><p>但是既然是在排序数组中查找某个数字，就尝试应用二分查找算法。在一个排序数组中，如果所有数字都出现了两次，那么将数组中的数字每两个分成一组，每组的两个数字都是相等的。但如果在数组中添加一个只出现一次的数字，那么这个规律就会被打破。</p><p>其规律是：最初若干组的两个数字都是相同的。但是遇到了只出现一次的数字之后，导致后面所有出现两次的数字都被分到两个不同的组，即后面所有组的两个数字都不相同。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i = mid * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] != nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[i - <span class="number">2</span>] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果数组的长度是n(n为奇数)，每两个数字分成一组，则可以分成n/2+1组，最后一组只有一个数字。把这些分组从0开始编号，那么可以编号为0~n/2。在上述代码中，left是查找范围内的第1个分组的编号，right是查找范围内最后一个分组的编号。</p><h3 id="71-按权重生成随机数"><a href="#71-按权重生成随机数" class="headerlink" title="#71 按权重生成随机数"></a>#71 按权重生成随机数</h3><p>输入一个正整数数组w，数组中的每个数字w[i]表示下标i的权重，请实现一个函数pickIndex根据权重比例随机选择一个下标。</p><p>例如：</p><p>如果权重数组w为[1,2,3,4]，那么函数pickIndex将有10%的概率选择0、20%的概率选择1、30%的概率选择2、40%的概率选择3。</p><p>分析：</p><p>首先考虑如何根据权重比例计算选择下标的概率。先把权重数组中的所有权重加起来得到权重之和，然后用每个权重除以权重之和就能得到每个下标被选择的概率。</p><p>接着考虑如何根据权重比例随机选择一个下标。还是以权重数组[1,2,3,4]为例。先按照等概率生成0到9之间的一个整数p，如果p是0就选择0，p是1或2就选择1，以此类推。</p><p>可以创建另一个和权重数组的长度一样的数组sums，新数组的第i个数值sums[i]是权重数组中前i个数字之和。有了这个数组sums就能很方便地根据等概率随机生成的数字p按照权重比例选择下标。</p><p>sums数组满足递增条件，是排序数组。可以用二分查找法在其中查找需要的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[w.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length; i++) &#123;</span><br><span class="line">            total += w[i];</span><br><span class="line">            sums[i] = total;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> p = random.nextInt(total);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = sums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sums[mid] &gt; p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == <span class="number">0</span> || (sums[mid - <span class="number">1</span>] &lt;= p)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="72-求平方根"><a href="#72-求平方根" class="headerlink" title="#72 求平方根"></a>#72 求平方根</h3><p>输入一个非负整数，请计算它的平方根。正数的平方根有两个，只输出其中的正数平方根。如果平方根不是整数，那么只需要输出它的整数部分。</p><p>例如：</p><p>如果输入4则输出2；如果输入18则输出4。</p><p>分析：</p><p>除0之外，非负整数n的平方根一定在从1到n的范围内，在此范围内应用二分查找。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt;= n / mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid + <span class="number">1</span>) &gt; n / (mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变量mid表示某个范围的中间值。上述代码将mid * mid &lt;= n 写成了mid &lt;= n / mid。虽然这两个不等式在数学上是等价的，但计算mid * mid可能会产生溢出。</strong></p><h3 id="73-狒狒吃香蕉"><a href="#73-狒狒吃香蕉" class="headerlink" title="#73 狒狒吃香蕉"></a>#73 狒狒吃香蕉</h3><p>狒狒很喜欢吃香蕉。一天它发现了n堆香蕉，第i堆有piles[i]根香蕉。门卫刚好走开，H小时后才会回来。狒狒吃香蕉喜欢细嚼慢咽，但又想在门卫回来之前吃完所有的香蕉。请问狒狒每小时至少吃多少根香蕉？如果狒狒决定每小时吃k根香蕉，而它在吃的某一堆剩余的香蕉数目少于k，那么它只会将一堆香蕉吃完，下一个小时才会开始吃另一堆的香蕉。</p><p>例如：</p><p>有4堆香蕉，表示香蕉数目的数组piles为[3,6,7,11]，门卫将于8小时之后回来，那么狒狒每小时吃香蕉的数目为4根。如果它每小时吃4根香蕉，那么它用8小时吃完所有香蕉。如果它每小时只吃3根香蕉，则需要10小时，不能在门卫回来之前吃完。</p><p>分析：</p><p>它每小时至少要吃1根香蕉。由于它一小时内只吃一堆香蕉，因此它每小时吃香蕉数目的上限是最大一堆香蕉的数目，记为max根。</p><p>在此范围内应用二分查找，判断每小时要吃的香蕉数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">        max = Math.max(max, pile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = max;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> hours = getHours(piles, mid);</span><br><span class="line">        <span class="keyword">if</span> (hours &lt;= H) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">1</span> || getHours(piles, mid - <span class="number">1</span>) &gt; H) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHours</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hours = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">        hours += (pile + speed - <span class="number">1</span>) / speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hours;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="74-合并区间"><a href="#74-合并区间" class="headerlink" title="#74 合并区间"></a>#74 合并区间</h3><p>输入一个区间的集合，请将重叠的区间合并。每个区间用两个数字比较，分别表示区间的起始位置和结束位置。</p><p>例如：</p><p>输入区间[[1,3],[4,5],[8,10],[2,6],[9,12],[15,18]], 合并重叠的区间之后得到[[1,6],[8,12],[15,18]]。</p><p>分析：</p><p>如果先将所有区间按照起始位置排序，那么只需要比较相邻两个区间的结束位置就能知道它们是否重叠。如果它们重叠就将他们合并，然后判断合并区间是否和下一个区间重叠。重复这个过程，直到所有重叠的区间都合并为止。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    Arrays.sort(intervals, (i1, i2) -&gt; i1[<span class="number">0</span>] - i2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; merged = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.length) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; intervals.length &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= temp[<span class="number">1</span>]) &#123;</span><br><span class="line">            temp[<span class="number">1</span>] = Math.max(temp[<span class="number">1</span>], intervals[j][<span class="number">1</span>]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        merged.add(temp);</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[merged.size()][];</span><br><span class="line">    <span class="keyword">return</span> merged.toArray(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入数组有n个区间，那么将它排序的时间复杂度是O(nlogn)，接着逐一扫描排序的区间数组并将相邻的区间合并。虽然代码中有嵌套的二重循环，但每个区间只会扫描一次，因此时间复杂度是O(n)。上述算法的总体时间复杂度是O(nlogn)。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="#计数排序"></a>#计数排序</h3><p>计数排序是一种线性时间的整数排序算法。如果数组的长度为n，整数范围(数组中最大整数与最小整数的差值)为k，对于k远小于n的场景(如对某公司所有员工的年龄排序)，那么计数排序的时间复杂度优于其他基于比较的排序算法(如归并排序、快速排序等)。</p><p>计数排序的参考代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        counts[num - min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = min; num &lt;= max; num++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (counts[num - min] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i++] = num;</span><br><span class="line">            counts[num - min]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果数组的长度是n，整数的范围是k，那么计数排序的**时间复杂度就是O(n+k)<strong>。由于需要创建一个长度为O(k)的辅助数组counts，因此</strong>空间复杂度是O(k)**。当k较小时，无论从时间复杂度还是空间复杂度来看计数排序都是非常高效的算法。当k很大时，计数排序可能就不如其他排序算法高效。</p><h3 id="75-数组相对排序"><a href="#75-数组相对排序" class="headerlink" title="#75 数组相对排序"></a>#75 数组相对排序</h3><p>输入两个数组arr1和arr2，其中数组arr2中的每个数字都唯一，并且都是数组arr1中的数字。请将数组arr1中的数字按照数组arr2中的数字的相对顺序排序。如果数组arr1中的数字再数组arr2中没有出现，那么将这些数字按递增的顺序排在后面。假设数组中的所有数字都在0到1000的范围内。</p><p>例如：</p><p>输入的数组arr1和arr2分别是[2,3,3,7,3,9,2,1,7,2]，和[3,2,1]，则数组arr1排序之后为[3,3,3,2,2,2,1,7,7,9]。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr1) &#123;</span><br><span class="line">        counts[num]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr2) &#123;</span><br><span class="line">        <span class="keyword">while</span> (counts[num] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr1[i] = num;</span><br><span class="line">            i++;</span><br><span class="line">            counts[num]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; counts.length; num++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (counts[num] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr1[i] = num;</span><br><span class="line">            i++;</span><br><span class="line">            counts[num]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果数组arr1的长度为m，数组arr2的长度为n，那么时间复杂度时O(m+n)。辅助数组counts的长度为1001，是一个常数，因此空间复杂度可以认为是O(1)。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="#快速排序"></a>#快速排序</h3><p>快速排序是一种非常高效的算法，从其名字可以看出这种排序算法最大的特点就是快。当表现良好时，快速排序的速度比其他主要对手(如归并排序)快2~3倍。</p><p>快速排序的基本思想是分治法，排序过程如下：在输入数组中随机选取一个元素作为中间值(pivot)，然后对数组进行分区(partition)，使所有比中间值小的数据移到数组的左边，所有比中间值大的数据移到数组的右边。接下来对中间值左右两侧的子数组用相同的步骤排序，直到子数组中只有一个数字为止。</p><p>递归代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    quicksort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &gt; start) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(nums, start, end);</span><br><span class="line">        quicksort(nums, start, pivot - <span class="number">1</span>);</span><br><span class="line">        quicksort(nums, pivot + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nextInt(end - start + <span class="number">1</span>) + start;</span><br><span class="line">    swap(nums, random, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[end]) &#123;</span><br><span class="line">            small++;</span><br><span class="line">            swap(nums, i, small);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    small++;</span><br><span class="line">    swap(nums, small, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 != index2) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序的时间复杂度取决于所选取的中间值在数组中的为止。如果每次选取的中间值在排序数组中都接近数组中间的为止，那么快速排序的时间复杂度是O(nlogn)。如果每次选取的中间值都位于排序数组的头部或尾部，那么快速排序的时间复杂度是O(n^2)。这也是随机选取中间值的原因，避免在某些情况下快速排序退化成时间复杂度为O(n^2)的算法。在随机选取中间值的前提下，**快速排序的平均时间复杂度是O(nlogn)**。</p><h3 id="76-数组中第k大的数字"><a href="#76-数组中第k大的数字" class="headerlink" title="#76 数组中第k大的数字"></a>#76 数组中第k大的数字</h3><p>请从一个乱序数组中找出第k大的数字。</p><p>例如，数组[3,1,2,4,5,6]中第3大的数字是5。</p><p>分析：</p><p>面试题59中介绍过一种基于最小堆的解法。此种解法的时间复杂度是O(nlogk)，空间复杂度是O(k)。</p><p>但59题中的数据位于一个数据流中，不能一次性地将所有数据全部读入内存。但本题不同，数据都保存在一个数组中，所有操作都在内存中完成。因此有更快找出第k大的数字的算法。</p><p>在长度为n的排序数组中，第k大的数字的下标是n-k。可以用快速排序的函数partition对数组分区，如果函数partition选取的中间值在分区之后的下标正好是n-k，那么它就是第k大的数字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> target = nums.length - k;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(nums, start, end);</span><br><span class="line">    <span class="keyword">while</span> (index != target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; target) &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index = partition(nums, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nextInt(end - start + <span class="number">1</span>) + start;</span><br><span class="line">    swap(nums, random, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[end]) &#123;</span><br><span class="line">            small++;</span><br><span class="line">            swap(nums, i, small);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    small++;</span><br><span class="line">    swap(nums, small, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 != index2) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="#归并排序"></a>#归并排序</h3><p>归并排序也是一种基于分治法的排序算法。为了排序长度为n的数组，需要先排序两个长度为n/2的子数组，然后合并这两个排序的子数组，于是整个数组也就排序完毕。归并排序可以用迭代代码实现，也可以用递归代码实现。</p><p>递归代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray1(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] src = nums;</span><br><span class="line">    <span class="keyword">int</span>[] dst = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="comment">// 归</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; length; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; length; start += seg * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = Math.min(start + seg, length);</span><br><span class="line">            <span class="keyword">int</span> end = Math.min(start + seg * <span class="number">2</span>, length);</span><br><span class="line">            <span class="keyword">int</span> i = start, j = mid, k = start;</span><br><span class="line">            <span class="comment">// 并</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; mid || j &lt; end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == end || (i &lt; mid &amp;&amp; src[i] &lt; src[j])) &#123;</span><br><span class="line">                    dst[k++] = src[i++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dst[k++] = src[j++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] temp = src;</span><br><span class="line">        src = dst;</span><br><span class="line">        dst = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray2(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] dst = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dst = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    mergeSort(nums, dst, <span class="number">0</span>, nums.length);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span>[] dst, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分组少了两个节点</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">1</span> &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(dst, src, start, mid);</span><br><span class="line">    mergeSort(dst, src, mid, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start, j = mid, k = start;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid || j &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == end || (i &lt; mid &amp;&amp; src[i] &lt; src[j])) &#123;</span><br><span class="line">            dst[k++] = src[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dst[k++] = src[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的**时间复杂度是O(nlogn)<strong>。需要创建一个长度为n的辅助数组。如果递归实现归并排序，那么递归调用栈需要O(logn)的空间。因此，归并排序的</strong>空间复杂度是O(n)**。</p><h3 id="77-链表排序"><a href="#77-链表排序" class="headerlink" title="#77 链表排序"></a>#77 链表排序</h3><p>输入一个链表的头节点，请将该链表排序。</p><p>分析：</p><p>由于题目没有限定数字的范围，因此计数排序就不太合适。可以考虑使用插入排序、冒泡排序等算法对链表进行排序，只是这些算法的时间复杂度是O(n^2)，并不高效。</p><p>可以创建一个长度为n的数组来实现堆，也就是说，通过O(n)的空间代价来实现堆排序。</p><p>如果使用快速排序，那么需要O(n)的时间才能根据节点的编号找到对应的节点。如果始终以某个固定位置的值作为中间值，可能会导致每次分区时两个子链表的大小都不均衡，从而使时间复杂度退化为O(n^2)。因此，虽然可以用快速排序算法对链表进行排序，但不如对数组排序高效。</p><p>接下来考虑归并排序算法。借由双指针，可以将链表分成两半。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分组少于两个节点</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode head1 = head;</span><br><span class="line">    ListNode head2 = split(head);</span><br><span class="line"></span><br><span class="line">    head1 = sortList(head1);</span><br><span class="line">    head2 = sortList(head2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(head1, head2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">split</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode second = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.val &lt; head2.val) &#123;</span><br><span class="line">            cur.next = head1;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = head2;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur.next = head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="78-合并排序链表"><a href="#78-合并排序链表" class="headerlink" title="#78 合并排序链表"></a>#78 合并排序链表</h3><p>输入k个排序的链表，请将它们合并成一个排序的链表。</p><p>思路1：利用最小堆选取值最小的节点。用k个指针分别指向k个链表的头节点，用一个大小为k的堆存储这些节点的值。通过操作此堆完成排序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists1</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((n1, n2)</span><br><span class="line">                                                          -&gt; n1.val - n2.val);</span><br><span class="line">    <span class="keyword">for</span> (ListNode list : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minHeap.offer(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">        ListNode least = minHeap.poll();</span><br><span class="line">        cur.next = least;</span><br><span class="line">        cur = least;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (least.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minHeap.offer(least.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设k个排序链表总共有n个节点。如果堆的大小为k，那么**空间复杂度就是O(k)<strong>。每次用最小堆处理一个节点需要O(logk)的时间，因此这种解法的</strong>时间复杂度是O(nlogk)**。</p><p>思路2：按照归并排序的思路合并链表。输入的k个排序链表可以分成两部分，前k/2个链表和后k/2个链表。如果将前k/2个链表和后k/2个链表分别合并成两个排序的链表，再将两个排序的链表合并，那么所有链表都合并了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists2</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mergeLists(lists, <span class="number">0</span>, lists.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeLists</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分组中只有一个链表</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">1</span> == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    ListNode head1 = mergeLists(lists, start, mid);</span><br><span class="line">    ListNode head2 = mergeLists(lists, mid, end);</span><br><span class="line">    <span class="keyword">return</span> merge(head1, head2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.val &lt; head2.val) &#123;</span><br><span class="line">            cur.next = head1;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = head2;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur.next = head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的递归调用的深度是O(logk)，每次需要合并n个节点，因此**时间复杂度是O(nlogk)<strong>。</strong>空间复杂度是O(nlogk)**，来维护递归调用栈。</p><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯法可以看作蛮力法的升级版，它在解决问题时的每一步都尝试所有可能的选项，最终找出所有可行的解决方案。<strong>回溯法解决问题的过程可以形象地用一个树形结构表示。</strong></p><p>由于回溯法实在所有选项形成的树上进行深度优先遍历，如果解决问题的步骤较多或每个步骤都面临多个选项，那么遍历整棵树将需要较多的时间。如果明确知道某些子树没有必要遍历，那么再遍历的时候应该避开这些子树以优化效率**(剪枝)**。</p><h3 id="79-所有子集"><a href="#79-所有子集" class="headerlink" title="#79 所有子集"></a>#79 所有子集</h3><p>输入一个不含重复数字的数据集合，请找出它的所有子集。</p><p>例如：</p><p>数据集合[1,2]有4个子集，分别是[]、[1]、[2]和[1,2]。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    helper(nums, <span class="number">0</span>, <span class="keyword">new</span> LinkedList&lt;Integer&gt;(), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, LinkedList&lt;Integer&gt; subset, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(subset));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; nums.length) &#123;</span><br><span class="line">        helper(nums, index + <span class="number">1</span>, subset, result);</span><br><span class="line"></span><br><span class="line">        subset.add(nums[index]);</span><br><span class="line">        helper(nums, index + <span class="number">1</span>, subset, result);</span><br><span class="line">        subset.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入的集合中有n个元素，由于每个元素都有2个选项，因此**总的时间复杂度是O(2^n)**。</p><h3 id="80-包含k个元素的集合"><a href="#80-包含k个元素的集合" class="headerlink" title="#80 包含k个元素的集合"></a>#80 包含k个元素的集合</h3><p>输入n和k，请输出从1到n中选取k个数字组成所有的组合。</p><p>例如：</p><p>如果n等于3，k等于2，将组成3个组合，分别是[1,2],[1,3]和[2,3]。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; combination = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(n, k, <span class="number">1</span>, combination, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> i, LinkedList&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (combination.size() == k) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= n) &#123;</span><br><span class="line">        helper(n, k, i + <span class="number">1</span>, combination, result);</span><br><span class="line"></span><br><span class="line">        combination.add(i);</span><br><span class="line">        helper(n, k, i + <span class="number">1</span>, combination, result);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="81-允许重复选择元素的集合"><a href="#81-允许重复选择元素的集合" class="headerlink" title="#81 允许重复选择元素的集合"></a>#81 允许重复选择元素的集合</h3><p>给定一个没有重复数字的正整数集合，请找出所有元素之和等于某个给定值的所有组合。同一个数字可以在组合中出现任意次。</p><p>例如，</p><p>输入整数集合[2,3,5]，元素之和等于8的组合有3个，分别是[2,2,2,2]，[2,3,3]，[3,5]。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; combination = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(nums, target, <span class="number">0</span>, combination, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> i, LinkedList&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; <span class="number">0</span> &amp;&amp; i &lt; nums.length) &#123;</span><br><span class="line">        helper(nums, target, i + <span class="number">1</span>, combination, result);</span><br><span class="line"></span><br><span class="line">        combination.add(nums[i]);</span><br><span class="line">        helper(nums, target - nums[i], i, combination, result);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="82-包含重复元素集合的组合"><a href="#82-包含重复元素集合的组合" class="headerlink" title="#82 包含重复元素集合的组合"></a>#82 包含重复元素集合的组合</h3><p>给定一个可能包含重复数字的整数集合，请找出所有元素之和等于某个给定值的所有组合。输出中不得包含重复的组合。</p><p>例如，</p><p>输入整数集合[2,2,2,4,3,3]，元素之和等于8的组合有2个，分别是[2,2,4]和[2,3,3]。</p><p>分析：</p><p>避免重复的组合的方法是当某一步决定跳过值为m的数字时，跳过所有值为m的数字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; combination = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(nums, target, <span class="number">0</span>, combination, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> i, LinkedList&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; <span class="number">0</span> &amp;&amp; i &lt; nums.length) &#123;</span><br><span class="line">        helper(nums, target, getNext(nums, i), combination, result);</span><br><span class="line"></span><br><span class="line">        combination.add(nums[i]);</span><br><span class="line">        helper(nums, target - nums[i], i + <span class="number">1</span>, combination, result);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next = index;</span><br><span class="line">    <span class="keyword">while</span> (next &lt; nums.length &amp;&amp; nums[next] == nums[index]) &#123;</span><br><span class="line">        next++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="83-没有重复元素集合的全排列"><a href="#83-没有重复元素集合的全排列" class="headerlink" title="#83 没有重复元素集合的全排列"></a>#83 没有重复元素集合的全排列</h3><p>给定一个没有重复数字的集合，请找出它的所有全排列。</p><p>例如，集合[1,2,3]有6个全排列。分别是[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(nums, <span class="number">0</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        List&lt;Integer&gt; permutation = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            permutation.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(permutation);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            helper(nums, i + <span class="number">1</span>, result);</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="84-包含重复元素集合的全排列"><a href="#84-包含重复元素集合的全排列" class="headerlink" title="#84 包含重复元素集合的全排列"></a>#84 包含重复元素集合的全排列</h3><p>给定一个包含重复数字的集合，请找出它的所有全排列。</p><p>例如，</p><p>集合[1,1,2]有3个全排列，分别是[1,1,2],[1,2,1],[2,1,1]。</p><p>分析：</p><p>如果已经将某个值为m的数字交换为排列的第i个数字，那么再遇到其他值为m的数字就跳过。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(nums, <span class="number">0</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        List&lt;Integer&gt; permutation = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            permutation.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.add(permutation);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(nums[j])) &#123;</span><br><span class="line">                set.add(nums[j]);</span><br><span class="line"></span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                helper(nums, i + <span class="number">1</span>, result);</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="85-生成匹配的括号"><a href="#85-生成匹配的括号" class="headerlink" title="#85 生成匹配的括号"></a>#85 生成匹配的括号</h3><p>输入一个正整数n，请输出所有包含n个左括号和n个右括号的组合，要求每个组合的左括号和右括号匹配。</p><p>例如，当n等于2时，有两个符合条件的括号组合，分别是”(())”和”()()”。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(n, n, <span class="string">&quot;&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String parenthesis, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">        result.add(parenthesis);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        helper(left - <span class="number">1</span>, right, parenthesis + <span class="string">&quot;(&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        helper(left, right - <span class="number">1</span>, parenthesis + <span class="string">&quot;)&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="86-分割回文字符串"><a href="#86-分割回文字符串" class="headerlink" title="#86 分割回文字符串"></a>#86 分割回文字符串</h3><p>输入一个字符串，要求将它分割成若干子字符串，使每个子字符串都是回文。请列出所有可能的分割方法。</p><p>例如，输入”google”，将输出3种符合条件的分割方法，分别是[“g”, “o”, “o”, “g”, “l”, “e”]，[“g”, “oo”, “g”, “l”, “e”]，</p><p>[“goog”, “l”, “e”]。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(s, <span class="number">0</span>, <span class="keyword">new</span> LinkedList&lt;&gt;(), result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String str, <span class="keyword">int</span> start, LinkedList&lt;String&gt; substrings, List&lt;List&lt;String&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == str.length()) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(substrings));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(str, start, i)) &#123;</span><br><span class="line">            substrings.add(str.substring(start, i + <span class="number">1</span>));</span><br><span class="line">            helper(str, i + <span class="number">1</span>, substrings, result);</span><br><span class="line">            substrings.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(start++) != str.charAt(end--)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="87-恢复IP地址"><a href="#87-恢复IP地址" class="headerlink" title="#87 恢复IP地址"></a>#87 恢复IP地址</h3><p>输入一个只包含数字的字符串，请列出所有可能的恢复出来的IP地址。</p><p>例如，输入字符串”10203040”，可能恢复出3个IP地址，分别为”10.20.30.40”、”102.0.30.40”、”10.203.0.40”。</p><p>分析：</p><p>根据IP地址的特点，一个IP地址被三个’.’字符分隔成4段，每段是从0到255之间的一个数字。另外，除”0”本身外，其他数字不能以’0’开头。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(s, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> segI, String seg, String ip, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == s.length() &amp;&amp; segI == <span class="number">3</span> &amp;&amp; isValidSeg(seg)) &#123;</span><br><span class="line">        result.add(ip + seg);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; s.length() &amp;&amp; segI &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">        <span class="comment">// 将当前字符拼接到当前分段数字的末尾</span></span><br><span class="line">        <span class="keyword">if</span> (isValidSeg(seg + ch)) &#123;</span><br><span class="line">            helper(s, i + <span class="number">1</span>, segI, seg + ch, ip, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前字符作为新的分段的开始</span></span><br><span class="line">        <span class="keyword">if</span> (seg.length() &gt; <span class="number">0</span> &amp;&amp; segI &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            helper(s, i + <span class="number">1</span>, segI + <span class="number">1</span>, <span class="string">&quot;&quot;</span> + ch, ip + seg + <span class="string">&quot;.&quot;</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidSeg</span><span class="params">(String seg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(seg) &lt;= <span class="number">255</span> &amp;&amp; (seg.equals(<span class="string">&quot;0&quot;</span>) || seg.charAt(<span class="number">0</span>) != <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归函数helper的参数i是字符串s中当前被处理的字符的下标。参数segI是当前分段数字的下标，由于IP地址有4个分段数字，因此参数segI的取值范围是从0到3。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>用动态规划解决问题的第1步是识别哪些问题适合运用动态规划。和适合运用回溯法的问题类似，适用动态规划的问题都存在若干步骤，并且每个步骤都面临若干选择。如果题目要求列举出所有的解，那么很有可能需要用回溯法解决。<strong>如果题目是求一个问题的最优解(通常是求最大值或最小值)，或者求问题的解的数目(或判断问题是否存在解)，那么这个题目有可能适合运用动态规划。</strong></p><p>采用动态规划时总是用递归的思路分析问题，即把大问题分解成小问题，再把小问题的解合起来形成大问题的解。如果将大问题分解成若干小问题之后，小问题相互重叠，那么直接用递归的代码实现就会存在大量的重复计算。<strong>小问题之间存在重叠部分，这是可以用动态规划求解问题的另一个显著特点。</strong></p><h3 id="88-爬楼梯的最少成本"><a href="#88-爬楼梯的最少成本" class="headerlink" title="#88 爬楼梯的最少成本"></a>#88 爬楼梯的最少成本</h3><p>一个数组cost的所有数字都是正数，它的第i个数字表示在一个楼梯的第i级台阶往上爬的成本，在支付了成本cost[i]之后可以从第i级台阶往上爬1级或2级。假设台阶上至少有2级，既可以从第0级台阶出发，也可以从第1级台阶出发，请计算爬上该楼梯的最少成本。</p><p>例如，输入数组[1,100,1,1,100,1]，则爬上该楼梯的最少成本时4，分别经过下标为0、2、3、5的这4级台阶。</p><p>分析：确定状态转移方程。</p><p>可以用函数f(i)表示从楼梯的第i级台阶再往上爬的最少成本。由于一次可以爬1级或2级台阶，即f(n-1)和f(n-2)的最小值就是这个问题的最优解。</p><p>状态转移方程: f(i)=min(f(i-1),f(i-2))+cost[i]。</p><p>递归代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs1</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = cost.length;</span><br><span class="line">    <span class="keyword">return</span> Math.min(helper1(cost, len - <span class="number">2</span>), helper1(cost, len - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper1</span><span class="params">(<span class="keyword">int</span>[] cost, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cost[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(helper1(cost, i - <span class="number">2</span>), helper1(cost, i - <span class="number">1</span>)) + cost[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然直观，但是存在大量重复计算，效率不高。</p><p>使用缓存的递归代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs2</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    helper2(cost, len - <span class="number">1</span>, dp);</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[len - <span class="number">2</span>], dp[len - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper2</span><span class="params">(<span class="keyword">int</span>[] cost, <span class="keyword">int</span> i, <span class="keyword">int</span>[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        dp[i] = cost[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        helper2(cost, i - <span class="number">2</span>, dp);</span><br><span class="line">        helper2(cost, i - <span class="number">1</span>, dp);</span><br><span class="line">        dp[i] = Math.min(dp[i - <span class="number">2</span>], dp[i - <span class="number">1</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**时间复杂度O(n)<strong>。同时，需要一个长度为n的数组，因此</strong>空间复杂度也是O(n)**。</p><p>空间复杂度为O(n)的迭代代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs3</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i - <span class="number">2</span>], dp[i - <span class="number">1</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[len - <span class="number">2</span>], dp[len - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>空间复杂度为O(1)的迭代代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs4</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cost[<span class="number">0</span>], cost[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">        dp[i % <span class="number">2</span>] = Math.min(dp[<span class="number">0</span>], dp[<span class="number">1</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，数组dp的长度时2，求解的f(i)的结果保存在数组下标为”i%2”的位置。</p><h3 id="89-房屋偷盗"><a href="#89-房屋偷盗" class="headerlink" title="#89 房屋偷盗"></a>#89 房屋偷盗</h3><p>输入一个数组表示某条街上的一排房屋内财产的数量。如果这条街上相邻的两幢房屋被盗就会自动触发报警系统。请计算小偷在这条街上最多能偷取到多少财产。</p><p>例如，街道上有5幢房屋，房屋内的财产用数组[2,3,4,5,3]表示，那么他能偷取到的最多的财务是9。</p><p>分析：</p><p>f(i)表示小偷从标号为0的房屋开始到标号为i的房屋为止能偷取到的财务的最大值。</p><p>状态转移方程：f(i)=max(f(i-2)+nums[i],f(i-1))</p><p>带缓存的递归代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    helper1(nums, nums.length - <span class="number">1</span>, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span>[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i] = nums[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        dp[i] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        helper1(nums, i - <span class="number">2</span>, dp);</span><br><span class="line">        helper1(nums, i - <span class="number">1</span>, dp);</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(n)。</p><p>空间复杂度为O(n)的迭代代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度为O(1)的迭代代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i % <span class="number">2</span>] = Math.max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>], dp[(i - <span class="number">2</span>) % <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[(nums.length - <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用两个状态转移方程解决问题。定义两个表达式f(i)，g(i)，其中f(i)表示小偷选择不进入标号为i的房屋偷东西时能偷得的最多财物数量，g(i)表示小偷选择进入标号为i的房屋偷东西时能偷得得最多财物数量。因此，f(n-1)和g(n-1)的最大值就是小偷能从n幢房屋内偷得的财物得最大值。</p><p>定义状态转移方程：</p><p>f(i) = max(f(i-1),g(i-1))</p><p>g(i) = f(i-1) + nums[i-1]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob4</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i % <span class="number">2</span>] = Math.max(dp[<span class="number">0</span>][(i - <span class="number">1</span>) % <span class="number">2</span>], dp[<span class="number">1</span>][(i - <span class="number">1</span>) % <span class="number">2</span>]);</span><br><span class="line">        dp[<span class="number">1</span>][i % <span class="number">2</span>] = dp[<span class="number">0</span>][(i - <span class="number">1</span>) % <span class="number">2</span>] +nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[<span class="number">0</span>][(len - <span class="number">1</span>) % <span class="number">2</span>], dp[<span class="number">1</span>][(len - <span class="number">1</span>) % <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n)，<strong>空间复杂度为O(1)。但实际使用得辅助空间比上一种方法多了一倍</strong>。</p><h3 id="90-环形房屋偷盗"><a href="#90-环形房屋偷盗" class="headerlink" title="#90 环形房屋偷盗"></a>#90 环形房屋偷盗</h3><p>一条环形街道上有若干房屋。输入一个数组表示该条街道上得房屋内财产的数量。如果这条街道上相邻的两幢房屋被盗就会自动触发报警系统。请计算小偷在这条街道上最多能偷取的财产的数量。</p><p>分析：</p><p>这个问题与#89题的区别在于小偷不能同时到标号为0和n-1这两幢房屋内偷东西。如果他考虑去标号为0的房屋，那么他一定不能去标号为n-1的房屋；反之亦然。因此，可以将这个问题分解成两个子问题，分别求小偷从标号0<del>n-2的房屋内偷得的最多财物数量，和从标号1</del>n-1的房屋内偷得的最多财物数量。这两个问题提解的最大值就是此问题的解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result1 = helper(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> result2 = helper(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(result1, result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[start];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="comment">// 确保从第0个位置开始更新</span></span><br><span class="line">        <span class="keyword">int</span> j = i - start;</span><br><span class="line">        dp[j % <span class="number">2</span>] = Math.max(dp[(j - <span class="number">1</span>) % <span class="number">2</span>], dp[(j - <span class="number">2</span>) % <span class="number">2</span>] + nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[(end - start) % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="91-粉刷房子"><a href="#91-粉刷房子" class="headerlink" title="#91 粉刷房子"></a>#91 粉刷房子</h3><p>一排n幢房子要刷成红色、绿色和蓝色，不同房子被粉刷成不同颜色的成本不同。用一个nx3的数组表示n幢房子分别用3种颜色粉刷的成本。要求任意相邻的两幢房子的颜色都不一样，请分别计算这n幢房子的最少成本。</p><p>例如，粉刷3幢房子的成本分别为[[17,2,16],[15,14,5],[13,3,1]]，粉刷的最少成本是10。</p><p>分析：</p><p>用r(i), g(i), b(i)分别表示将标号为i的房子粉刷成红色、绿色和蓝色时粉刷标号从0到i的i+1幢房子的最少成本。</p><p>r(i) = min(g(i-1),b(i-1))+cost[i][0]</p><p>g(i) = min(r(i-1),b(i-1))+cost[i][1]</p><p>b(i) = min(r(i-1),g(i-1))+cost[i][2]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        dp[j][<span class="number">0</span>] = costs[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev1 = dp[(j+<span class="number">2</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> prev2 = dp[(j+<span class="number">1</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">            dp[j][i%<span class="number">2</span>] = Math.min(prev1, prev2) + costs[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> last = (costs.length - <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[<span class="number">0</span>][last], Math.min(dp[<span class="number">1</span>][last], dp[<span class="number">2</span>][last]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="92-翻转字符"><a href="#92-翻转字符" class="headerlink" title="#92 翻转字符"></a>#92 翻转字符</h3><p>输入一个只包含’0’和’1’的字符串，其中’0’可以翻转成’1’，’1’可以翻转成’0’。请问至少需要翻转几个字符，才可以使翻转之后的字符串中所有的’0’位于’1’的前面？翻转之后的字符串可能只包含字符’0’或’1’。</p><p>例如：输入字符串”00110”，至少需要翻转一个字符才能使所有的’0’位于’1’的前面。</p><p>分析：</p><p>由于翻转下标为i的字符依赖于前i个字符翻转之后最后一个字符是’0’还是’1’，因此要分两种情况讨论。假设函数f(i)表示把字符串从下标为0的字符到下标为i的字符编程符合要求的字符串且最后一个字符是’0’所需要的最少翻转次数。g(i)类似，只不过最后一个字符是’1’。</p><p>当字符i是’0’时</p><ul><li>f(i) = f(i-1)</li><li>g(i) = min[f(i-1),g(i-1)]+1</li></ul><p>当字符i是’1’时</p><ul><li>f(i) = f(i-1) + 1</li><li>g(i) = min[f(i-1),g(i-1)]</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFlipsMonoIncr</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> ch = s.charAt(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = ch == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = ch == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ch = s.charAt(i);</span><br><span class="line">        <span class="keyword">int</span> prev0 = dp[<span class="number">0</span>][(i-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> prev1 = dp[<span class="number">1</span>][(i-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][i%<span class="number">2</span>] = prev0 + (ch == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">1</span>][i%<span class="number">2</span>] = Math.min(prev0, prev1) + (ch == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> last = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[<span class="number">0</span>][last%<span class="number">2</span>], dp[<span class="number">1</span>][last%<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度O(n)，空间复杂度O(1)。</strong></p><h3 id="93-最长斐波那契数列"><a href="#93-最长斐波那契数列" class="headerlink" title="#93 最长斐波那契数列"></a>#93 最长斐波那契数列</h3><p>输入一个没有重复数字的单调递增的数组，数组中至少有3个数字，请问数组中最长的斐波那契数列的长度是多少？</p><p>例如：如果输入的数组是[1,2,3,4,5,6,7,8]，由于其中最长的斐波那契数列是1、2、3、5、8，因此输出是5。</p><p>分析：</p><p>由于以A[i]为结尾的斐波那契数列的长度依赖于它前一个数字A[j]，不同的A[j]能和A[i]形成不同的斐波那契数列，它们的长度也可能不同。因此，状态转移方程有两个参数i和j，f(i,j)表示以A[i]为最后一个数字，A[j]为倒数第2个数字的斐波那契数列的长度。如果数组中存在一个数字k，使A[i] = A[j] + A[k](0&lt;=k&lt;j&lt;i)，那么f(i,j)=f(j,k)+1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        map.put(A[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][A.length];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = map.getOrDefault(A[i] - A[j], -<span class="number">1</span>);</span><br><span class="line">            dp[i][j] = k &gt;= <span class="number">0</span> &amp;&amp; k &lt; j ? dp[j][k] + <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            result = Math.max(result, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result &gt; <span class="number">2</span> ? result : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码用到了二重循环，因此**时间复杂度是O(n^2)<strong>。由于使用了一个大小为O(n^2)的二维数组和一个大小为O(n)的哈希表，因此</strong>空间复杂度也是O(n^2)**。</p><h3 id="94-最少回文分割"><a href="#94-最少回文分割" class="headerlink" title="#94 最少回文分割"></a>#94 最少回文分割</h3><p>输入一个字符串，请问至少需要几次分割才可以使分割出的每个字符串都是回文？</p><p>例如：输入字符串”aaba”，至少需要分割1次，从两个相邻字符’a’中间切一刀将字符串分割成两个回文子字符串”a”和”aba”。</p><p>分析：</p><p>用f(i)表示从下标为0到i的子字符串S[0..i]的符合条件的最少分割次数。如果子字符串S[0..i]本身就是一个回文，那么不需要分割就符合要求，此时f(i)等于0。如果子字符串S[0..i]不是一个回文，那么对每个下标j(1&lt;=j&lt;=i)逐一判断子字符串S[j..i]是不是回文。如果是回文，那么这就是一个有效的分割方法，此时的分割次数相当于子字符串S[0..j-1]的分割次数再加1。因此，f(i)就是所有符合条件的j对应的f(i-1)的最小值加1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] isPal = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> ch2 = s.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (ch1 == ch2 &amp;&amp; (i &lt;= j + <span class="number">1</span>) || isPal[j+<span class="number">1</span>][i-<span class="number">1</span>]) &#123;</span><br><span class="line">                isPal[j][i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPal[<span class="number">0</span>][i]) &#123;</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPal[j][i]) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了优化时间复杂度，上述代码需要预处理，先判断所有子字符串S[j..i]是不是回文，并将子字符串是否为回文的结果保存在”isPal[j][i]”中。判断子字符串S[j..i]是否为回文的标准使字符S[j]和S[i]相同，并且子字符串S[j+1][i-1]也是回文。优化之后只需要O(1)的时间就能判断子字符串S[j..i]是不是回文。</p><p>长度为n的子字符串有O(n^2)个子字符串，因此需要至少O(n^2)的时间才能判断所有的子字符串是不是回文。低2个二重循环是为了计算状态转移方程，时间复杂度也是O(n^2)。因此，上述解法的**总体时间复杂度是O(n^2)**。</p><p>上述代码使用了两个数组，一个是大小为O(n^2)的二维数组isPal，另一个是大小为O(n)的一维数组dp，因此<strong>总的空间复杂度是O(n^2)<strong>。正常求回文串的算法时间复杂度是O(n)，可以用一个大小为O(n^2)的数组将时间复杂度从O(n^3)优化到O(n^2)，因此</strong>这种优化是用空间换时间</strong>。</p><h3 id="95-最长公共子序列"><a href="#95-最长公共子序列" class="headerlink" title="#95 最长公共子序列"></a>#95 最长公共子序列</h3><p>输入两个字符串，请求出它们的最长公共子序列的长度。如果从字符串s1中删除若干字符之后能得到字符串s2，那么字符串s2就是字符串s1的一个子序列。</p><p>例如，从字符串”abcde”中删除两个字符之后能得到字符串”ace”，因此字符串”ace”是字符串”abcde”的一个子序列。但字符串”aec”不是字符串”abcde”的子序列。如果输入字符串”abcde”和”badfe”，呢么它们的最长公共子序列是”bde”，因此输出3。</p><p>分析：</p><p>用函数f(i,j)表示第1个字符串中下标从0到i的子字符串和第2个字符串中下标从0到j的最长公共子序列的长度。</p><p>可以将这个问题的状态转移方程总结为:</p><ul><li>f(i,j) = f(i-1,j-1)+1 (s1[i]==s2[j])</li><li>f(i,j) = max(f(i-1,j),f(i,j-1)) (s1[i] != s2[j])</li></ul><p>当上述状态转移方程的i或j等于0时，即求f(0,j)或f(i,0)时可能需要f(-1,j)或f(i,-1)的值。-1表示空串。任意空字符串和另一个字符串的公共子序列的长度都是0，所以f(-1,j)和f(i,-1)的值都等于0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence1</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i) == text2.charAt(j)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.max(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设两字符串的长度分别为m、n</p><p>f(i,j)的值保存在dp[i+1][j+1]中，这种解法的**空间复杂度是O(mn)**。</p><p>接着用二重循环填充数组dp中的每个数值，循环体内时按照状态转移方程写出的代码。这种解法的**时间复杂度是O(mn)**。</p><p>优化空间效率，只保存表格中的两行：</p><p>f(i,j)的值依赖于表格中左上角f(i-1,j-1)的值、正上方f(i-1,j)的值和同一行左边f(i,j-1)的值。由于计算f(i,j)时只需要使用上方一行的值和同一行左边的值，因此实际上只需要保存表格中的两行就可以。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubquence2</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line">    <span class="comment">// 保证长的字符串在前</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">return</span> longestCommonSubquence2(text2, text1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i) == text2.charAt(j)) &#123;</span><br><span class="line">                dp[(i+<span class="number">1</span>)%<span class="number">2</span>][j+<span class="number">1</span>] = dp[i%<span class="number">2</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[(i+<span class="number">1</span>)%<span class="number">2</span>][j+<span class="number">1</span>] = Math.max(dp[i%<span class="number">2</span>][j+<span class="number">1</span>], dp[(i+<span class="number">1</span>)%<span class="number">2</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len1%<span class="number">2</span>][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于数组dp的行数是一个常数，因此此时**空间复杂度是O(min(m,n))<strong>。由于仍然需要二重循环，因此</strong>时间复杂度仍然是O(mn)**。</p><p>进一步优化空间效率，只需要一个一维数组：</p><p>为了让一个一维数组保存表格中的两行信息，一维数组的每个位置需要保存原来表格中上下两格的信息，即f(i,j)和f(i-1,j)都保存在数组dp下标j+1的位置。在计算f(i,j)之前，dp[j+1]中保存的是f(i-1,j)的值，在完成f(i,j)的计算之后，dp[j+1]被f(i,j)的值替换。</p><p>需要注意的是，在计算f(i,j+1)时，可能还需要f(i-1,j)的值，因此在<strong>计算f(i,j)之后不能直接用f(i,j)的值替换dp[j+1]中f(i-1,j)的值</strong>。可以先将这个值临时保存起来，这样在下一步计算时还能用到。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence3</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line">    <span class="comment">// 保证长的字符串在前</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">return</span> longestCommonSubsequence3(text2, text1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i) == text1.charAt(j)) &#123;</span><br><span class="line">                cur = prev + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = Math.max(dp[j], dp[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prev = dp[j + <span class="number">1</span>];</span><br><span class="line">            dp[j + <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量prev保存的是f(i-1,j-1)的值。</p><p>在代码cur = Math.max(dp[j], dp[j+1])中，dp[j]对应的是f(i,j-1)，而dp[j+1]对应的是f(i-1,j)。</p><p><strong>虽然再次优化后的空间复杂度仍然是O(min(m,n))，但是所需的辅助空间减少到之前的一半。</strong></p><h3 id="96-字符串交织"><a href="#96-字符串交织" class="headerlink" title="#96 字符串交织"></a>#96 字符串交织</h3><p>输入3个字符串s1,s2,s3,请判断字符串s3能不能由字符串s1和s2交织而成，即字符串s3的所有字符串都是字符串s1或s2中的字符，字符串s1和s2中的字符都将出现在字符串s3中且相对位置不变。</p><p>例如：字符串”aadbbcbcac”可以由字符串”aabcc”和”dbbca”交织而成。</p><p>分析：</p><p>如果字符串的s1的长度为m，字符串s2的长度为n，那么它们交织得到的字符串s3的长度一定是m+n。</p><p>可以用函数f(i,j)表示字符串s1[0..i]和字符串s2[0..j]能否交织得到字符串s3[0..i+j+1]。</p><p>状态转移方程：</p><ul><li>f(i,j) = f(i-1,j) if {s3[i+j+1] = s1[i]}</li><li>f(i,j) = f(i,j-1) if {s3[i+j+1] = s2[j]}</li><li>f(i,j) = f(i-1,j) or f(i,j-1) if {s3[i+j+1] = s1[i] = s2[j]}</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave1</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        dp[i + <span class="number">1</span>][<span class="number">0</span>] = s1.charAt(i) == s3.charAt(i) &amp;&amp; dp[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j + <span class="number">1</span>] = s2.charAt(j) == s3.charAt(j) &amp;&amp; dp[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = s1.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> ch2 = s2.charAt(j);</span><br><span class="line">            <span class="keyword">char</span> ch3 = s3.charAt(i + j + <span class="number">1</span>);</span><br><span class="line">            dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (ch1 == ch3 &amp;&amp; dp[i][j + <span class="number">1</span>]) || (ch2 == ch3 &amp;&amp; dp[i + <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于需要一个二重循环，因此上述代码的<strong>时间复杂度是O(mn)</strong>; 由于需要用二维数组dp保存f(i,j)的计算结果，因此它的**空间复杂度也是O(mn)**。</p><p>优化空间效率：</p><p>由于f(i,j)的值只依赖于f(i-1,j)和f(i,j-1)的值，因此计算数组dp的行号为i+1的位置时只需要上面行号为i的一行的值，即只需要保留二维数组中的两行就可以。当数组dp只有两行时，f(i,j)的值保存在dp[(i+1)%2][j+1]中。</p><p>还可以进一步优化空间效率，只需要保留二维数组中的一行就可以。f(i,j)的值依赖于位于它上方的f(i-1,j)和它左方的f(i,j-1)，而它上方的f(i-1,j)在计算完f(i,j)之后就没用了，因此可以把它们存在同一个格子中，即计算完f(i,j)后覆盖f(i-1,j)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave2</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证长的字符串在前</span></span><br><span class="line">    <span class="keyword">if</span> (s1.length() &lt; s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> isInterleave2(s2, s1, s3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s2.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">        dp[j + <span class="number">1</span>] = s2.charAt(j) == s3.charAt(j) &amp;&amp; dp[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">0</span>] &amp;&amp; s1.charAt(i) == s3.charAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = s1.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> ch2 = s2.charAt(j);</span><br><span class="line">            <span class="keyword">char</span> ch3 = s3.charAt(i + j + <span class="number">1</span>);</span><br><span class="line">            dp[j + <span class="number">1</span>] = (ch1 == ch3 &amp;&amp; dp[j + <span class="number">1</span>]) || (ch2 == ch3 &amp;&amp; dp[j]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[s2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后代码的**时间复杂度仍然是O(mn)<strong>，但</strong>空间效率变成O(min(m,n))**。</p><h3 id="子序列数目"><a href="#子序列数目" class="headerlink" title="# 子序列数目"></a># 子序列数目</h3><p>输入字符串S和T，请计算字符串S中有多少个子序列等于字符串T。</p><p>例如，在字符串”appplep”中，由3个子序列等于字符串”apple”。</p><p>分析：</p><p>用f(i,j)表示字符串S下标从0到i的子字符串中等于字符串T下标从0到j的字符串的子序列数目。</p><p>当字符串S的长度小于字符串T的长度时，字符串S中不可能存在等于字符串T的子序列，所以当i小于j时，f(i,j)的值都等于0。</p><p>如果S[i]=T[j]，那么对S[i]有两个选择：</p><ul><li>用S[i]去匹配T[j]，此时f(i,j)=f(i-1,j-1)</li><li>舍去S[i]，此时f(i,j)=f(i-1,j)</li></ul><p>因此，当S[i]=T[j]，f(i,j)=f(i-1,j-1)+f(i-1,j)</p><p>如果S[i]!=T[j]，f(i,j)=f(i-1,j)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct1</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i &amp;&amp; j &lt; t.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + dp[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果字符串S的长度为m，字符串T的长度为n，那么**时间复杂度为O(mn)<strong>，</strong>空间复杂度也为O(mn)**。</p><p>优化空间效率：</p><p>在计算f(i,j)的值时，最多只需要用到它上一行f(i-1,j-1)和f(i-1,j)的值，因此可以只保存表格中的两行。可以创建一个只有两行的二维数组dp，列数仍然是n+1，将f(i,j)保存在dp[(i+1)%2][j+1]中。</p><p>还可以进一步优化空间效率。将f(i,j)和f(i-1,j)保存在数组的同一个位置，这样实际上只需要一个长度为n+1的一维数组。但是f(i-1,j)的值在计算f(i,j+1)的时候也会需要，所以计算完f(i,j)之后不能直接覆盖。这里给出两个解决方案：</p><ul><li>保存f(i-1,j)的值备用</li><li>从右向左计算(因为计算f(i,j)时并不需要依赖f(i,j-1)的值)，这样可以避免值覆盖的问题，也不会影响计算结果</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct2</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Math.min(i, t.length() - <span class="number">1</span>); j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                dp[j + <span class="number">1</span>] = dp[j + <span class="number">1</span>] + dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[t.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化之后的**时间复杂度仍然是O(mn)<strong>，但</strong>空间复杂度为O(n)**。且比用两行数组的优化方法需要的辅助空间减少一倍。</p><h3 id="98-路径的数目"><a href="#98-路径的数目" class="headerlink" title="#98 路径的数目"></a>#98 路径的数目</h3><p>一个机器人从mxn的格子的左上角出发，它每步要么向下要么向右，直到抵达格子的左下角。请计机器人从左上角到达右下角的路径的数目。</p><p>例如，如果格子的大小是3x3，那么机器人从左上角到达右下角有6条符合条件的不同路径。</p><p>分析：</p><p>用f(i,j)表示从格子的左上角坐标为(0,0)的位置出发到达坐标为(i,j)的位置的路径的数目。</p><p>当i=0，机器人位于格子最上面的一行，机器人只能从(i, j-1)的位置向右走一步。</p><p>当j=0，机器人位于格子最左边的一列，机器人只能从(i-1,j)的位置向下走一步。</p><p>当i,j都大于0时，有两种走法，所以f(i,j)=f(i-1,j)+f(i,j-1)</p><p>递归代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">return</span> helper(m - <span class="number">1</span>, n - <span class="number">1</span>, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = helper(i - <span class="number">1</span>, j, dp) + helper(i, j - <span class="number">1</span>, dp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    Arrays.fill(dp[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化空间效率：</p><p>在计算f(i,j)时只需要用到f(i-1,j)和f(i,j-1)的值，因此只需要记录两行即可。将f(i,j)保存在dp[i%2][j]中。</p><p>可以进一步优化空间效率。在计算出f(i,j)之后，f(i-1,j)的值就没用了，因此可以把它们存在同一个位置，计算出f(i,j)后直接覆盖f(i-1,j)的值。这样用一个一维数组就可以实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths3</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="99-最小路径之和"><a href="#99-最小路径之和" class="headerlink" title="#99 最小路径之和"></a>#99 最小路径之和</h3><p>在一个mxn(m、n均大于0)的格子中，每个位置都有一个数字。一个机器人每步只能向下或向右，请计算它从格子的左上角到达右下角的路径的数字之和的最小值。</p><p>分析：</p><p>用f(i,j)表示从(0,0)到(i,j)数字之和的最小值。</p><p>当i等于0时，机器人位于格子最上面一行，那么此时只能从f(i,j-1)向右走一步到达。因此最小值只能是f(i,j-1)+grid[0][j]</p><p>当j等于0时，机器人位于格子最左边一列，那么此时只能从f(i-1,j)向下走一步到达。因此最小值只能是f(i-1,j)+grid[i][0]</p><p>当i,j都大于0时，f(i,j)=Math.min[f(i-1,j),f(i,j-1)]+grid[i][j]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum1</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j] + dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            dp[i][j] = grid[i][j] + prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[grid.length - <span class="number">1</span>][grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度空间复杂度都为O(mn)。</p><p>优化空间效率：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum2</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid[<span class="number">0</span>].length];</span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">        dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] += grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j-<span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度为O(mn)，但空间复杂度降为O(n)。</strong></p><h3 id="100-三角形中最小路径之和"><a href="#100-三角形中最小路径之和" class="headerlink" title="#100 三角形中最小路径之和"></a>#100 三角形中最小路径之和</h3><p>在一个由数字组成的三角形中，第1行有1个数字，第2行有2个数字，以此类推，第n行有n个数字。如果每步只能前往下一行中相邻的数字，请计算从三角形顶部到底部的路径经过的数字之和的最小值。</p><p>分析：</p><p>可以用矩阵坐标来定位三角形中的数字。移动三角形每行的位置使他们左端对齐。如果三角形有n行数字，将这些行左对齐之后就形成了一个nxn的矩阵的左下半部分。如果三角形中某个数字再矩阵中的行号和列号分别是i和j，那么i&gt;=j。</p><p>用f(i,j)表示从三角形的顶部出发到达行号和列号分别为i和j(i&gt;=j)的位置时路径数字之和的最小值。有三种情况：</p><ul><li>j=0，当前到达某行的第1个数字。由于路径的每步都时前往正下方或右下方的数字，而此时当前位置的左上方没有数字，那么前一步一定来自它的正上方的数字，f(i,0)=f(i-1,0)+T[i][0]</li><li>i=j，当前到达某行的最后一个数字，此时它的正上方没有数字，前一步只能来自它左上方的数字，f(i,j)=f(i-1,j-1)+T[i][j]</li><li>其他情况，f(i,j)=Math.min(f(i-1,j),f(i-1,j-1))+T[i][j]</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal1</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[size][size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i][j] = triangle.get(i).get(j);</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i == j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : dp[size - <span class="number">1</span>]) &#123;</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度空间复杂度都为O(n^2)。</strong></p><p>优化时间复杂度：</p><p>计算f(i,j)时只需要f(i-1,j-1)，f(i-1,j)的值。因为需要左上角的值，所以计算完f(i,j)不能直接覆盖f(i-1,j)的值。但是可以从右往左计算，就可以避免这个问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal2</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.size()];</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; row : triangle) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = row.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = row.get(j) + dp[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == row.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[j] = row.get(j) + dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j - <span class="number">1</span>]) + row.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : dp) &#123;</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度O(n^2)，空间复杂度降为O(n)。</strong></p><h3 id="101-分割等和子集"><a href="#101-分割等和子集" class="headerlink" title="#101 分割等和子集"></a>#101 分割等和子集</h3><p>给定一个非空的正整数数组，请判断能否将这些数字分成和相等的两部分。</p><p>例如，如果输入数组为[3,4,1]，将这些数字分成[3,1]和[4]两部分，它们的和相等，因此输出true；如果输入数组为[1,2,3,5]，则不能将这些数字分成和相等的两部分，因此输出false。</p><p>分析：</p><p>如果能将数组中的数字分成和相等的两部分，那么数组中所有数字的和(记为sum)应该是一个偶数。</p><p>可以换一个角度来描述这个问题：能否从数组中选出若干数字，使它们的和等于sum/2。由于每个数字最多只能选择一次，因此这是一个0-1背包问题。</p><p>确定状态转移方程。可以用函数f(i,j)表示能否从前i个物品中选择若干物品放满容量为j的背包。如果总共有n个物品，背包的容量为t，那么f(n,t)就是问题的解。分情况确定状态转移方程：</p><ul><li>当j=0，即背包容量为0，不管有多少个物品，只要什么物品都不选择，就能使选中的物品的总重量为0，因此f(i,0)都为true。</li><li>当i=0，j&gt;0时，即物品的数量为0，肯定无法用0个物品来放慢容量大于0的背包，因此f(0,j)都为false。</li><li>其他情况，对于标号为i-1的物品有两个选择：<ul><li>将标号i-1的物品放入背包：f(i,j)=f(i-1, j - nums[i-1])</li><li>不将标号i-1的物品放入背包：f(i,j)=f(i-1,j)</li></ul></li></ul><p>根据状态转移方程写递归代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subsetSum(nums, sum / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[nums.length + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> helper(nums, dp, nums.length, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, Boolean[][] dp, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = helper(nums, dp, i - <span class="number">1</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (!dp[i][j] &amp;&amp; j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = helper(nums, dp, i - <span class="number">1</span>, j - nums[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度空间复杂度都为O(nt)。</strong></p><p>根据状态转移方程写迭代代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">subsetSum2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (!dp[i][j] &amp;&amp; j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[nums.length][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度和空间复杂度都是O(nt)。</strong></p><p>优化空间效率：</p><p>计算f(i,j)时只需要用到i-1行的值，而且都是&lt;=j列的值，因此可以只用一个一维数组，从右向左完成运算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">subsetSum3</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[j] &amp;&amp; j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[j] = dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>空间复杂度降为O(t)</strong></p><h3 id="102-加减的目标值"><a href="#102-加减的目标值" class="headerlink" title="#102 加减的目标值"></a>#102 加减的目标值</h3><p>给定一个非空的正整数数组和一个目标值S，如果为每个数字添加”+”或”-“运算符，请计算有多少种方法可以使这些整数的计算结果为S。</p><p>例如，如果输入数组[2,2,2]并且S=2，有三种方法使结果为2：2+2-2；2-2+2；-2+2+2</p><p>分析：</p><p>假设所有需要添加”+”的数字之和为p，所有添加”-“的数字之和为q，按照题目要求p-q=S。又p+q=sum，所以p=(S+num)/2。因此这个题目等价于从计算数组中选出和为(S+sum)/2的数字的方法的数目。</p><p>确定状态转移方程：f(i,j)=</p><ul><li>1    j==0</li><li>0    i==0 &amp;&amp; j&gt;0</li><li>f(i-1,j) + f(i-1,j-nums[i])    i&gt;0 &amp;&amp; j &gt; nums[j]</li></ul><p>直接给出优化空间复杂度后的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sum + S) % <span class="number">2</span> == <span class="number">1</span> || sum &lt; S) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subsetSum(nums, (sum + S) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= num; j--) &#123;</span><br><span class="line">            dp[j] = dp[j] + dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度为O(nt)，空间复杂度为O(t)。</strong></p><h3 id="103-最少的硬币数目"><a href="#103-最少的硬币数目" class="headerlink" title="#103 最少的硬币数目"></a>#103 最少的硬币数目</h3><p>给定正整数数组coins表示硬币的面额和一个目标总额t，请计算凑出总额t至少需要的硬币数目。每种硬币可以使用任意多枚。如果不能用输入的硬币凑出给定的总额，则返回-1。</p><p>例如，如果硬币的面额为[1,3,9,10]，总额t为15，那么至少需要3枚硬币，2 * 3 + 9</p><p>分析：</p><p>用f(i,j)表示用前i种硬币凑出总额为j需要的硬币的最少数目。</p><p>f(i,j)=min(f(i-1),j-k*coins[i-1]+k)(k*coins[i-1]&lt;=j)</p><p>当j=0，f(i,0)都等于0，即从前i种硬币中选出0个硬币，使总额等于0。</p><p>当i=0且j&gt;0时，显然是不可能的，可以用特殊值表示。</p><p>直接给出优化空间复杂度后的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange1</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, target + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * coin &lt;= j; k++) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j - k * coin] + k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target] &gt; target ? -<span class="number">1</span> : dp[target];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>时间复杂度O(ntk)，空间复杂度O(t)。</strong>n是硬币类数，t是目标总额</p><p>换一种思路：</p><p>用函数f(i)表示凑出总额为i的硬币需要的最少数目。</p><p>f(i)=min(f(i-coins[j])+1)(coins[j]&lt;=i)</p><p>f(0)=0</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange2</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        dp[i] = target + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target] &gt; target ? -<span class="number">1</span> : dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度O(nt)，空间复杂度O(t)。</strong>n是硬币类数，t是目标总额</p><h3 id="104-排列的数目"><a href="#104-排列的数目" class="headerlink" title="#104 排列的数目"></a>#104 排列的数目</h3><p>给定一个非空的正整数数组nums和一个目标值t，数组中的所有数字都是唯一的，请计算数字之和等于t的所有排列的数目。数组中的数字可以在排列中出现任意次。</p><p>例如，输入数组[1,2,3]，目标值t为3，那么总共有4个组合的数字之和等于3。分别为{1,1,1}、{1，2}、{2，1}、{3}。</p><p>分析：</p><p>用f(i)表示和为i的排列的数目。</p><p>f(i)=sumOf(i-nums[j])(nums[j]&lt;=i)</p><p>f(0)=1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">permutationSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= num) &#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**时间复杂度O(nt)，空间复杂度O(t)**。n为输入数组的长度，t为排列的目标和。</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="105-最大的岛屿"><a href="#105-最大的岛屿" class="headerlink" title="#105 最大的岛屿"></a>#105 最大的岛屿</h3><p>海洋岛屿地图可以用0、1组成的二维数组表示，水平或竖直方向相连的一组1表示一个岛屿，请计算最大岛屿的面积(即岛屿中1的数目)。</p><p>分析：</p><p>可以逐一扫描矩阵中的每个格子，如果遇到一个值为1的格子并且不在之前已知的岛屿上，那么久到达了一个新的岛屿，于是搜索这个岛屿并计算它的面积。在比较所有岛屿的面积之后就可以知道最大的岛屿的面积。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> area = getArea(grid, visited, i, j);</span><br><span class="line">                maxArea = Math.max(maxArea, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了一个和输入矩阵相同大小的矩阵visited，它的作用是用一个布尔值标识矩阵中的每个值为1的格子是否已经到达过，用来确保每个格子只搜索一次。</p><p>getArea方法需要搜索整个连通子图可以得到节点的数目，因此这是一个典型的图的搜索问题。</p><p>基于队列的广度优先搜索：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea1</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pos = queue.remove();</span><br><span class="line">        area++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = pos[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = pos[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length</span><br><span class="line">                &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length</span><br><span class="line">                &amp;&amp; grid[r][c] == <span class="number">1</span> &amp;&amp; visited[r][c]) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c&#125;);</span><br><span class="line">                visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于栈的深度优先搜索：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getArea2</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>[]&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pos = stack.pop();</span><br><span class="line">        area++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = pos[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = pos[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length</span><br><span class="line">                &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length</span><br><span class="line">                &amp;&amp; grid[r][c] == <span class="number">1</span> &amp;&amp; !visited[r][c]) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c&#125;);</span><br><span class="line">                visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于递归实现深度优先搜索：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getArea3</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">1</span>;</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> c = j + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length</span><br><span class="line">            &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length</span><br><span class="line">            &amp;&amp; grid[r][c] == <span class="number">1</span> &amp;&amp; !visited[r][c]) &#123;</span><br><span class="line">            area += getArea3(grid, visited, r, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个图的节点数目为v，边的数目为e，那么在该图上进行广度优先搜索和深度优先搜索的时间复杂度都是O(v+e)。</p><p>此题中节点数和边数都是O(mn)，因此**时间复杂度也是O(mn)**。</p><p>**空间复杂度为O(mn)**。</p><h3 id="106-二分图"><a href="#106-二分图" class="headerlink" title="#106 二分图"></a>#106 二分图</h3><p>如果能将一个图中的节点分成A、B两个部分，使任意一条边的一个节点属于A而另一个节点属于B，那么该图就是一个二分图。输入一个由数组graph表示的图，graph[i]中包含所有和节点i相邻的节点，请判断该图是否为二分图。</p><p>分析：</p><p>二分图的节点可以分成两种不同的类型，任意一条边的两个节点分别属于两种不同的类型。可以为图中的所有节点着色，两种不同类型的节点分别涂上不同的颜色。如果任意一条边的两个节点都能被涂上不同的颜色，那么整个图就是一个二分图。</p><p>一个图可能包含多个连通子图，逐一对每个子图的节点着色。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = graph.length;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    Arrays.fill(colors, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!setColor(graph, colors, i, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了一个长度为n的数组colors记录每个节点的颜色，节点i的颜色保存在colors[i]中。如果节点i还没有被着色，那么colors[i]的值为-1；如果节点i已经被着色，那么colors[i]的值为0或1。</p><p>利用广度优先搜索对子图着色：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setColor1</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] colors, <span class="keyword">int</span> i, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(i);</span><br><span class="line">    colors[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = queue.remove();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colors[neighbor] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (colors[neighbor] == colors[v]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.add(neighbor);</span><br><span class="line">                colors[neighbor] = <span class="number">1</span> - colors[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用深度优先搜索对子图着色：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setColor2</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] colors, <span class="keyword">int</span> i, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已经被着色，且正好是想要的颜色</span></span><br><span class="line">    <span class="keyword">if</span> (colors[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> colors[i] == color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    colors[i] = color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!setColor2(graph, colors, neighbor, <span class="number">1</span> - color)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所有算法的时间复杂度均为O(v+e)</strong></p><h3 id="107-矩阵中的距离"><a href="#107-矩阵中的距离" class="headerlink" title="#107 矩阵中的距离"></a>#107 矩阵中的距离</h3><p>输入一个由0、1组成的矩阵M，请输出一个大小相同的矩阵D，矩阵D中的每个格子是矩阵M中对应格子离最近的0的距离。水平或竖直方向相邻的两个格子的距离为1。假设矩阵M中至少有一个0。</p><p>分析：</p><p>要求计算每个格子离0最近的距离。根据题目要求，上下左右相邻的两个格子的距离为1。可以将图看成一个无权图，这个题与无权图的最近距离相关，因此可以考虑应用广度优先搜索解决。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dists = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                dists[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dists[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pos = queue.remove();</span><br><span class="line">        <span class="keyword">int</span> dist = dists[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = pos[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = pos[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt; rows &amp;&amp; c &lt; cols) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dists[r][c] &gt; dist + <span class="number">1</span>) &#123;</span><br><span class="line">                    dists[r][c] = dist + <span class="number">1</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广度优先搜索能够保证从起始节点到达任意节点一定是沿着最短路径的，因此可以通过用“dist[r][c] &gt; dist + 1”避免重复访问某个格子。</p><h3 id="108-单词演变"><a href="#108-单词演变" class="headerlink" title="#108 单词演变"></a>#108 单词演变</h3><p>输入两个长度相同但内容不同的单词(beginWord和endWord)和一个单词列表，求从beginWord到endWord的演变序列的最短长度，要求每步只能改变单词中的一个字母，并且演变过程中每步得到的单词都必须在给定的单词列表中。如果不能从beginWord演变到endWord，则返回0。假设所有单词只包含英文小写字母。</p><p>分析：</p><p>应用图相关算法的前提是找出图中的节点和边。这个问题是关于单词的演变的，所以每个单词就是图中的一个节点。如果两个单词能相互演变，那他们之间有一条边相连。</p><p>又是求无权图的最短路径，想到用广度优先搜索。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength1</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; notVisited = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    queue1.add(beginWord);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        String word = queue1.remove();</span><br><span class="line">        <span class="keyword">if</span> (word.equals(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; neighbors = getNeighbors(word);</span><br><span class="line">        <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (notVisited.contains(neighbor)) &#123;</span><br><span class="line">                queue2.add(neighbor);</span><br><span class="line">                notVisited.remove(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回所有可能的neighbor</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; neighbors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> old = chars[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>; ch &lt;= <span class="string">&#x27;z&#x27;</span>; ch++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (old != ch) &#123;</span><br><span class="line">                chars[i] = ch;</span><br><span class="line">                neighbors.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chars[i] = old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>！！双向广度优先搜索：</strong></p><p>这个题目时关于单一起始节点、单一目标节点的最短路径问题。前面的解法是从起始节点出发不断朝着目标节点的方向搜索，直到到达目标节点。针对这类问题有一种常见的优化方法，即在从起始节点出发不断朝着目标节点的方向搜索的同时，也从目标节点出发不断朝着起始节点的方向搜索。这种双向搜索的方法能够缩小搜索空间，从而提高搜索的时间效率。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength2</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; notVisited = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    <span class="keyword">if</span> (!notVisited.contains(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">    set1.add(beginWord);</span><br><span class="line">    set2.add(endWord);</span><br><span class="line">    notVisited.remove(endWord);</span><br><span class="line">    <span class="keyword">while</span> (!set1.isEmpty() &amp;&amp; !set2.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 保证set1是size更大的集合</span></span><br><span class="line">        <span class="comment">// 也是双向搜索的保证</span></span><br><span class="line">        <span class="keyword">if</span> (set2.size() &lt; set1.size()) &#123;</span><br><span class="line">            Set&lt;String&gt; temp = set1;</span><br><span class="line">            set1 = set2;</span><br><span class="line">            set2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set3 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : set1) &#123;</span><br><span class="line">            List&lt;String&gt; neighbors = getNeighbors(word);</span><br><span class="line">            <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set2.contains(neighbor)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> length;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (notVisited.contains(neighbor)) &#123;</span><br><span class="line">                    set3.add(neighbor);</span><br><span class="line">                    notVisited.remove(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length++;</span><br><span class="line">        set1 = set3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="109-开密码锁"><a href="#109-开密码锁" class="headerlink" title="#109 开密码锁"></a>#109 开密码锁</h3><p>一个密码锁由4个环形转轮组成，每个转轮由0~9这10个数字组成。每次可以上下拨动一个转轮，如果可以将一个转轮从0拨到1，也可以从0拨到9。密码锁有若干死锁状态，一旦4个转轮被拨到某个死锁状态，这个锁就不可能打开。密码锁的状态可以用一个长度为4的字符串表示，字符串中的每个字符对应某个转轮上的数字。输入密码锁的密码和它的所有死锁状态，请问至少需要拨动转轮多少次才能从起始状态”0000”开始打开这个密码锁？如果锁不能打开，请返回-1。</p><p>分析：</p><p>首先要构建一个图。密码锁的每个状态都对应着图中的一个节点，如果转动某个转轮一次可以让密码锁从一个状态转移到另一个状态，那么这两个状态之间有一条边相连。</p><p>因为要搜索最少拨动的次数，所以想到用广度优先搜索。搜索时还要避开死锁状态对应的系欸但，因为一旦到达这些节点后就不能继续向下搜索。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; dead = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(deadends));</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    String init = <span class="string">&quot;0000&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (dead.contains(init) || dead.contains(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;String&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    queue1.offer(init);</span><br><span class="line">    visited.add(init);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        String cur = queue1.remove();</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> steps;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; nexts = getNeighbors(cur);</span><br><span class="line">        <span class="keyword">for</span> (String next : nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dead.contains(next) &amp;&amp; !visited.contains(next)) &#123;</span><br><span class="line">                queue2.add(next);</span><br><span class="line">                visited.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            steps++;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String cur)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; nexts = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = cur.charAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> newCh = ch == <span class="string">&#x27;0&#x27;</span> ? <span class="string">&#x27;9&#x27;</span> : (<span class="keyword">char</span>)(ch - <span class="number">1</span>);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(cur);</span><br><span class="line">        builder.setCharAt(i, newCh);</span><br><span class="line">        nexts.add(builder.toString());</span><br><span class="line"></span><br><span class="line">        newCh = ch == <span class="string">&#x27;9&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : (<span class="keyword">char</span>)(ch + <span class="number">1</span>);</span><br><span class="line">        builder.setCharAt(i, newCh);</span><br><span class="line">        nexts.add(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nexts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实现的是单向广度优先搜索。同样也可以用双向广度优先搜索来解决这个问题。请自行尝试。</p><h3 id="110-所有路径"><a href="#110-所有路径" class="headerlink" title="#110 所有路径"></a>#110 所有路径</h3><p>一个有向无环图由n个节点(标号从0到n-1，n&gt;=2)组成，请找出从节点0到节点n-1的所有路径。图用一个数组graph表示，数组的graph[i]包含所有从节点i直接到达的节点。</p><p>例如，输入数组graph为[[1,2],[3],[3],[]]，则输出两条从节点0到节点3路径，分别为0-&gt;1-&gt;3和0-&gt;2-&gt;3。</p><p>分析：</p><p>题目要求找出有向无环图中从节点0到节点n-1的所有路径，自然需要搜索图中的所有节点。由于题目要求列出从节点0到节点n-1的所有路径，因此深度优先搜索是更合适的选择。</p><p>深度优先搜索通常用递归实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    dfs(<span class="number">0</span>, graph, path, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span>[][] graph, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    path.add(source);</span><br><span class="line">    <span class="keyword">if</span> (source == graph.length - <span class="number">1</span>) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(path));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[source]) &#123;</span><br><span class="line">            dfs(next, graph, path, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯思想</span></span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的实现和回溯法代码很像，这是因为回溯法从本质上来说就是深度优先搜索。</p><h3 id="111-计算除法"><a href="#111-计算除法" class="headerlink" title="#111 计算除法"></a>#111 计算除法</h3><p>输入两个数组equations和values，其中，数组equations的每个元素包含两个表示变量名字的字符串，数组values的每个元素是一个浮点数值。如果equations[i]的两个变量名分别是Ai和Bi，那么Ai/Bi=values[i]。再给点一个数组queries，它的每个元素也包含两个变量名。对于queries[j]的两个变量名Ci和Di，请计算Ci和Di的结果。假设任意values[i]大于0。如果不能计算，那么返回-1。</p><p>例如，数组equations为[[“a”, “b”], [“b”, “c”]]，数组values为[2.0, 3.0]，数组queries为[[“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”]]，那么对应的计算结果为[6.0, 0.5, -1.0, 1.0, -1.0]。</p><p>分析：</p><p>首先根据数组equations和values构建出对应的图。因为a/b=2.0，所以图中有一条从节点a到节点b的边，权重为2.0。由数学常识可知b/a=1/2，所以图中还有一条由节点b指向节点a的权重为1/2的边。其他节点同理。</p><p>接下来考虑如何计算除法。已知a/b=2.0，b/c=3.0，那么a/c=6.0，计算过程等价于找到一条从a-&gt;c的路径，并将边上的权重相乘。因此，这个问题从本质上来说还是一个图搜索问题，由于需要记录从一个节点到另一个节点的路径，深度优先搜索比较合适。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">    Map&lt;String, Map&lt;String, Double&gt;&gt; graph = buildGraph(equations, values);</span><br><span class="line">    <span class="keyword">double</span>[] results = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">        String from = queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">        String to = queries.get(i).get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!graph.containsKey(from) || graph.containsKey(to)) &#123;</span><br><span class="line">            results[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            results[i] = dfs(graph, from, to, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Map&lt;String, Double&gt;&gt; buildGraph(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values) &#123;</span><br><span class="line">    Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">        String var1 = equations.get(i).get(<span class="number">0</span>);</span><br><span class="line">        String var2 = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        graph.putIfAbsent(var1, <span class="keyword">new</span> HashMap&lt;String, Double&gt;());</span><br><span class="line">        graph.get(var1).put(var2, values[i]);</span><br><span class="line"></span><br><span class="line">        graph.putIfAbsent(var2, <span class="keyword">new</span> HashMap&lt;String, Double&gt;());</span><br><span class="line">        graph.get(var2).put(var1, <span class="number">1.0</span> / values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">dfs</span><span class="params">(Map&lt;String, Map&lt;String, Double&gt;&gt; graph, String from, String to, Set&lt;String&gt; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (from.equals(to)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited.add(from);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; entry : graph.get(from).entrySet()) &#123;</span><br><span class="line">        String next = entry.getKey();</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">            <span class="keyword">double</span> nextValue = dfs(graph, next, to, visited);</span><br><span class="line">            <span class="keyword">if</span> (nextValue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getValue() * nextValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited.remove(from);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="112-最长的递增路径"><a href="#112-最长的递增路径" class="headerlink" title="#112 最长的递增路径"></a>#112 最长的递增路径</h3><p>输入一个整数矩阵，请求最长递增路径的长度。矩阵中的路径沿着上、下、左、右4个方向前行。</p><p>分析：</p><p>求最长递增路径的长度，深度优先搜索比较适合。</p><p>因为不知道从哪个节点开始的递增路径是最长的，所以试着找出从矩阵的每个数字出发的最长递增路径的长度，通过比较可以得出整个矩阵中的最长递增路径的长度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] lengths = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = dfs(matrix, lengths, i, j);</span><br><span class="line">            longest = Math.max(longest, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[][] lengths, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lengths[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lengths[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> c = j + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; rows &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; cols</span><br><span class="line">            &amp;&amp; matrix[r][c] &gt; matrix[i][j]) &#123;</span><br><span class="line">            <span class="keyword">int</span> path = dfs(matrix, lengths, r, c);</span><br><span class="line">            length = Math.max(path + <span class="number">1</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lengths[i][j] = length;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="#拓扑排序"></a>#拓扑排序</h3><p>拓扑排序是指对一个有向无环图的节点进行排序之后得到的序列。如果存在一条从节点A指向节点B的边，那么在拓扑排序的序列中节点A出现在节点B的前面。一个有向无环图可以有一个或多个拓扑排序序列，但无向图或有环的有向图都不存在拓扑排序。</p><p>一种常用的拓扑排序算法是每次从有向无环图中取出一个入度为0的节点添加到拓扑排序的序列之中，然后删除该节点及所有以它为起点的边。重复这个步骤，直到图为空或图中不存在入度为0的节点。如果最终图为空，那么图是有向无环图，此时就找到了该图的一个拓扑排序序列。如果最终图不为空并且已经不存在入度为0的节点，那么图中一定有环。</p><h3 id="113-课程顺序"><a href="#113-课程顺序" class="headerlink" title="#113 课程顺序"></a>#113 课程顺序</h3><p>n门课程的编号为0~n-1。输入一个数组prerequisites，它的每个元素prerequisites[i]表示两门课程的先修顺序。如果prerequisites[i]=[ai, bi]，那么必须先修完bi才能修ai。请根据总课程数n和表示先修顺序的prerequisites得出一个可行的修课序列。如果有多个可行的修课序列，则输出任意一个可行的序列；如果没有可行的修课序列，则输出空序列。</p><p>例如，总共有4门课程，先修顺序prerequisites为[[1,0], [2,0], [3,1], [3,2]]，一个可行的修课序列是0-&gt;2-&gt;1-&gt;3。</p><p>分析：</p><p>将课程看成图中的节点，如果两门课程存在先修顺序，那么它们在图中对应的节点之间存在一条从先修课程到后修课程的边，因此这是一个有向图。可行的修课序列实际上是图的拓扑排序序列。拓扑排序得到的序列与先修顺序一定不会存在冲突，于是这个问题转变成如何求有向图的拓扑排序序列。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] inDegrees = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] prereq : prerequisites) &#123;</span><br><span class="line">        graph.get(prereq[<span class="number">1</span>]).add(prereq[<span class="number">0</span>]);</span><br><span class="line">        inDegrees[prereq[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; order = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> course = queue.remove();</span><br><span class="line">        order.add(course);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(course)) &#123;</span><br><span class="line">            inDegrees[next]--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inDegrees[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order.size() == numCourses </span><br><span class="line">        ? order.stream().mapToInt(i-&gt;i).toArray() </span><br><span class="line">        : <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图中节点数目为m，边数为n，**拓扑排序的时间复杂度为O(m+n)**。</p><h3 id="114-外星文字典"><a href="#114-外星文字典" class="headerlink" title="#114 外星文字典"></a>#114 外星文字典</h3><p>一种外星语言的字母都是英文字母，但字母的顺序未知。给定该语言的单词列表，请推测可能的字母顺序。如果有多个可能的顺序，则返回任意一个。如果没有满足条件的字母顺序，则返回空字符串。</p><p>例如，如果输入排序的单词列表为[“ac”, “ab”, “bc”, “zc”, “zb”]。</p><p>分析：</p><p>与#113类似，可以把此题转换为求拓扑排序的问题。图的节点为字母，单词”ac”&lt;”ab”前，则’c’&lt;’b’，有一条从c-&gt;b的有向边。”ac”&lt;”bc”，则’a’&lt;’b’，有一条从a-&gt;b的有向边。以此类推。构建完图后，求解拓扑排序，即为此题的解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; inDegrees = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            graph.putIfAbsent(ch, <span class="keyword">new</span> HashSet&lt;Character&gt;());</span><br><span class="line">            inDegrees.putIfAbsent(ch, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        String w1 = words[i - <span class="number">1</span>];</span><br><span class="line">        String w2 = words[i];</span><br><span class="line">        <span class="keyword">if</span> (w1.startsWith(w2) &amp;&amp; !w1.equals(w2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w1.length() &amp;&amp; j &lt; w2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = w1.charAt(j);</span><br><span class="line">            <span class="keyword">char</span> ch2 = w2.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (ch1 != ch2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!graph.get(ch1).contains(ch2)) &#123;</span><br><span class="line">                    graph.get(ch1).add(ch2);</span><br><span class="line">                    inDegrees.put(ch2, inDegrees.get(ch2) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : inDegrees.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees.get(ch) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = queue.remove();</span><br><span class="line">        sb.append(ch);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> next : graph.get(ch)) &#123;</span><br><span class="line">            inDegrees.putIfAbsent(next, inDegrees.get(next) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegrees.get(next) == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.length() == graph.size() ? sb.toString() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中并没有把所有单词之间两两比较，而是值比较相邻的单词，从头找出第1组不同的两个字母，在图中添加一条较小字母指向较大字母的边。</p><p>有一类特殊的输入需要特别注意。如果排在后面的单词是排在前面的单词的前缀，那么无论什么样的字母顺序都是不可能的。例如，如果排序的单词列表是[“abc”, “ab”]，不管是什么样子的字母顺序，”abc”都不可能在”ab”前面，因此这是一个无效输入，可以直接返回空字符串列表表示无效的字母顺序。</p><h3 id="115-重建序列"><a href="#115-重建序列" class="headerlink" title="#115 重建序列"></a>#115 重建序列</h3><p>长度为n的数组org是数字1~n的一个排列，seqs是若干序列，请判断数组org是否可以由seqs重建的唯一序列。重建的序列是指seqs所有序列的最短公共超序列，即seqs中的任意序列都是该序列的子序列。</p><p>例如，如果数组org为[4,1,5,2,6,3]，而seqs为[[5,2,6,3], [4,1,5,2]], 因为用[[5,2,6,3], [4,1,5,2]]可以重建出唯一的序列[4,1,5,2,6,3], 所以返回true。如果数组org为[1,2,3]，而seqs为[[1,2], [1,3]]，因为用[[1,2], [1,3]]可以重建出两个序列, [1,2,3]或[1,3,2]，所以返回false。</p><p>分析：</p><p>可以将seqs中每个序列的每个数字看成图中的一个节点，两个相邻的数字之间有一条从前面数字指向后面数字的边。然后，这个问题就转变成一个判断一个有向图的拓扑排序序列是否唯一，即同一时刻，只能有一个入度为0的节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sequenceReconstruction</span><span class="params">(<span class="keyword">int</span>[] org, List&lt;List&lt;Integer&gt;&gt; seqs)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegrees = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; seq : seqs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : seq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">1</span> || num &gt; org.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            graph.putIfAbsent(num, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            inDegrees.putIfAbsent(num, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = seq.get(i);</span><br><span class="line">            <span class="keyword">int</span> num2 = seq.get(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!graph.get(num1).contains(num2)) &#123;</span><br><span class="line">                graph.get(num1).add(num2);</span><br><span class="line">                inDegrees.put(num2, inDegrees.get(num2) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : inDegrees.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees.get(num) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; built = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (queue.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = queue.remove();</span><br><span class="line">        built.add(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(num)) &#123;</span><br><span class="line">            inDegrees.put(next, inDegrees.get(next) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegrees.get(next) == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[built.size()];</span><br><span class="line">    result = built.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(result, org);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="#并查集"></a>#并查集</h3><p>并查集是一种树形的数据结构，用来表示不相交集合的数据。并查集中的每个子集是一棵树，每个元素是某棵树中的一个节点。树中的每个节点有一个指向父节点的指针，树的根节点的指针指向它自己。</p><p>并查集支持两种操作，即合并和查找。</p><ul><li>合并：将两个子集合并成一个集合，只需要将一个子集对应的树的根节点的指针指向另一个子集对应的树的根节点</li><li>查找：确定某个元素v处于哪个子集中。并查集中的子集由对应的树的根节点代表。从元素v对应的节点开始沿着指向父节点的指针一直找到树的根节点，即节点的祖先节点。</li></ul><p><strong>并查集经常用来解决图的动态连接问题。</strong></p><h3 id="116-朋友圈"><a href="#116-朋友圈" class="headerlink" title="#116 朋友圈"></a>#116 朋友圈</h3><p>假设一个班级中由n个学生。学生之间有些是朋友，有些不是。朋友关系是可以传递的。例如，A是B的直接朋友，B是C的直接朋友，那么A是C的间接朋友。定义朋友圈就是一组直接朋友或间接朋友的学生。输入一个nxn的矩阵M表示班上的朋友关系，如果M[i][j]=1，那么学生i和学生j是直接朋友。请计算该班级中朋友圈的数目。</p><p>图的搜索算法可以用来计算图中子图的数目。扫描图中所有的节点。如果某个节点v之前没有访问过，就搜索他所在的子图。当所有节点都访问完之后，就可以知道图中有多少个子图。广度优先搜索和深度优先搜索都可以用来计算图中子图的数目。基于广度优先搜索的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[M.length];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            findCircle(M, visited, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findCircle</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(i);</span><br><span class="line">    visited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = queue.remove();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> friend = <span class="number">0</span>; friend &lt; M.length; friend++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[t][friend] == <span class="number">1</span> &amp;&amp; !visited[friend]) &#123;</span><br><span class="line">                queue.add(friend);</span><br><span class="line">                visited[friend] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果班级中有n个学生，那么图中有n个节点和O(n^2)条边，广度优先搜索的时间复杂度是O(n^2)。</p><p>应用并查集：</p><p>创建长度为n的数组fathers存储n个节点的父节点。有了这个数组fathers，如果想知道节点i所在的子集的根节点，就可以从节点i开始沿着指向父节点的指针搜索，时间复杂度看起来是O(n)，但可以将从i到根节点的路径压缩，从而优化时间效率。</p><p>我们真正关心的是节点i的根节点是谁而不是它的父节点，因此可以在fathers[i]中存储它的根节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] fathers = <span class="keyword">new</span> <span class="keyword">int</span>[M.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fathers.length; i++) &#123;</span><br><span class="line">        fathers[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = M.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span> &amp;&amp; union(fathers, i, j)) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fathers[i] != i) &#123;</span><br><span class="line">        fathers[i] = findFather(fathers, fathers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fathers[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fatherOfI = findFather(fathers, i);</span><br><span class="line">    <span class="keyword">int</span> fatherOfJ = findFather(fathers, j);</span><br><span class="line">    <span class="keyword">if</span> (fatherOfI != fatherOfJ) &#123;</span><br><span class="line">        fathers[fatherOfI] = fatherOfJ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总时间复杂度O(n^2)。</strong></p><h3 id="117-相似的字符串"><a href="#117-相似的字符串" class="headerlink" title="#117 相似的字符串"></a>#117 相似的字符串</h3><p>如果交换字符串X中的两个字符就能得到字符串Y，那么两个字符串X和Y相似。例如，字符串”tars”和”rats”相似(交换下标为0和2的两个字符)、字符串”rats”和”arts”相似(交换下标为0和1的字符)，但字符串”star”和”tars”不相似。</p><p>输入一个字符串数组，根据字符串的相似性分组，请问能把输入数组分成几组？如果一个字符串至少和一组字符串中的一个相似，那么它就可以放到该组中。假设输入数组中的所有字符串的长度相同并且两两互为变位词。</p><p>例如，输入数组为[“tars”, “rats”, “arts”, “star”]，可以分成两组，一组为{“tars”, “rats”, “arts”}, 另一组为{“star”}。</p><p>分析：解法与#116类似</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] fathers = <span class="keyword">new</span> <span class="keyword">int</span> [A.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fathers.length; i++) &#123;</span><br><span class="line">        fathers[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> groups = A.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (similar(A[i], A[j]) &amp;&amp; union(fathers, i, j)) &#123;</span><br><span class="line">                groups--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> groups;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">similar</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> diffCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1.charAt(i) != str2.charAt(i)) &#123;</span><br><span class="line">            diffCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diffCount &lt;= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fathers[i] != i) &#123;</span><br><span class="line">        fathers[i] = findFather(fathers, fathers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fathers[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fatherOfI = findFather(fathers, i);</span><br><span class="line">    <span class="keyword">int</span> fatherOfJ = findFather(fathers, j);</span><br><span class="line">    <span class="keyword">if</span> (fatherOfI != fatherOfJ) &#123;</span><br><span class="line">        fathers[fatherOfI] = fatherOfJ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="118-多余的边"><a href="#118-多余的边" class="headerlink" title="#118 多余的边"></a>#118 多余的边</h3><p>树可以看成无环的无向图。在一个包含n个节点(节点标号为从1到n)的树中添加一条边连接任意两个节点，这棵树就会变成一个有环的图。给定一个在树中添加了一条边的图，请找出这条多余的边(用这条边连接的两个节点表示)。输入的图用一个二维数组edges表示，数组中的每个元素是一条边的两个节点[u,v](u&lt;v)。如果有多个答案，请输出在数组edges中最后出现的边。</p><p>分析：</p><p>如果两个节点分别属于两个不同的子图，添加一条边连接这两个节点，会将他们所在的子图连接在一起，但不会形成环。如果两个节点同属于一个子图，添加一条边连接这两个节点就会形成一个环。</p><p>因此，为了遭到多余的边需要解决两个问题：一是如何判断两个节点是否属于同一个子图，二是如何合并两个子图。并查集刚好可以解决这两个问题，由此可见，这是一个适合用并查集解决的问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxVertex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        maxVertex = Math.max(maxVertex, edge[<span class="number">0</span>]);</span><br><span class="line">        maxVertex = Math.max(maxVertex, edge[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] fathers = <span class="keyword">new</span> <span class="keyword">int</span>[maxVertex + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxVertex; i++) &#123;</span><br><span class="line">        fathers[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!union(fathers, edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> edge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fathers[i] != i) &#123;</span><br><span class="line">        fathers[i] = findFather(fathers, fathers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fathers[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fatherOfI = findFather(fathers, i);</span><br><span class="line">    <span class="keyword">int</span> fatherOfJ = findFather(fathers, j);</span><br><span class="line">    <span class="keyword">if</span> (fatherOfI != fatherOfJ) &#123;</span><br><span class="line">        fathers[fatherOfI] = fatherOfJ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度O(n)。</strong></p><h3 id="119-最长连续序列"><a href="#119-最长连续序列" class="headerlink" title="#119 最长连续序列"></a>#119 最长连续序列</h3><p>输入一个无序的整数数组，请计算最长的连续数值序列的长度。</p><p>例如，输入数组[10, 5, 9, 2, 4, 3]，则最长的连续数值序列是[2, 3, 4, 5]，因此输出4。</p><p>分析：</p><p>如果把数组中每个数值当作一个节点，相邻的整数组成一个岛屿，那么连续整数的数目就是岛屿的面积。可以通过广度优先搜索或深度优先搜索求最大岛屿的面积。</p><p>基于广度优先搜索：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!set.isEmpty()) &#123;</span><br><span class="line">        Iterator&lt;Integer&gt; iter = set.iterator();</span><br><span class="line">        longest = Math.max(longest, bfs(set, iter.next()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(Set&lt;Integer&gt; set, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(num);</span><br><span class="line">    set.remove(num);</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = queue.poll();</span><br><span class="line">        <span class="keyword">int</span>[] neighbors = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i - <span class="number">1</span>, i + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(neighbor)) &#123;</span><br><span class="line">                queue.offer(neighbor);</span><br><span class="line">                set.remove(neighbor);</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用并查集解决问题：</p><p>在初始化并查集的时候输入数组中的每个整数放入一个子集中，父节点的指针指向它子集。然后对于每个整数n，如果存在整数n-1和n+1，则将他们所在的子集合并。每个子集的根节点记录它所在子集的元素的数目，在合并子集的时候需要更新合并之后新子集的根节点中子集元素的数目。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; fathers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; all = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        fathers.put(num, num);</span><br><span class="line">        counts.put(num, <span class="number">1</span>);</span><br><span class="line">        all.add(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (all.contains(num + <span class="number">1</span>)) &#123;</span><br><span class="line">            union(fathers, counts, num, num + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (all.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            union(fathers, counts, num, num - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> length : counts.values()) &#123;</span><br><span class="line">        longest = Math.max(longest, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFather</span><span class="params">(Map&lt;Integer, Integer&gt; fathers, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fathers.get(i) != i) &#123;</span><br><span class="line">        fathers.put(i, findFather(fathers, fathers.get(i)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fathers.get(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Map&lt;Integer, Integer&gt; fathers, Map&lt;Integer, Integer&gt; counts, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fatherOfI = findFather(fathers, i);</span><br><span class="line">    <span class="keyword">int</span> fatherOfJ = findFather(fathers, j);</span><br><span class="line">    <span class="keyword">if</span> (fatherOfI != fatherOfJ) &#123;</span><br><span class="line">        fathers.put(fatherOfI, fatherOfJ);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> countOfI = counts.get(fatherOfI);</span><br><span class="line">        <span class="keyword">int</span> countOfJ = counts.get(fatherOfJ);</span><br><span class="line">        counts.put(fatherOfJ, countOfI + countOfJ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设输入n个整数，上述代码可能需要合并相邻的整数O(n)次，<strong>时间复杂度O(n)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux韩顺平学习笔记</title>
      <link href="/2021/09/29/linux_hsp/"/>
      <url>/2021/09/29/linux_hsp/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相关课程学习资料请添加韩老师微信获取</p><p>微信号<code>hspfly</code></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>linux是一个开源、免费的操作系统。 其稳定性、 安全性、 处理多并发已经得到业界的认可，因此目前很多企业级项目都会部署到linux/unix系统上。</p><h3 id="Linux主要的发行版："><a href="#Linux主要的发行版：" class="headerlink" title="Linux主要的发行版："></a>Linux主要的发行版：</h3><p>​    Ubuntu, RedHat, CentOS, Debain, Fedora, SuSE, OpenSUSE</p><p>(本课程主要使用CentOS)</p><h3 id="Linux应用领域"><a href="#Linux应用领域" class="headerlink" title="Linux应用领域"></a>Linux应用领域</h3><ul><li><p><code>服务器领域</code></p><p>linux再服务器领域的应用是最强的</p><p>linux免费、稳定、高效等特点在这里得到了很好的体现， 尤其在一些高端领域尤为广泛（c/c++/php/java/python/go）</p></li><li><p><code>嵌入式领域</code></p><p>linux运行稳定、对网络的良好支持性、低成本， 且可以根据需要进行剪裁，内核最小可以达到几百KB等特点，使其近些年来再嵌入式领域广泛应用</p><p>主要应用： 机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件等都是其应用领域。以后再物联网中应用会更加广泛。</p></li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li>VMware Workstation Pro 15.5 </li><li>Centos7.6 DVD版 （目前主流的生产环境）</li><li>Centos8.1 DVD版 （未来的主流）</li></ol><p>在配置Cenots时， 网络连接模式要选NAT模式，避免造成IP冲突。</p><p><img src="image-20211001130843302.png" alt="image-20211001130843302"></p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="虚拟机克隆"><a href="#虚拟机克隆" class="headerlink" title="虚拟机克隆"></a>虚拟机克隆</h3><p>如果你已经安装了一台linux操作系统， 还想要更多的， 没必要再重新安装， 直接克隆即可。</p><ul><li>方式1：直接拷贝一份安装好的虚拟机文件，然后用vmware打开</li><li>方式2：使用vmware的克隆操作。（注意：克隆时需要先关闭linux系统）</li></ul><h3 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h3><p>如果在使用虚拟机系统时，想要回到原先的摸一个状态，比如担心可能有些误操作造成系统异常，需要回到原先某个正常运行的状态，vmware提供了这样的功能，叫快照管理</p><p>快照管理类似于Git的分支管理，但使用时会占用一定的磁盘空间，建议在系统发生有意义的变化时使用。</p><h3 id="虚拟机迁移和删除"><a href="#虚拟机迁移和删除" class="headerlink" title="虚拟机迁移和删除"></a>虚拟机迁移和删除</h3><p>安装好的虚拟机，本质上就是（放在文件夹中的）文件。因此虚拟系统的迁移很方便，你可以把安装好的虚拟系统文件夹整体<strong>拷贝</strong>或者<strong>剪切</strong>到另外的位置使用。</p><p>删除也很简单，先在vmware中进行移除 （不会删除本地文件），再手动删除本地文件。</p><h3 id="windows和虚拟机共享文件"><a href="#windows和虚拟机共享文件" class="headerlink" title="windows和虚拟机共享文件"></a>windows和虚拟机共享文件</h3><p>安装vmtools</p><p>可以在windows下更好地管理vm虚拟机</p><p>可以设置wondows和centos的共享文件夹</p><p><img src="image-20211001145806913.png" alt="image-20211001145806913"></p><p><img src="image-20211001150308200.png" alt="image-20211001150308200"></p><h2 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Linux的文件系统采用级层式的树状目录结构，在此结构中的最上层是根目录”/“，然后在此目录下再创建其他的目录。</p><p><code>在Linux世界里，一切皆文件</code>，硬件设备、网络通信等资源也是通过文件管理。</p><ul><li><p>这样做最明显的好处是，开发者仅需要使用一套 API 和开发工具即可调取 Linux 系统中绝大部分的资源。</p></li><li><p>不利之处在于，使用任何硬件设备都必须与根目录下某一目录执行挂载操作，否则无法使用。我们知道，本身 Linux 具有一个以根目录为树根的文件目录结构，每个设备也同样如此，它们是相互独立的。如果我们想通过 Linux 上的根目录找到设备文件的目录结构，就必须将这两个文件系统目录合二为一，这就是挂载的真正含义。</p></li></ul><h3 id="具体目录结构"><a href="#具体目录结构" class="headerlink" title="具体目录结构"></a>具体目录结构</h3><p>了解即可</p><p>可以用<code>pwd</code>指令显示当前用户所在目录的绝对路径</p><ul><li><p>/bin <code>【常用】</code>：</p><p>是Binary的缩写，这个目录存放着最经常使用的命令。</p></li><li><p>/sbin：</p><p>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p>/home <code>【常用】</code> ：</p><p>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p></li><li><p>/root <code>【常用】</code>：</p><p>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p>/lib：</p><p>系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p>/lost+found：</p><p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p>/etc <code>【常用】</code>：</p><p>所有的系统管理所需要的配置文件和子目录my.conf。</p></li><li><p>/usr <code>【常用】</code>：</p><p>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</p></li><li><p>/boot <code>【常用】</code>：</p><p>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p>/proc <code>【不能动】</code>：</p><p>这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</p></li><li><p>/srv <code>【不能动】</code>：</p><p>service的缩写，该目录存放一些服务启动之后需要提供的数据。</p></li><li><p>/sys <code>【不能动】</code>：</p><p>这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。</p></li><li><p>/tmp：</p><p>这个目录是用来存放一些临时文件的。</p></li><li><p>/dev：</p><p>类似windows的设备管理器，把所有的硬件用文件的形式存储。</p></li><li><p>/media <code>【不能动】</code>：</p><p>linux系统会自动识别一些设备，例如U盘光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p></li><li><p>/mnt <code>【常用】</code>：</p><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。</p></li><li><p>/opt：</p><p>这是给主机额外安装软件所摆放的目录，如安装ORACLE数据库就可放到该目录下。默认为空。</p></li><li><p>/usr/local <code>【常用】</code>：</p><p>这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。</p></li><li><p>/var <code>【常用】</code>：</p><p>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</p></li><li><p>/selinux：</p><p>SELinux是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式， 可以自行设置。</p></li></ul><h2 id="Linux-远程连接"><a href="#Linux-远程连接" class="headerlink" title="Linux 远程连接"></a>Linux 远程连接</h2><p>为什么要远程连接Linux？</p><ol><li>Linux服务器是开发小组共享</li><li>正式上线的项目是运行在公网</li><li>因此程序员需要远程登录到Linux进行项目管理或者开发</li></ol><h3 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h3><p>xshell 7 <a href="https://www.netsarang.com/en/xshell/">XSHELL - The Industry’s Most Powerful SSH Client (netsarang.com)</a></p><ol><li><p>首先在虚拟机中通过ifconfig命令获取ip</p><img src="image-20211001165231780.png" alt="image-20211001165231780" style="zoom: 80%;"   /></li><li><p>在xshell中新建会话，填入对应ip</p><img src="image-20211001165423495.png" alt="image-20211001165423495" style="zoom: 80%;"  /></li><li><p>连接成功</p><img src = "image-20211001165938748.png" alt="image-20211001165938748.png" style="zoom: 80%;"  ></li></ol><h3 id="文件上传下载"><a href="#文件上传下载" class="headerlink" title="文件上传下载"></a>文件上传下载</h3><p>xshell只能进行远程命令式的操作，如果需要上传或下载文件，需要用到<code>Xftp</code> <a href="https://www.netsarang.com/zh/xftp/">XFTP - NetSarang Website</a></p><p>配置过程与xshell类似</p><ol><li><p>新建会话并输入对应主机ip，协议默认SFTP</p><img src="image-20211001170906472.png" alt="image-20211001170906472" style="zoom: 80%;"  /></li><li><p>输入系统对应的用户名和密码</p><img src="image-20211001171657031.png" alt="image-20211001171657031" style="zoom: 80%;"  /></li><li><p>连接成功</p><img src="image-20211001172731187.png" alt="image-20211001172731187" style="zoom: 67%;" /></li><li><p>（如果有乱码，则在属性中修改编码格式）</p><img src="image-20211001172459766.png" alt="image-20211001172459766" style="zoom: 67%;"  /><img src="image-20211001172553054.png" alt="image-20211001172553054" style="zoom: 67%;"  /></li></ol><h2 id="vi-amp-vim-编辑器"><a href="#vi-amp-vim-编辑器" class="headerlink" title="vi &amp; vim 编辑器"></a>vi &amp; vim 编辑器</h2><p>vim具有程序编辑的能力，可以看作是vi增强版本，可以生动地以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，因此被广泛使用。</p><h3 id="vi-和-vim-常用的三种模式"><a href="#vi-和-vim-常用的三种模式" class="headerlink" title="vi 和 vim 常用的三种模式"></a>vi 和 vim 常用的三种模式</h3><ul><li><p>正常模式（默认模式）</p><p>在这个模式中，可以使用<code>上下左右按键</code>来移动光标，你可以使用<code>删除字符</code>或<code>删除整行</code>来处理档案内容，也可以使用<code>复制、粘贴</code>来处理文件数据</p></li><li><p>插入模式</p><p>按下<code>i,I,o,O,a,A,r,R</code>等任何一个字母之后才会进入编辑模式</p></li><li><p>命令行模式</p><p>按Esc退出插入模式，然后输入”:”进入命令行模式。在这个模式中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等动作</p></li></ul><p><strong>各模式相互切换示意图</strong></p><img src="image-20211001190603554.png" alt="image-20211001190603554" style="zoom: 50%;"  /><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li>拷贝当前行 【yy】，拷贝当前向下5行 【5yy】，粘贴 【p】</li><li>删除当前行 【dd】，删除当前向下5行 【5dd】</li><li>在文件中查找某个单词，在<code>命令行模式</code>下输入【/关键字】，回车查找，按n查找下一个</li><li>设置文件行号【set nu】，取消文件行号【set nonu】</li><li>编辑文件，到达文档最末行/首行，<code>正常模式</code>下输入【G】/【gg】</li><li>撤销输入，在<code>正常模式</code>下输入【u】</li><li>编辑文件，光标移动到某行, <code>正常模式下</code>输入【shift+g】<ul><li>显示行号：set nu</li><li>输入行号这个数</li><li>输入shift+g</li></ul></li></ul><p><strong>Vim键盘图</strong></p><img src="image-20211001200549477.png" alt="image-20211001200549477" style="zoom: 80%;"  /><h2 id="关机-、-重启和用户登录注销"><a href="#关机-、-重启和用户登录注销" class="headerlink" title="关机 、 重启和用户登录注销"></a>关机 、 重启和用户登录注销</h2><h3 id="关机-amp-重启命令"><a href="#关机-amp-重启命令" class="headerlink" title="关机 &amp; 重启命令"></a>关机 &amp; 重启命令</h3><ul><li><p>shutdown -h now：表示立即关机</p></li><li><p>shutdown -h 1：表示1分钟后关机 （直接输入shutdown等效于shutdown -h 1）</p></li><li><p>shutdown -r now：立即重启</p></li><li><p>halt：关机，等效于shutdown -h now</p></li><li><p>reboot：重启，等效于shutdown -r now</p></li><li><p>sync：把内存的数据同步到磁盘</p><p><strong>当我们关机或者重启时，都应该先执行一下sync，防止数据丢失</strong></p><p><strong>现在的shutdown、halt、reboot等命令均已在关机前进行了sync</strong></p></li><li><p>logout：注销用户，<strong>在图形运行级别无效，在运行级别3有效</strong>。</p></li></ul><h3 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h3><ul><li><p>登陆时尽量少使用root账号，因为他是系统管理员，拥有最大权限。使用时要注意避免操作失误。可以利用普通用户登录，登录后再用”su - 用户名“来切换成系统管理员身份。</p></li><li><p>在提示符下驶入logout即可注销用户</p><p><strong>logout注销指令在图形运行级别无效，在运行级别3下有效。</strong></p><p><strong>运行级别这个概念，后面介绍。</strong></p></li></ul><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>基本语法 <code>useradd 用户名</code></p><p>案例：添加一个用户milan <strong>==&gt;</strong> useradd milan</p><p> 默认该用户的家目录在/home/milan</p><p>当创建用户成功后，会自动创建和用户同名的家目录</p><p>也可以通过<code>useradd -d 指定目录 用户名</code>，给新创建的用户指定家目录</p><h3 id="指定-amp-修改密码"><a href="#指定-amp-修改密码" class="headerlink" title="指定 &amp; 修改密码"></a>指定 &amp; 修改密码</h3><p>基本语法 <code>passwd 用户名</code></p><p>案例：给milan指定密码 <strong>==&gt;</strong> passwd milan</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>基本语法 <code>userdel 用户名</code></p><p>案例1：删除用户milan，但要保留家目录 <strong>==&gt;</strong> userdel milan</p><p>案例2：删除用户milan以及主目录（home/milan） <strong>==&gt;</strong> userdel -r milan</p><p><strong>一般情况下建议保留家目录</strong></p><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><p>基本语法 <code>id 用户名</code></p><p>案例：查询root信息 <strong>==&gt;</strong> id root</p><p>当用户不存在时，返回无此用户</p><h4 id="查询当前用户-登录用户"><a href="#查询当前用户-登录用户" class="headerlink" title="查询当前用户/登录用户"></a>查询当前用户/登录用户</h4><p>基本语法 </p><ul><li><code>whoami</code> 查询当前用户</li><li><code>who am i</code> 查询登录用户</li></ul><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>基本语法 <code>su - 用户名</code></p><p>在Linux中，如果当前用户的权限不够，可以通过su - 指令切换到高权限用户，比如root。从权限高的用户切换到权限低的用户不需要输入密码，反之则需要。当需要返回到原来用户时，使用<code>exit/logout</code>指令。</p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>类似于角色，系统可以对有共性/权限的多个用户进行统一的管理。</p><p><strong>每个用户至少要属于一个组！</strong></p><img src="image-20211001231506984.png" alt="image-20211001231506984" style="zoom:80%;"  /><p>基本语法</p><ul><li>添加组 <code>groupadd 组名</code></li><li>删除组 <code>groupdel 组名</code></li><li>创建用户时指定组 <code>useradd -g 组名 用户名</code></li><li>修改用户组 <code>usermod -g 组名 用户名</code></li></ul><h3 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h3><ol><li> /etc/passwd 文件</li></ol><ul><li>用户（user）的配置文件，记录用户的各种信息。</li><li>每行的含义：用户名：口令：用户标识号：注释性描述：主目录：登录shell</li></ul><ol start="2"><li> /etc/shadow 文件</li></ol><ul><li>口令配置文件</li><li>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</li></ul><ol start="3"><li> /etc/group 文件</li></ol><ul><li>组（group）的配置文件，记录Linux包含的组的信息。</li><li>每行含义：组名：口令：组标识号：组内用户列表（隐藏）</li></ul><h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><p>共有7个运行级别：</p><ol start="0"><li><p>关机</p></li><li><p>单用户【找回丢失密码】</p></li><li><p>多用户状态没有网络服务</p></li><li><p>多用户状态有网络服务</p></li><li><p>系统未使用保留给用户</p></li><li><p>图形界面</p></li><li><p>系统重启</p></li></ol><p>常用运行级别是3和5，也可以指定默认运行级别，后面演示。</p><h3 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h3><p>基本指令 <code>init [0123456]</code></p><h3 id="Centos7后运行级别说明"><a href="#Centos7后运行级别说明" class="headerlink" title="Centos7后运行级别说明"></a>Centos7后运行级别说明</h3><p>在Centos7以前，在/etc/inittab文件中进行修改</p><p>在Centos7以后进行了简化，如下：</p><p>​    multi-user.target: analogous to runlevel 3</p><p>​    graphical.target: analogous to runlevel 5</p><p>查看当前默认运行级别 <code>systemctl get-default</code></p><p>设置默认运行级别 <code>systemctl set-default xxx.target</code></p><h2 id="找回root密码-【面试题】"><a href="#找回root密码-【面试题】" class="headerlink" title="找回root密码 【面试题】"></a>找回root密码 【面试题】</h2><p>不同版本的系统操作流程略有区别，这里适用于Centos7之后的版本。</p><ol><li><p>首先启动系统，进入开机界面，在页面中按”e”进入编辑界面</p><img src="image-20211002000436645.png" alt="image-20211002000436645" style="zoom:80%;"  /></li><li><p>进入编辑界面，使用键盘上的上下键把光标往下移动，找到以”linux16”开头内容所在的行数，在行的最后面输入 <code>init=/bin/sh</code></p><img src="image-20211002000601694.png" alt="image-20211002000601694" style="zoom:80%;"  /></li><li><p>输入完成后，按快捷键<code>Ctrl + x</code>进入单用户模式</p></li><li><p>在光标闪烁的位置输入<code>mount -o remount,rw /</code>, 然后按回车键</p><img src="image-20211002000744156.png" alt="image-20211002000744156"   /></li><li><p>在新的一行最后面输入<code>passwd</code>， 完成后按键盘的回车键（Enter）。输入密码，<strong>然后再次确认密码即</strong>可(<strong>密码长度最好8位以上,但不是必须的</strong>), 密码修改成功后，会显示passwd…..的样式，说明密码修改成功</p><img src="image-20211002001001897.png" alt="image-20211002001001897"   /></li><li><p>在鼠标闪烁的位置中（最后一行中）输入<code>touch /.autorelabel</code>，完成后按键盘的回车键（Enter）</p></li><li><p>继续在光标闪烁的位置中，输入<code>exec /sbin/init</code>，完成后按键盘的回车键（Enter）,等待系统自动修改密码(<strong>这个过程时间可能有点长，耐心等待</strong>)，完成后，系统会自动重启, <strong>新的密码生效</strong>了</p></li></ol><h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><ul><li><code>man [命令或配置文件] </code>（获得帮助信息）</li><li><code>help 命令</code> （获得shell内置命令得帮助信息）</li></ul><h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><ol><li><p>pwd指令：显示当前工作目录的绝对路径</p><p>基本语法 <code>pwd</code></p></li></ol><ol start="2"><li><p>ls指令：查看当前目录的内容信息</p><p>基本语法 <code>ls [选项] [目录或文件]</code></p><p>常用选项：</p><ul><li>-a：显示当前目录所有的文件和目录，包括隐藏的</li><li>-l：以列表的方式显示信息</li></ul></li></ol><ol start="3"><li><p>cd指令：切换到指定目录</p><p>基本语法 <code>cd [参数]</code></p><p><strong>绝对路径和相对路径：</strong>绝对路径是从根目录开始，相对目录是从当前位置开始</p><p><img src="image-20211002165846507.png" alt="image-20211002165846507"></p><p>cd ~ 或者 cd：回到自己的家目录，比如你是root，则到/root；如果是tom，则到/home/tom</p><p>cd..：回到当前目录的上一级目录</p><p>案例：</p><ul><li>使用绝对路径切换到root目录 <strong>==&gt;</strong> cd /root</li><li>使用相对路径到/root，当前在/home/tom <strong>==&gt;</strong> cd ../../root</li></ul></li></ol><ol start="4"><li><p>mkdir指令：创建目录</p><p>基本语法 <code>mkdir [选项] 要创建的目录</code></p><p>常用选项</p><ul><li>-p：创建多级目录</li></ul><p>实例：</p><ul><li>创建一个目录/home/dog <strong>==&gt;</strong> mkdir /home/dog</li><li>创建多级目录/home/animal/tiger <strong>==&gt;</strong> mkdir -p /home/animal/tiger</li></ul></li></ol><ol start="5"><li><p>rmdir指令：删除空目录</p><p>基本语法 <code>rmdir [选项] 要删除的空目录</code></p><p>案例：</p><ul><li>删除目录/home/dog <strong>==&gt;</strong> rmdir /home/dog</li></ul><p>使用细节：</p><ul><li>mkdir删除的是空目录，如果目录下有内容是无法删除的。</li><li>如果需要删除非空目录，需要使用rm -rf删除</li></ul></li></ol><ol start="6"><li><p>touch指令：创建空文件</p><p>基本语法 <code>touch 文件名称</code></p><p>案例：</p><ul><li>创建一个空文件hello.txt <strong>==&gt;</strong> touch hello.txt</li></ul></li></ol><ol start="7"><li><p>cp指令：拷贝文件到指定目录</p><p>基本语法 <code>cp [选项] source dest</code></p><p>常用选项：</p><ul><li>-r：递归复制整个文件夹</li></ul><p>实例：</p><ul><li>将/home/hello.txt拷贝到/home/bbb目录下 <strong>==&gt;</strong> cp /home/hello.txt /home/bbb</li><li>将/home/bbb整个目录拷贝到/opt <strong>==&gt;</strong> cp -r /home/bbb /opt</li></ul><p>使用细节：</p><ul><li>强制覆盖不提示的方法：\cp, \cp -r </li></ul></li></ol><ol start="8"><li><p>rm指令：移除文件或目录</p><p>基本语法 <code>rm [选项] 要删除的文件或目录</code></p><p>常用选项：</p><ul><li><p>-r：递归删除整个文件夹</p></li><li><p>-f：强制删除不提示</p></li></ul><p>实例：</p><ul><li><p>将/home/hello.txt删除 <strong>==&gt;</strong> rm /home/hello.txt</p></li><li><p>递归删除整个文件夹/home/bbb <strong>==&gt;</strong> rm -rf /home/bbb</p></li></ul><p>使用细节：</p><ul><li><p>想要强制删除不提示，带上-f参数即可</p></li><li><p><strong>使用前一定慎重！！！</strong></p></li></ul></li></ol><ol start="9"><li><p>mv指令：移动文件与目录 或 重命名</p><p>基本语法：</p><ul><li><code>mv oldFileName newFileName</code> 重命名</li><li><code> mv source dest</code> 移动文件</li></ul><p>实例：</p><ul><li><p>将/home/cat.txt文件重命名为pig.txt <strong>==&gt;</strong> mv /home/cat.txt /home/pig.txt</p></li><li><p>将/home/pig.txt文件移动到/root目录下 <strong>==&gt;</strong> mv /home/pig.txt /root</p></li><li><p>移动目录/opt/bbb到/home下 <strong>==&gt;</strong> mv /opt/bbb /home</p></li></ul></li></ol><ol start="10"><li><p>cat指令：查看文件内容</p><p>基本语法 <code>cat [选项] 文件名</code></p><p>常用选项：</p><ul><li>-n： 显示行号</li></ul><p>实例：</p><ul><li>显示/etc/profile并显示行号 <strong>==&gt;</strong> cat -n /etc/profile</li></ul><p>使用细节：</p><ul><li>cat只能浏览文件，而不能修改文件。为了浏览方便，一般会带上管道命令|more</li><li>e.g. cat -n /etc/profile | more</li></ul></li></ol><ol start="11"><li><p>more指令</p><p>基本语法 <code>more 文件名</code></p><p>more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。其中内置了若干快捷键（交互的指令），如下：</p><p><img src="image-20211002211740449.png" alt="image-20211002211740449"></p><p>实例：</p><ul><li>查看/etc/profile文件 <strong>==&gt;</strong> more /etc/profile</li></ul></li><li><p>less指令</p><p>基本语法 <code>less 文件名</code></p><p>less指令用来分屏查看文件的内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。<strong>less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于大型文件有较高的效率。</strong>操作说明如下：</p><p><img src="image-20211002212230782.png" alt="image-20211002212230782"></p><p>实例：</p><ul><li>查看/etc/profile文件 <strong>==&gt;</strong> less /etc/profile</li></ul></li></ol><ol start="13"><li><p>echo指令：输出内容到控制台</p><p>基本语法 <code>echo [选项] [输出内容]</code></p><p>实例：</p><ul><li>输出环境变量$HOSTNAME <strong>==&gt;</strong> echo $HOSTNAME</li><li>输出hello world <strong>==&gt;</strong> echo “hello world” （可以不加双引号）</li></ul></li><li><p>head指令：输出文件头部内容，默认输出前10行</p><p>基本语法 <code>head [-n number] 文件名</code></p><p>案例：</p><ul><li>查看/etc/profile前5行 <strong>==&gt;</strong> head -n 5 /etc/profile</li></ul></li><li><p>tail指令：输出文件尾部内容，默认输出最后10行</p><p>基本语法：</p><ul><li><code>tail [-n number] 文件名</code> 输出最后number行文件</li><li><code>tail -f 文件名</code> 实时追踪该文档的所有更新</li></ul><p>实例：</p><ul><li>查看/etc/profile最后5行 <strong>==&gt;</strong> tail-n 5 /etc/profile</li><li>实时监控mydate.txt <strong>==&gt;</strong> tail -f mydate.txt （文件发生变化后会直接在控制台输出）</li></ul></li><li><p>&gt; 输出重定向指令 和 &gt;&gt; 追加指令</p><p>基本语法：</p><ul><li><code>ls -l &gt; 文件</code> 列表的内容写入文件中（覆盖写）</li><li><code>ls -al &gt;&gt; 文件</code> 列表的内容追加到文件末尾</li><li><code>cat 文件1 &gt; 文件2</code> 将文件1的内容覆盖到文件2</li><li><code>echo ”内容“ &gt;&gt; 文件</code> 把内容追加到文件末尾</li></ul><p>实例：</p><ul><li>将/home目录下的文件列表写入到/home/info.txt中，覆盖写入 <strong>==&gt;</strong> ls -l /home &gt; /home/info.txt （如果info.txt没有，会自动创建）</li><li>将当前日历信息追加到/home/mycal文件中 <strong>==&gt;</strong> cal &gt;&gt; /home/mycal</li></ul></li><li><p>ln指令：软链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</p><p>基本语法 <code>ln -s 原文件或目录 软链接名</code></p><p>案例：</p><ul><li>在/home目录下创建一个软链接myroot，连接到/root目录 <strong>==&gt;</strong> ln -s /root /home/myroot</li><li>删除软连接myroot <strong>==&gt;</strong> rm /home/myroot</li></ul><p>细节说明：</p><ul><li>当我们使用pwd指令查看目录时，看到的仍然是软链接所在的目录</li></ul></li><li><p>history指令：查看已执行过的历史命令，也可以执行历史命令</p><p>基本语法 <code>history [n]</code></p><p>实例：</p><ul><li>显示所有的历史命令 <strong>==&gt;</strong> history</li><li>显示最近使用过的10个指令 <strong>==&gt;</strong> history 10</li><li>执行历史编号为5的指令 <strong>==&gt;</strong> !5 （使用前先用history查看指令的历史编号）</li></ul></li></ol><h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><ol><li><p>date指令：显示当前日期</p><p>基本语法：</p><ul><li><p><code>date</code> 显示当前时间 </p></li><li><p><code>date +%Y</code> 显示当前年份 </p></li><li><p><code>date +%m</code> 显示当前月份 </p></li><li><p><code>date +%d</code> 显示当前是哪一天 </p></li><li><p><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> 显示年月日时分秒</p></li></ul></li></ol><ol start="2"><li><p>date指令：设置日期</p><p>基本语法 <code>date -s 字符串时间</code></p><p>实例：</p><ul><li>date -s “2021-6-20 16:44:30”</li></ul></li><li><p>cal指令：查看日历</p><p>基本语法 <code>cal [选项]</code></p><p>实例：</p><ul><li><p>显示当前月份的日历 <strong>==&gt;</strong> cal</p></li><li><p>显示2021年的日历 <strong>==&gt;</strong> cal 2021</p></li></ul></li></ol><h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h3><ol><li><p>find指令：从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端</p><p>基本语法 <code>find [搜索范围] [选项]</code></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td>-user&lt;用户名&gt;</td><td>查找属于指定用户名所有文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件（+n大于，-n小于，n等于，单位有k、M、G）</td></tr></tbody></table><p>实例：</p><ul><li>按文件名，查找/home目录下的hello.txt文件 <strong>==&gt;</strong> find /home -name hello.txt</li><li>按拥有者，查找/opt目录下用户名为nobody的文件 <strong>==&gt;</strong> find /opt -user nobody</li><li>查找整个linux系统下大于200M的文件 <strong>==&gt;</strong> find / -size +200M</li></ul></li><li><p>locate指令</p><p>locate指令可以快速定位文件路径。locate命令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位的文件名。Locate指令无需遍历整个文件系统，查询速度较快。为了保障查询结果的准确度，管理员必须定期更新locate时刻。</p><p>基本语法 <code>locate 文件名</code></p><p>特别说明：由于locate指令基于数据进行查询，所以第一次运行前，必须是使用updatedb指令创建locate数据库</p><p>实例：</p><ul><li>用locate指令快速定位hello.txt文件所在目录 <strong>==&gt;</strong> updatedb, locate hello.txt</li></ul></li></ol><ol start="3"><li><p>which指令：查看某个指令在哪个目录下</p><p>基本语法 <code>which 指令名</code></p><p>实例：</p><ul><li>查看ls指令在哪个目录 <strong>==&gt;</strong> which ls</li></ul></li></ol><ol start="4"><li><p>grep指令和管道符号|</p><p>grep过滤查找，管道符，“|“，表示将前一个命令输出传递给后面的命令处理。grep一般和管道符号一起使用。</p><p>基本语法 <code>grep [选项] 查找内容 源文件</code></p><p>常用选项：</p><ul><li>-n 显示匹配行及行号</li><li>-i 忽略字母大小写</li></ul><p>实例：过滤查找hello.txt中的”yes“文本</p><ul><li>写法1：cat /home/hello.txt | grep -n “yes”</li><li>写法2：grep -n “yes” /home/hello.txt</li></ul></li></ol><h2 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h2><ol><li><p>gzip/gunzip指令：只能用于压缩/解压文件</p><p>基本语法 <code>gzip/gunzip 文件名</code></p><p>使用细节：压缩后原文件会消失，解压后压缩文件会消失</p></li><li><p>zip/unzip指令：用于压缩/解压文件或文件夹</p><p>基本语法：<code>zip/unzip [选项] xxx.zip 压缩内容</code></p><p>常用选项：</p><ul><li>-r：递归压缩，即压缩目录 （zip常用）</li><li>-d&lt;目录&gt;：指定解压后文件的存放目录（unzip常用）</li></ul></li></ol><ol start="3"><li><p>tar指令：打包指令</p><p>基本语法：<code>tar [选项] xxx.tar(.gz) 打包内容</code></p><p>选项说明：</p><table><thead><tr><th>选项</th><th align="left">功能</th></tr></thead><tbody><tr><td>-c</td><td align="left">产生.tar打包文件</td></tr><tr><td>-v</td><td align="left">显示详细信息</td></tr><tr><td>-f</td><td align="left">指定压缩后的文件名</td></tr><tr><td>-z</td><td align="left">打包同时压缩</td></tr><tr><td>-x</td><td align="left">解包.tar文件</td></tr></tbody></table><p>实例：</p><ul><li>压缩多个文件，将pig.txt和cat.txt 压缩成  pc.tar.gz <strong>==&gt;</strong> tar -zcvf pc.tar.gz pig.txt cat.txt</li><li>将/home的文件夹压缩成myhome.tar.gz <strong>==&gt;</strong> tar -zcvf myhome.tar.gz /home</li><li>pc.tar.gz 解压到当前目录 <strong>==&gt;</strong> tar -zxvf pc.tar.gz</li><li>将myhome.tar.gz  解压到/opt/tmp2目录下 <strong>==&gt;</strong> tar -zxvf myhome.tar.gz <code>-C</code> opt/tmp2 (-C后面指定解压目录)</li></ul></li></ol><h2 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h2><p>在Linux中的每个用户必须属于至少一个组，不能独立于组外。在Linux中每个文件都有所有者、所在组、其他组的概念</p><p><img src="image-20211002233042774.png" alt="image-20211002233042774"></p><p>一个文件a.txt由tom创建，tom属于组1，那么a.txt的所有者是tom，所在组是组1。组1中的用户对a.txt有一定的权限。组2、组3不包含tom，它们相对于a.txt的所在组而言是其他组。</p><h3 id="文件-目录-所有者"><a href="#文件-目录-所有者" class="headerlink" title="文件/目录 所有者"></a>文件/目录 所有者</h3><p>一般为文件的创建者，谁创建了该文件，就自然成为该文件的所有者。</p><h4 id="查看文件的所有者"><a href="#查看文件的所有者" class="headerlink" title="查看文件的所有者"></a>查看文件的所有者</h4><p>可以通过ls指令查看 <code>ls -ahl</code></p><img src="image-20211003001542456.png" alt="image-20211003001542456" style="zoom: 80%;" /><h4 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h4><p>基本指令 <code>chown 用户名 文件名</code></p><p>实例：</p><ul><li>将apple.txt文件的所有者修改成tom <strong>==&gt;</strong> chown tom apple.txt</li></ul><h3 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h3><p>基本指令 <code>groupadd 组名</code></p><p>实例：</p><ul><li>创建一个monster组 <strong>==&gt;</strong> groupadd monster</li><li>创建一个用户fox，并加入到monster组中 <strong>==&gt;</strong> useradd -g monster fox</li></ul><h3 id="文件-目录-所在组"><a href="#文件-目录-所在组" class="headerlink" title="文件/目录 所在组"></a>文件/目录 所在组</h3><p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组</p><h4 id="查看文件-目录所在组"><a href="#查看文件-目录所在组" class="headerlink" title="查看文件/目录所在组"></a>查看文件/目录所在组</h4><p>可以通过ls指令查看 <code>ls -ahl</code></p><img src="image-20211003002132904.png" alt="image-20211003002132904"  /><h4 id="修改文件-目录的所在组"><a href="#修改文件-目录的所在组" class="headerlink" title="修改文件/目录的所在组"></a>修改文件/目录的所在组</h4><p>基本指令：</p><ul><li><code>chgrp 组名 文件/目录</code> 改变所在组</li><li>-R 如果是目录，使其下所有子文件或目录递归生效</li></ul><p>实例：</p><ul><li>修改orange.txt文件到fruit组 <ol><li>groupadd fruit</li><li>touch orange.txt (假设在root权限下创建，默认属于root组)</li><li>chgrp fruit orange.txt</li></ol></li><li>将/home/test目录下所有的文件和目录的所在组都改成shaolin <strong>==&gt;</strong> chgrp -R shaolin /home/test</li></ul><h3 id="其他组"><a href="#其他组" class="headerlink" title="其他组"></a>其他组</h3><p>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其它组</p><h3 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h3><p>基本指令：</p><ul><li><code>usermod -g 新组名 用户名</code></li><li><code>usermod -d 目录名 用户名</code> 改变该用户登录的初始目录 （<strong>特别说明：</strong>用户需要有进入到新目录的权限）</li></ul><p>实例：</p><ul><li>将用户zwj从原来所在组修改到wudang组 <strong>==&gt;</strong> usermod -g wudang zwj</li></ul><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>ls -l显示如下内容</p><p>-rw-r–r–.  1 root root  121 10月  2 21:37 hello.java</p><p>0-9位说明：</p><ul><li><p>第0位确定文件类型（d，-，l，c，b）<br>d是目录，相当于windows的文件夹</p><p>-是普通文件</p><p>l是链接文件，相当于windows的快捷方式<br>c是字符设备文件，鼠标，键盘<br>b是块设备，比如硬盘</p></li><li><p>第1-3位确定<strong>所有者</strong>（该文件的所有者）拥有该文件的权限 [User]</p></li><li><p>第4-6位确定<strong>所属组</strong>（同用户组的）拥有该文件的权限 [Group]</p></li><li><p>第7-9位确定<strong>其他用户</strong>拥有该文件的权限 [Other]</p></li></ul><h3 id="rwx权限"><a href="#rwx权限" class="headerlink" title="rwx权限"></a>rwx权限</h3><h4 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a>rwx作用到文件</h4><p>【r】代表可读（read）：可以读取、查看</p><p>【w】代表可写（write）：可以修改，但是不代表可以删除该文件，<strong>删除一个文件的前提条件是对该文件所在的目录有写权限</strong>，才能删除该文件</p><p>【x】代表可执行（execute）：可以被执行</p><h4 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a>rwx作用到目录</h4><p>【r】代表可读（read）：可以读取，ls查看目录内容</p><p>【w】代表可写（write）：可以修改，对目录内创建+删除+重命名目录名</p><p>【x】代表可执行（execute）：可以进入该目录</p><h3 id="文件及目录权限实际案例"><a href="#文件及目录权限实际案例" class="headerlink" title="文件及目录权限实际案例"></a>文件及目录权限实际案例</h3><p>ls -l显示如下内容</p><p>-rw-r–r–.  1 root root  121 10月  2 21:37 hello.java</p><p>10个字符确定不同用户能对文件干什么：</p><ul><li>第一个字符代表文件类型： -l d c b</li><li>其余字符每三个一组（rwx）读（r）写（w）执行（x）</li><li>第一组rw-：文件拥有者的权限是读、写但不能执行</li><li>第二组r–：与文件拥有者同一组的用户的权限是读、但不能写和执行</li><li>第三组r–-：不与文件拥有者同组的其他用户的权限是读、但不能写和执行</li></ul><p>可用数字表示为：r=4，w=2，x=1。 因此rwx = 4 + 2 + 1 = 7</p><p>其他说明：</p><ul><li>1 若是文件：硬件连接 若是目录：子目录数+文件数</li><li>root 用户</li><li>root 组</li><li>121 文件大小（字节），如果是文件夹显示4096字节</li><li>10月  2 21:37</li><li>hello.java 文件名</li></ul><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>基本指令 <code>chmod [选项,选项...] 文件/目录名</code></p><h4 id="第一种方式：-、-、-变更权限"><a href="#第一种方式：-、-、-变更权限" class="headerlink" title="第一种方式：+、-、=变更权限"></a>第一种方式：+、-、=变更权限</h4><p>u：所有者</p><p>q：所有组 </p><p>o：其他用户 </p><p>a：所有人（u、g、o的总和）</p><p>指令示例：</p><ul><li>chmod u=rwx,g=rx,o=x 文件/目录名</li><li>chmod o+w 文件/目录名</li><li>chmod a-x 文件/目录名</li></ul><p>实例：</p><ul><li>给hello.java文件的所有者读写执行的权限，给所在组读执行权限， 给其他组读执行权限 <strong>==&gt;</strong> chmod u=rwx,g=rx,0=x hello.java</li><li>给hello.java文件的所有者除去执行的权限，增加组写的权限 <strong>==&gt;</strong> chmod u-x,g+w hello.java</li><li>给hello.java文件的所有用户添加读的权限 <strong>==&gt;</strong> chmod a+r hello.java</li></ul><h4 id="第二种方式：通过数字变更权限"><a href="#第二种方式：通过数字变更权限" class="headerlink" title="第二种方式：通过数字变更权限"></a>第二种方式：通过数字变更权限</h4><p>r=4，w=2，x=1， rwx=4+2+1=7</p><p>chmod u=rwx,g=rx,o=x 文件目录名 </p><p>相当于chmod 751 文件目录</p><p>实例：</p><ul><li>将/home/hello.java文件的权限修改成 rwxr-xr-x,使用数字的方式实现 <strong>==&gt;</strong> chmod 755 /home/hello.java</li></ul><h3 id="修改文件所有者-1"><a href="#修改文件所有者-1" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><p>基本指令：</p><ul><li> <code>chown newowner 文件/目录</code>  改变所有者</li><li><code>chown newowner:newgroup 文件/目录</code> 改变所有者和所在组</li><li>-R 如果是目录，则使其下所有子文件或目录递归生效</li></ul><p>实例：</p><ul><li>将/home/hello.java文件的所有者修改成tom <strong>==&gt;</strong> chown tom /home/hello.java</li><li>将/home/test目录下所有的文件和目录的所有者都修改成tom <strong>==&gt;</strong> chown -R tom /home/test</li></ul><h2 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h2><h3 id="crond-任务调度"><a href="#crond-任务调度" class="headerlink" title="crond 任务调度"></a>crond 任务调度</h3><p>crontab 进行定时任务的设置</p><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><ul><li><p>任务调度：是指系统在某个时间执行的特定的命令或程序。</p></li><li><p>任务调度分类.</p><ul><li>系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</li><li>个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份</li></ul><p><img src="image-20211015124511506.png" alt="image-20211015124511506"></p></li></ul><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p><code>crontab [选项]</code></p><p>常用选项：</p><ul><li>-e 编辑crontab定时任务 </li><li>-l 查询crontab任务 </li><li>-r 删除当前用户所有的crontab任务</li></ul><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ul><li>设置任务调度文件：/etc/crontab</li><li>设置个人任务调度。执行crontab -e命令</li><li>接着输入任务到调度文件</li><li>例如：<ul><li>*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt </li><li>意思说每个小时的每分钟执行ls -l /etc/ &gt; /tmp/to.txt 命令</li></ul></li></ul><p>参数细节说明：</p><p>5个占位符的说明</p><p><img src="image-20211015130318394.png" alt="image-20211015130318394"></p><p>特殊符号的说明：</p><p><img src="image-20211015150607827.png" alt="image-20211015150607827"></p><p>特殊时间执行案例：</p><p><img src="image-20211015150803821.png" alt="image-20211015150803821"></p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li><p>每隔1分钟，就将当前的日期信息，追加到/tmp/mydate文件中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e </span><br><span class="line">*/1 * * * * data &gt;&gt; /tmp/mydata</span><br></pre></td></tr></table></figure></li><li><p>每隔1分钟，将当前日期和日历都追加到/home/mycal文件中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步: 编辑一个脚本文件</span><br><span class="line">vim /home/my.sh</span><br><span class="line">date &gt;&gt; /home/mycal</span><br><span class="line">cal &gt;&gt; /home/mycal</span><br><span class="line"></span><br><span class="line">第二步: 给my.sh增加执行权限 (必须，否则没权限无法执行)</span><br><span class="line">chmod u+x /home/my.sh</span><br><span class="line"></span><br><span class="line">第三步:</span><br><span class="line">crontab -e</span><br><span class="line">*/1 * * * * /home/my.sh</span><br></pre></td></tr></table></figure></li><li><p>每天凌晨2:00将mysql数据库testdb，备份到文件中，提示：指令为mysqldump -u root -p 密码 数据库 &gt;&gt; /home/bd.bak</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">0 2 * * * mysqldump -u root -proot testdb &gt; /home/db.bak</span><br></pre></td></tr></table></figure></li></ol><h4 id="crond相关指令"><a href="#crond相关指令" class="headerlink" title="crond相关指令"></a>crond相关指令</h4><p><code>crontab -r</code> 终止任务调度</p><p><code>crontab -l</code> 列出当前有哪些任务调度</p><p><code>service crond restart</code> 重启任务调度</p><h3 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行</p></li><li><p>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业</p></li><li><p>at命令是<strong>一次性定时任务计划</strong>，执行完一个任务后不再执行此任务了</p></li><li><p>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep atd</span><br></pre></td></tr></table></figure></li><li><p>示意图：</p><p><img src="image-20211015152727550.png" alt="image-20211015152727550"></p><p>执行完就会移出队列了，所以不会反复执行</p></li></ul><h4 id="at-命令格式"><a href="#at-命令格式" class="headerlink" title="at 命令格式"></a>at 命令格式</h4><p><code>at [选项] [时间]</code></p><p>输入完指令后，要连续按<strong>两次</strong>ctrl + D 结束at命令输入</p><h4 id="at-命令选项"><a href="#at-命令选项" class="headerlink" title="at 命令选项"></a>at 命令选项</h4><p><img src="image-20211015152930841.png" alt="image-20211015152930841"></p><h4 id="at-时间定义"><a href="#at-时间定义" class="headerlink" title="at 时间定义"></a>at 时间定义</h4><p><img src="image-20211015153110423.png" alt="image-20211015153110423"></p><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li><p>2天后的下午5点执行/bin/ls /home</p><p><img src="image-20211015153245525.png" alt="image-20211015153245525"></p></li><li><p>atq命令来查看系统中没有执行的工作任务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atq</span><br></pre></td></tr></table></figure></li><li><p>明天17点钟，输出时间到指定文件内，比如/root/date100.log</p><p><img src="image-20211015153405541.png" alt="image-20211015153405541"></p></li><li><p>2分钟后，输出时间到指定文件内，比如 /root/date200.log</p><p><img src="image-20211015153511968.png" alt="image-20211015153511968"></p></li><li><p>删除已经设置的任务， <code>atrm 编号</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atq // 先查看还未执行的任务编号</span><br><span class="line">atrm 4 // 删除编号为4的任务</span><br></pre></td></tr></table></figure></li></ol><h2 id="Linux-磁盘分区"><a href="#Linux-磁盘分区" class="headerlink" title="Linux 磁盘分区"></a>Linux 磁盘分区</h2><h3 id="Linux-分区"><a href="#Linux-分区" class="headerlink" title="Linux 分区"></a>Linux 分区</h3><h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><ol><li><p>Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分</p></li><li><p>Linux采用了一种叫”载入“的处理方法，它的整个文件系统包含了一整套的目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得</p></li><li><p>示意图：</p><p><img src="image-20211015162207598.png" alt="image-20211015162207598"></p></li></ol><h4 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a>硬盘说明</h4><ol><li><p>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</p></li><li><p>对于IDE硬盘，驱动驱动标识符为” hdx~ “，其中”hd“表明分区所在的设备类型，这里是指IDE硬盘了。”x“为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），”~“代表分区，前四个分区用数字1到4表示，他们是主分区和拓展分区；从5开始就是逻辑分区。</p><p>例如，hda3表示为第一个IDE硬盘上的第三个主分区或拓展分区，hdb2表示为第二个IDE硬盘上的第二个主分区或拓展分区</p></li><li><p>对于SCSI硬盘则标识为”sdx~“，SCSI硬盘是用”sd“来表示分区所在设备的类型的，其余则和IDE硬盘的标识方式一样</p></li></ol><h4 id="查看所有设备挂载情况"><a href="#查看所有设备挂载情况" class="headerlink" title="查看所有设备挂载情况"></a>查看所有设备挂载情况</h4><p>命令：<code>lsblk</code> or <code>lsblk -f</code></p><p><img src="image-20211015162634171.png" alt="image-20211015162634171"></p><p><img src="image-20211015162650314.png" alt="image-20211015162650314"></p><p>UUID是分区的唯一标识符，40位</p><h3 id="挂载的经典案例"><a href="#挂载的经典案例" class="headerlink" title="挂载的经典案例"></a>挂载的经典案例</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>以<strong>增加一块硬盘</strong>为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。</p><h4 id="如何增加一块硬盘？"><a href="#如何增加一块硬盘？" class="headerlink" title="如何增加一块硬盘？"></a>如何增加一块硬盘？</h4><ol><li>虚拟机添加硬盘</li><li>分区</li><li>格式化</li><li>挂载</li><li>设置可以自动挂载</li></ol><h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><p>在<strong>虚拟机</strong>菜单中，选择<strong>设置</strong>，然后设备列表里添加硬盘，然后一路<strong>下一步</strong>，中间只有选择磁盘大小的地方需要修改，直到完成。然后重启系统才能识别。</p><p><img src="image-20211015163555052.png" alt="image-20211015163555052"></p><h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><p>分区命令 <code>fdisk /dev/sdb</code> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev（device)这个目录中包含了所有Linux系统中使用的外部设备。但是不是存放外部设备的驱动程序。它实际上是一个访问这些外部设备的端口。我们可以非常方便的去访问这些外部设备，和访问一个文件，一个目录没有任何区别</span><br></pre></td></tr></table></figure><p>开始对 /sdb分区</p><ul><li><p>m    显示命令列表 </p></li><li><p>p    显示磁盘分区 同 fdisk -l </p></li><li><p>n    新增分区 </p></li><li><p>d    删除分区 </p></li><li><p>w    写入并退出 </p></li></ul><p>说明：开始分区后输入n，新增分区，然后选者p，分区类型为主分区。两次回车默认剩余全部空间。最后输入w写入分区并退出，若不保存退出输入q</p><p><img src="image-20211015163940155.png" alt="image-20211015163940155"></p><h5 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h5><p>格式化磁盘</p><p>分区命令：<code>mkfs -t ext4 /dev/sdb1</code></p><p>其中ext4是分区类型</p><h5 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h5><p>挂载：将一个分区与一个目录联系起来</p><p><code>mount 设备名称 挂载目录</code></p><p>例如：mount /dev/sdb1 /newdisk</p><p>解除挂载：<code>umount 设备名称 or 挂载目录</code></p><p>例如：umount /dev/sdb1 或者 umount /newdisk</p><p><strong>注意：用命令行挂载，重启后就会失效</strong></p><h5 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h5><p>永久挂载：通过修改/etc/fstab 实现挂载</p><p><img src="image-20211015164713199.png" alt="image-20211015164713199"></p><p>vim /etc/fstab打开文件</p><p>第一个位置可以写UUID或者设备号</p><p>第二个位置是挂载目录</p><p>最后一个位置写0 0即可</p><p>添加完成后，执行mount -a即刻生效</p><h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><h4 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h4><p>基本语法 <code>df -h</code></p><p><img src="image-20211015165013147.png" alt="image-20211015165013147"></p><h4 id="查询指定目录的磁盘占用情况"><a href="#查询指定目录的磁盘占用情况" class="headerlink" title="查询指定目录的磁盘占用情况"></a>查询指定目录的磁盘占用情况</h4><p>基本语法 <code>du -h</code></p><p>查询指定目录的磁盘占用情况，默认为当前目录</p><ul><li>-s 指定目录占用大小汇总</li><li>-h 带计量单位</li><li>-a 含文件</li><li>–max-depth=1 子目录深度</li><li>-c 列出明细的同时，增加汇总值</li></ul><p>实例：查询 /opt目录的磁盘占用情况，深度为1</p><p><img src="image-20211015165445951.png" alt="image-20211015165445951"></p><h3 id="磁盘情况-工作实用指令"><a href="#磁盘情况-工作实用指令" class="headerlink" title="磁盘情况 - 工作实用指令"></a>磁盘情况 - 工作实用指令</h3><ol><li><p>统计/opt文件夹下文件的个数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /opt | grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>统计/opt文件夹下目录的个数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /opt | grep &quot;^d&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>统计/opt文件夹下文件的个数，包括子文件夹里的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -lR /opt | grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>统计/opt文件夹下目录的个数，包括子文件夹里的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -lR /opt | grep &quot;^d&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>以树状显示目录结构</p><p>如果显示找不到指令，就说明没有安装tree</p><p>使用yum install tree安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree /home</span><br></pre></td></tr></table></figure></li></ol><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="Linux-网络配置原理图"><a href="#Linux-网络配置原理图" class="headerlink" title="Linux 网络配置原理图"></a>Linux 网络配置原理图</h3><p><img src="image-20211015174643678.png" alt="image-20211015174643678"></p><h3 id="查看网络IP和网关"><a href="#查看网络IP和网关" class="headerlink" title="查看网络IP和网关"></a>查看网络IP和网关</h3><h4 id="查看虚拟网络编辑器和修改IP地址"><a href="#查看虚拟网络编辑器和修改IP地址" class="headerlink" title="查看虚拟网络编辑器和修改IP地址"></a>查看虚拟网络编辑器和修改IP地址</h4><p>VMware workstation</p><p>编辑 =&gt; 虚拟网络编辑器</p><p><img src="image-20211015174822325.png" alt="image-20211015174822325"></p><h4 id="查看网关"><a href="#查看网关" class="headerlink" title="查看网关"></a>查看网关</h4><p><img src="image-20211015175139172.png" alt="image-20211015175139172"></p><h3 id="查看windows环境中的VMnet8网络配置（ipconfig指令）"><a href="#查看windows环境中的VMnet8网络配置（ipconfig指令）" class="headerlink" title="查看windows环境中的VMnet8网络配置（ipconfig指令）"></a>查看windows环境中的VMnet8网络配置（ipconfig指令）</h3><p><img src="image-20211015175316078.png" alt="image-20211015175316078"></p><h3 id="查看linux的网络配置ifconfig"><a href="#查看linux的网络配置ifconfig" class="headerlink" title="查看linux的网络配置ifconfig"></a>查看linux的网络配置ifconfig</h3><p><img src="image-20211015175350477.png" alt="image-20211015175350477"></p><h3 id="ping测试主机之间网络连通性"><a href="#ping测试主机之间网络连通性" class="headerlink" title="ping测试主机之间网络连通性"></a>ping测试主机之间网络连通性</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p>ping 目的主机 (功能描述：测试当前服务器是否可以连接目的主机)、</p><h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4><p>测试当前服务器是否可以连接百度</p><p>ping <a href="http://www.baidu.com/">www.baidu.com</a></p><h3 id="linux-网络环境配置"><a href="#linux-网络环境配置" class="headerlink" title="linux 网络环境配置"></a>linux 网络环境配置</h3><h4 id="第一种方法-自动获取"><a href="#第一种方法-自动获取" class="headerlink" title="第一种方法 (自动获取)"></a>第一种方法 (自动获取)</h4><p>登陆后，通过界面的设置自动获取ip</p><p>特点：Linux启动后会自动获取IP，缺点是每次自动获取的ip地址可能不一样</p><p><img src="image-20211015180646004.png" alt="image-20211015180646004"></p><p><img src="image-20211015180652841.png" alt="image-20211015180652841"></p><h4 id="第二种方法-指定ip"><a href="#第二种方法-指定ip" class="headerlink" title="第二种方法 (指定ip)"></a>第二种方法 (指定ip)</h4><p>说明：直接修改配置文件来指定IP，并且可以连接到外网(程序员推荐)</p><p>编辑 /etc/sysconfig/network-scripts/ifcfg-ens33</p><p>要求：将IP地址配置为静态的，比如ip地址为192.168.200.130</p><p>ifcfg-ens33 文件说明</p><p><img src="image-20211015181021651.png" alt="image-20211015181021651"></p><p>红色部分是需要修改的</p><p><strong>重启网络服务或重启系统生效</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service network restart</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="设置主机名和hosts映射"><a href="#设置主机名和hosts映射" class="headerlink" title="设置主机名和hosts映射"></a>设置主机名和hosts映射</h3><h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><ol><li>为了方便记忆，可以给Linux系统设置主机名，也可以根据需要修改主机名</li><li>指令hostname: 查看主机名</li><li>修改文件在 /etc/hostname指定</li><li>修改后，重启生效</li></ol><h4 id="设置hosts映射"><a href="#设置hosts映射" class="headerlink" title="设置hosts映射"></a>设置hosts映射</h4><ul><li><p>windows</p><p>在C:\windows\System32\drivers\etc\hosts 文件指定即可</p></li></ul><ul><li><p>linux</p><p>在/etc/hosts 文件 指定</p></li></ul><h3 id="主机名解析过程分析-Hosts-DNS"><a href="#主机名解析过程分析-Hosts-DNS" class="headerlink" title="主机名解析过程分析 (Hosts, DNS)"></a>主机名解析过程分析 (Hosts, DNS)</h3><h4 id="Hosts是什么"><a href="#Hosts是什么" class="headerlink" title="Hosts是什么"></a>Hosts是什么</h4><p>一个文本文件，用来记录<strong>IP和Hostname的映射关系</strong></p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS就是Domain Name System的缩写，域名系统</p><p>是互联网上作为域名和IP地址相互映射的一个<strong>分布式数据库</strong></p><h4 id="应用实例：用户在浏览器输入了www-baidu-com"><a href="#应用实例：用户在浏览器输入了www-baidu-com" class="headerlink" title="应用实例：用户在浏览器输入了www.baidu.com"></a>应用实例：用户在浏览器输入了<a href="http://www.baidu.com/">www.baidu.com</a></h4><ol><li><p>浏览器先检查浏览器缓存中有没有该域名解析ip地址，有就先调用这个IP完成解析；如果没有，就检查DNS解析器缓存，如果有就直接返回ip完成解析。（这两个缓存可以理解为本地解析器缓存）</p></li><li><p>一般来说，当电脑第一次成功访问某一网站后，在一定的时间内，浏览器或者操作系统会缓存它的ip地址DNS解析记录，如在命令行输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipconfig /displaydns//DNS缓存解析</span><br><span class="line">ipconifg /flushdns//手动清理dns缓存</span><br></pre></td></tr></table></figure></li><li><p>如果本地解析器缓存没有找到对应的映射，则检查系统系统中的hosts文件中有没有配置对应的域名ip映射。如果有，则完成解析并返回</p></li><li><p>如果本地DNS解析器缓存和hosts文件中均没有找到对应的ip，则到域名服务DNS进行解析</p><p><img src="image-20211015181858114.png" alt="image-20211015181858114"></p></li></ol><h2 id="进程管理-重点"><a href="#进程管理-重点" class="headerlink" title="进程管理 (重点)"></a>进程管理 (重点)</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>在Linux中，每个执行的程序都称为一个进程。每个进程都分配一个ID号(pid，进程号)。</li><li>每个进程都可能以两种方式存在。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的进程。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li><li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。</li></ol><p><img src="image-20211016160842083.png" alt="image-20211016160842083"></p><h3 id="显示系统执行的过程"><a href="#显示系统执行的过程" class="headerlink" title="显示系统执行的过程"></a>显示系统执行的过程</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>命令：<code>ps</code></p><p>可以用来查看目前系统中，有哪些进程正在执行，以及他们的执行状况，可以不加任何参数。</p><p>常用参数：</p><ul><li>-a 显示当前终端的所有进程信息</li><li>-u 以用户的格式显示进程信息</li><li>-x 显示后台进程运行的参数</li><li>-e 显示所有的进程</li><li>-f 全格式</li></ul><p><img src="image-20211016161140363.png" alt="image-20211016161140363"></p><h4 id="ps-详解"><a href="#ps-详解" class="headerlink" title="ps 详解"></a>ps 详解</h4><ol><li><p>指令：<code>ps -aux | grep xxx</code> 比如我们想看看有没有sshd服务</p></li><li><p>指令说明</p><table><thead><tr><th align="left">field</th><th>explanation</th></tr></thead><tbody><tr><td align="left">USER</td><td>进程执行用户</td></tr><tr><td align="left">PID</td><td>进程号</td></tr><tr><td align="left">%CPU</td><td>当前进程占用cpu的百分比</td></tr><tr><td align="left">%MEM</td><td>占用物理内存的百分比</td></tr><tr><td align="left">VSZ</td><td>进程占用虚拟内存大小（KB）</td></tr><tr><td align="left">RSS</td><td>进程占用的物理内存的大小（KB）</td></tr><tr><td align="left">TTY</td><td>终端名称</td></tr><tr><td align="left">STAT</td><td>运行状态，S-表示sleep休眠、s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-表示正在运行，D-短期等待，z-僵尸进程，T-被跟踪或者被停止等等</td></tr><tr><td align="left">STARTED</td><td>执行的开始时间</td></tr><tr><td align="left">TIME</td><td>占用CPU时间</td></tr><tr><td align="left">COMMAND</td><td>启动进程所用的命令和参数，如果过长会被截断显示</td></tr></tbody></table></li></ol><h3 id="终止进程-kill-和-killall"><a href="#终止进程-kill-和-killall" class="headerlink" title="终止进程 kill 和 killall"></a>终止进程 kill 和 killall</h3><p>若是某个进程执行一半需要停止时，或是以消耗了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。</p><p>基本语法：</p><p><code>kill [选项] 进程号</code> 通过<strong>进程号</strong>杀死/终止进程</p><p><code>killall 进程名称</code> 通过<strong>进程名</strong>杀死进程，也支持通配符(这在系统因负载过大而变得很慢时很有用)</p><p>常用选项：</p><ul><li>-9 强迫进程立即停止</li></ul><p>最佳实践：</p><ol><li><p>踢掉某个非法登录用户 (比如某个用户登陆的进程号是11421)</p><p>kill 11421</p></li><li><p>终止远程登陆服务sshd，在适当时候再次重启sshd服务</p><p>kill sshd对应的进程号</p><p>systemctl start sshd.service</p></li><li><p>终止多个gedit</p><p>killall gedit</p></li><li><p>强制停止一个终端</p><p>kill -9 bash对应的进程号</p></li></ol><h3 id="查看进程树-pstree"><a href="#查看进程树-pstree" class="headerlink" title="查看进程树 pstree"></a>查看进程树 pstree</h3><p>基本语法 <code>pstree [选项]</code> 可以更加直观地来看进程信息</p><p>常用选项：</p><ul><li>-p 显示进程的PID</li><li>-u 显示进程的所属用户</li></ul><h3 id="服务-service-管理"><a href="#服务-service-管理" class="headerlink" title="服务(service)管理"></a>服务(service)管理</h3><h4 id="管理指令"><a href="#管理指令" class="headerlink" title="管理指令"></a>管理指令</h4><p>基本命令 <code>service 服务名 [start|stop|restart|reload|status]</code></p><p>服务(service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，比如（mysqld，sshd 防火墙等），因此我们又称为守护进程，是Linux中非常重要的知识点</p><p>在CentOS7.0后，很多服务不再使用service，而是systemctl(后面讲)</p><h4 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h4><ol><li><p>通过 <code>setup</code> 指令进入系统服务</p><p>带*号的表示开机自动启动，可以通过空格编辑</p><p>退出按tab切换到下面的命令按钮</p><p><img src="image-20211016164739193.png" alt="image-20211016164739193"></p></li><li><p>ls -l /etc/init.d/</p><p><img src="image-20211016164433521.png" alt="image-20211016164433521"></p></li></ol><h4 id="服务的运行级别"><a href="#服务的运行级别" class="headerlink" title="服务的运行级别"></a>服务的运行级别</h4><p>linux系统有七种运行级别（runlevel）：<strong>常用的是级别3和5</strong></p><ul><li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录</li><li>运行级别2：多用户状态（没有NFS），不支持网络</li><li>运行级别3：完全的多用户状态（有NFS），登录后进入控制台命令行模式</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登陆后进入图形GUI模式</li><li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li></ul><p>开机的流程说明</p><p><img src="image-20211016164952140.png" alt="image-20211016164952140"></p><h4 id="CentOS7-0后运行级别说明"><a href="#CentOS7-0后运行级别说明" class="headerlink" title="CentOS7.0后运行级别说明"></a>CentOS7.0后运行级别说明</h4><p>multi-user.target: analogous to runlevel 3 </p><p>graphical.target: analogous to runlevel 5</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看默认运行级别</span><br><span class="line">systemctl get-default</span><br><span class="line"></span><br><span class="line">设置默认运行级别</span><br><span class="line">systemctl set-default TARGET.target</span><br></pre></td></tr></table></figure><h4 id="chkconfig-指令"><a href="#chkconfig-指令" class="headerlink" title="chkconfig 指令"></a>chkconfig 指令</h4><ul><li>通过chkconfig命令可以给服务的各个运行级别设置自 启动/关闭</li><li>chkconfig指令管理的服务在 /etc/init.d查看</li><li>注意：CentOS7.0后，很多服务使用systemctl管理</li></ul><p>基本语法：</p><ul><li><code>chkconfig --list [|grep xxx]</code> 查看服务</li><li><code>chkconfig 服务名 --list</code> 查看服务</li><li><code>chkconfig --level x 服务名 on/off</code> 对服务在x等级下的状态进行控制</li></ul><p>案例：</p><ol><li><p>对network服务在运行级别3，关闭/开启自启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig --level 3 network off/on</span><br></pre></td></tr></table></figure></li></ol><p>使用细节：chkconfig重新设置服务后，需要重启机器才能生效</p><h4 id="systemctl-管理指令"><a href="#systemctl-管理指令" class="headerlink" title="systemctl 管理指令"></a>systemctl 管理指令</h4><p>基本语法 <code>systemctl [start|stop|restart|status] 服务名</code></p><p>systemctl指令管理的服务在/usr/lib/systemd/system查看</p><h5 id="systemctl-设置服务的自启动状态"><a href="#systemctl-设置服务的自启动状态" class="headerlink" title="systemctl 设置服务的自启动状态"></a>systemctl 设置服务的自启动状态</h5><p><code>systemctl list-unit-files [|grep 服务名]</code> 查看服务开机启动状态</p><p><code>systemctl enable 服务名</code> 设置服务开机启动</p><p><code>systemctl disable 服务名</code> 关闭服务开机启动</p><p><code>systemctl is-enabled 服务名</code> 查询某个服务是否是自启动的</p><h5 id="案例：对防火墙进行操作"><a href="#案例：对防火墙进行操作" class="headerlink" title="案例：对防火墙进行操作"></a>案例：对防火墙进行操作</h5><p>查看当前防火墙状态 =&gt; systemctl status firewalld</p><p>关闭/开启防火墙 =&gt; systemctrl stop/start firewalld</p><p>细节：</p><p>关闭或启用防火墙后，立即生效 [用telnet测试某个端口即可]</p><p>这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置</p><p>如果希望设置某个服务自启动或关闭永久生效，需要用<code>sysemctl enable/disable 服务名</code></p><p>打开或关闭指定端口：</p><p>在真正的生产环境，往往需要将防火墙打开。但是问题是，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要让防火墙打开指定的端口，比如80，22，8080…</p><p><img src="image-20211016171450080.png" alt="image-20211016171450080"></p><p>firewall 指令 (重新载入才能生效)</p><ol><li><code>firewall-cmd -permanent --add-port=端口号/协议</code> 打开端口</li><li><code>firewall-cmd -permanent --remove-port=端口号/协议</code> 关闭端口</li><li><code>firewall-cmd --reload</code> 重新载入</li><li><code>firewall-cmd --query-port=端口号/协议</code> 查询端口是否开放</li></ol><h3 id="top-动态监控进程"><a href="#top-动态监控进程" class="headerlink" title="top 动态监控进程"></a>top 动态监控进程</h3><p>基本语法 <code>top [选项]</code></p><p><img src="image-20211016171831705.png" alt="image-20211016171831705"></p><p>top与ps命令很相似，他们都用来显示正在执行的进程。top和ps最大的不同之处在于，top在执行后可以更新正在运行的进程。</p><p>常用选项：</p><ul><li>-d 秒数：指定top命令每隔几秒更新，默认是3秒</li><li>-i：使top不显示任何闲置或者僵尸进程</li><li>-p：通过指定监控进程ID来仅仅监控某个进程的状态</li><li>-u 用户名：监视特定的用户(也可以在进入页面后输入u交互)</li></ul><p>交互操作：</p><ul><li>P：以CPU使用率排序，默认就是此项</li><li>M：以内存的使用率排序</li><li>N：以PID排序</li><li>q：退出top</li><li>k：终止进程</li></ul><h3 id="netstat-监控网络状态"><a href="#netstat-监控网络状态" class="headerlink" title="netstat 监控网络状态"></a>netstat 监控网络状态</h3><p>基本语法 <code>netstat [选项]</code></p><p>常用选项：</p><ul><li>-an：按一定顺序排列输出</li><li>-p：显示哪个进程在调用</li></ul><p>案例：查看服务名为sshd的服务信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -anp | grap sshd</span><br></pre></td></tr></table></figure><p><img src="image-20211016172718259.png" alt="image-20211016172718259"></p><p>第三列是linuxIP和端口，第四列是通过xhell建立连接的主机的IP和端口</p><p><img src="image-20211016172731096.png" alt="image-20211016172731096"></p><h4 id="ping-检测主机连接"><a href="#ping-检测主机连接" class="headerlink" title="ping 检测主机连接"></a>ping 检测主机连接</h4><p>一种网络检测工具，主要是用于检测远程主机是否正常，或是两部主机间的网线或网卡故障。</p><p>命令 <code>ping ip地址</code></p><h2 id="软件包管理-RPM-amp-YUM"><a href="#软件包管理-RPM-amp-YUM" class="headerlink" title="软件包管理 RPM &amp; YUM"></a>软件包管理 RPM &amp; YUM</h2><h3 id="rmp包的管理"><a href="#rmp包的管理" class="headerlink" title="rmp包的管理"></a>rmp包的管理</h3><p>rpm用于互联网下载包的打包及安装工具，它包含在某些linux分发版中。它生成具有.RPM拓展名的文件。RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。</p><p>Linux的分发版都有采用（suse，redhat，centos等），可以说是公用的行业标准。</p><h4 id="包的简单查询指令"><a href="#包的简单查询指令" class="headerlink" title="包的简单查询指令"></a>包的简单查询指令</h4><p><code>rpm -qa | grep xxx</code> 查询已安装的rpm列表</p><p>案例：查看当前系统是否安装了firefox</p><ul><li>rpm -qa | grep firefox</li></ul><h4 id="rpm包名基本格式"><a href="#rpm包名基本格式" class="headerlink" title="rpm包名基本格式"></a>rpm包名基本格式</h4><p>一个rpm包名：firefox-60.2.2-1.el7.centos.x86_64<br>名称：firefox<br>版本号：60.2.2-1<br>适用操作系统：el7.centos.x86_64 表示centos7.x的64位系统</p><p>(如果是i686、i386表示32位系统，noarch表示通用)</p><h4 id="rpm包的其他查询指令"><a href="#rpm包的其他查询指令" class="headerlink" title="rpm包的其他查询指令"></a>rpm包的其他查询指令</h4><p><code>rpm -qa</code> 查询所安装的所有rpm软件包</p><p>rpm -qa | more </p><p>rpm -qa | grep xxx (如：rpm -qa | grep firefox)</p><p>rpm -q 软件包名： 查询软件包是否安装</p><p>案例：</p><ul><li>rpm -q firefox</li></ul><p>rpm -qi 软件包名：查询软件包信息</p><p>案例：</p><ul><li>rpm -qi firefox</li></ul><p>rpm -ql 软件包名：查询软件包中的文件</p><p>案例：</p><ul><li>rpm -ql firefox</li></ul><p>rpm -qf 文件全路径名：查询文件所属的软件包</p><p>案例：</p><ul><li><p>rpm -qf /etc/passwd</p></li><li><p>rpm -qf /root/install.log</p></li></ul><h4 id="安装rpm包"><a href="#安装rpm包" class="headerlink" title="安装rpm包"></a>安装rpm包</h4><p>基本语法 <code>rpm -ivh rpm包全路径名称</code></p><p>案例：</p><ul><li>安装firefox =&gt; rpm -ivh /opt/firefox (先按tab补全再回车)</li></ul><p>参数：</p><ul><li>-i install(安装)</li><li>-v verobse(提示)</li><li>-h hash(进度条)</li></ul><h4 id="卸载rpm包"><a href="#卸载rpm包" class="headerlink" title="卸载rpm包"></a>卸载rpm包</h4><p>基本语法 <code>rpm -e rpm包名</code></p><p>案例：</p><ul><li>删除firebox软件包 =&gt; rpm -e firefox</li></ul><p>细节：</p><p>如果其他软件包依赖于你要卸载的软件包，卸载时会产生错误信息。如果必须要删除这个软件包，可以增加参数<code>--nodeps</code>，就可以强制删除。但是一般不推荐这么做，因为依赖于该软件包的程序可能无法运行。</p><p><code>rmp -e --nodeps 软件包名</code></p><h3 id="yum包的管理"><a href="#yum包的管理" class="headerlink" title="yum包的管理"></a>yum包的管理</h3><p>Yum是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并安装，可以自动处理依赖关系，并且一次安装所有依赖的软件包</p><p>基本指令</p><ul><li><code>yum list | grep xxx</code> 查询yum服务器是否有需要安装的软件</li><li><code>yum install xxx</code> 下载安装</li></ul><p>案例：</p><ul><li>使用yum的方式来安装firefox <ol><li>rpm -e firefox 先卸载</li><li>yum list | grep firefox 查询yum服务器是否有firefox</li><li>yum install firefox 安装</li></ol></li></ul><h2 id="CentOS8-0-vs-CentOS7-0"><a href="#CentOS8-0-vs-CentOS7-0" class="headerlink" title="CentOS8.0 vs. CentOS7.0"></a>CentOS8.0 vs. CentOS7.0</h2><p><img src="image-20211020165912290.png" alt="image-20211020165912290"></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><a href="https://www.bilibili.com/video/BV1Sv411r7vd?spm_id_from=333.999.0.0">【小白入门 通俗易懂】2021韩顺平 一周学会Linux_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> linux系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/09/29/hello-world/"/>
      <url>/2021/09/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> categories_test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tags_test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
