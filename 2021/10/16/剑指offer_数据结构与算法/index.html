<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>剑指offer刷题-数据结构与算法篇 | Tobyy的博客</title><meta name="keywords" content="数据结构与算法"><meta name="author" content="Toby"><meta name="copyright" content="Toby"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="整数#1 整数除法输入两个int型整数，它们进行除法计算并返回商，**要求不得使用乘号*，除号&#x2F;以及求余符号%**，当发出溢出时，返回最大的整数值。假设除数不为0。例如，输入15和2，输出15&#x2F;2，即7。（注意：int型范围是-2^31 ~ -2^31-1） 分析： 只基于减法实现是可以的，但是此情况的最坏时间复杂度为O(n)，需要对效率进一步提升。 当被除数大于出除数时，继续比较判断被除数是否大">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer刷题-数据结构与算法篇">
<meta property="og:url" content="https://dudu12091.github.io/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Tobyy的博客">
<meta property="og:description" content="整数#1 整数除法输入两个int型整数，它们进行除法计算并返回商，**要求不得使用乘号*，除号&#x2F;以及求余符号%**，当发出溢出时，返回最大的整数值。假设除数不为0。例如，输入15和2，输出15&#x2F;2，即7。（注意：int型范围是-2^31 ~ -2^31-1） 分析： 只基于减法实现是可以的，但是此情况的最坏时间复杂度为O(n)，需要对效率进一步提升。 当被除数大于出除数时，继续比较判断被除数是否大">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dudu12091.github.io/img/%E5%89%91%E6%8C%87offer_1.jpg">
<meta property="article:published_time" content="2021-10-16T16:30:46.584Z">
<meta property="article:modified_time" content="2022-01-03T23:13:51.514Z">
<meta property="article:author" content="Toby">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dudu12091.github.io/img/%E5%89%91%E6%8C%87offer_1.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://dudu12091.github.io/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剑指offer刷题-数据结构与算法篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-03 23:13:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/tit.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> about</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i><span> myself</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E5%89%91%E6%8C%87offer_1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Tobyy的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> about</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i><span> myself</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指offer刷题-数据结构与算法篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-16T16:30:46.584Z" title="发表于 2021-10-16 17:30:46">2021-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-03T23:13:51.514Z" title="更新于 2022-01-03 23:13:51">2022-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指offer刷题-数据结构与算法篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><h3 id="1-整数除法"><a href="#1-整数除法" class="headerlink" title="#1 整数除法"></a>#1 整数除法</h3><p>输入两个int型整数，它们进行除法计算并返回商，**要求不得使用乘号*，除号/以及求余符号%**，当发出溢出时，返回最大的整数值。假设除数不为0。例如，输入15和2，输出15/2，即7。（注意：int型范围是-2^31 ~ -2^31-1）</p>
<p>分析：</p>
<p>只基于减法实现是可以的，但是此情况的最坏时间复杂度为O(n)，需要对效率进一步提升。</p>
<p>当被除数大于出除数时，继续比较判断被除数是否大于除数的2倍，如果是，则继续判断被除数是否大于除数的4倍、8倍等。如果被除数最多大于除数的2^k倍，那么将被除数减去除数的2^k倍，然后将剩余的被除数重复前面的步骤。由于每次将除数翻倍，因此优化后的时间复杂度是O(logn)。</p>
<p>细节：</p>
<ol>
<li>最小的整数是-2^31, 最大的整数是2^31-1。因此，如果将负整数直接转换为正整数可能导致溢出。可以先将正整数都转换成负整数，再根据需要调整商的符号。</li>
<li>直接溢出的情况，被除数为-2^31，除数为-1</li>
<li>防止被除数在扩大一倍时溢出，所以需要提前判断</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 辅助判断符号,奇数为负，偶数为正</span></span><br><span class="line">        <span class="keyword">int</span> negative = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            negative--;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            negative--;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = divideCore(dividend, divisor);</span><br><span class="line">        <span class="keyword">return</span> negative == <span class="number">1</span> ? -result : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divideCore</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dividend &lt;= divisor) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = divisor;</span><br><span class="line">        <span class="keyword">int</span> quotient = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个判断条件很重要，防止后面value扩大一倍时溢出</span></span><br><span class="line">        <span class="keyword">while</span> (value &gt;= Integer.MIN_VALUE / <span class="number">2</span> &amp;&amp; dividend &lt;= value + value) &#123;</span><br><span class="line">            quotient += quotient;</span><br><span class="line">            value += value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result += quotient;</span><br><span class="line">        dividend -= value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-二进制加法"><a href="#2-二进制加法" class="headerlink" title="#2 二进制加法"></a>#2 二进制加法</h3><p>给定两个表示二进制的字符串，请计算它们的和，并以二进制字符串的形式输出。例如，输入的二进制字符串分别是”11”和”10”，则输出”101”</p>
<p>注意：不能直接将二进制字符串转换成整数运算，因为并没有限定二进制字符串的长度，可能会造成溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a_length = a.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b_length = b.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (a_length &gt;= <span class="number">0</span> || b_length &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> digitA = a_length &gt;= <span class="number">0</span> ? a.charAt(a_length--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digitB = b_length &gt;= <span class="number">0</span> ? b.charAt(b_length--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = digitA + digitB + carry;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">            sum -= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑最后是否存在进位</span></span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">        result.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为存储顺序是从右至左，所以需要逆序输出</span></span><br><span class="line">    <span class="keyword">return</span> result.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-前n个数字二进制形式中1的个数"><a href="#3-前n个数字二进制形式中1的个数" class="headerlink" title="#3 前n个数字二进制形式中1的个数"></a>#3 前n个数字二进制形式中1的个数</h3><p>输入一个非负数n，请计算0到n之间每个数字的二进制形式中1的个数，并输出一个数组。例如，输入的n为4，由于0、1、2、3、4的二进制形式中1的个数分别为0、1、1、2、1，因此输出数组[0,1,1,2,1]。</p>
<p>简单分析：最直观的解法，就是用for循环来计算从0到n的每个整数i的二进制形式中1的个数。于是问题转换成如何求一个整数i的二进制形式中1的个数。</p>
<p>思路</p>
<ol>
<li><p>根据<code>i&amp;(i-1)</code>计算</p>
<p>此公式的核心思想是把i最右面的1变成0。可以通过for循环，不断地把最右边的1变成0，变化了几次就说明有几个1。其中页暗藏动态规划的思想，数字i中1的个数比i&amp;(i-1)中1的个数多1。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于思路<span class="number">1</span>实现:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countBits_1(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result[i] = result[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>根据<code>i/2</code>计算</p>
<p>通过观察发现，如果正整数i是偶数，那么i相当于’i/2’左移一位的结果，因此它们的二进制形式中1的个数是相同的。如果i是奇数，那么i相当于’i/2’左移一位之后，再将最右边一位设成1的结果，因此奇数i的二进制形式中1的个数比’i/2’中的1的个数多1。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于思路<span class="number">2</span>实现:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countBits_2(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// i &amp; 1, i为奇数则结果为1, 偶数为0</span></span><br><span class="line">        result[i] = result[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上述代码用’i &gt;&gt; 1’计算’i/2’，用’i &amp; 1’计算’i%2’，因为位运算比除法运算和求余运算更高效。</p>
<h3 id="4-只出现一次的数字"><a href="#4-只出现一次的数字" class="headerlink" title="#4 只出现一次的数字"></a>#4 只出现一次的数字</h3><p>输入一个整数数组，书注重只有一个数字出现了一次，而其他数字都出现了3次。请找出那个只出现一次的数字。例如，如果输入的数组为[0,1,0,1,0,1,100]，则只出现一次的数字是100。</p>
<p>思路：一个整数是由32个0或1组成的。我们可以将数组中所有数字的同一位置的数位相加。因此，<strong>如果数组中所有数字的第i个数位相加之和能被3整除，那么只出现一次的数字的第i个位数一定是0；如果数组中所有数字的第i个数位相加之和被3除余1，那么只出现一次的数字的第i个数位一定是1。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代表整数的长度为32bit</span></span><br><span class="line">    <span class="keyword">int</span>[] bitSums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把数组中所有数字按对应的bit位累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            bitSums[i] += (num &gt;&gt; (<span class="number">31</span> - i)) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断累加后对应的bit位能否被三整除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        result = (result &lt;&lt; <span class="number">1</span>) + bitSums[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>举一反三：</strong>如果数组中只有一个数字出现m次，其他数字都出现n次，m不能被n整除，找出唯一出现m次的数字。</p>
<p>用同样的思路解决此问题，最后验证累加后的整数对应bit位能否被m整除。</p>
<h3 id="5-单词长度的最大乘积"><a href="#5-单词长度的最大乘积" class="headerlink" title="#5 单词长度的最大乘积"></a>#5 单词长度的最大乘积</h3><p>给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p>
<p>例如：输入的字符串数组words为[“abcw”,”foo”,”bar”,”fxyz”,”abcdef”], 最后返回的应该是16。</p>
<p>思路1：</p>
<p>假设两字符串长度分别为p,q。</p>
<ol>
<li>最直观的解法就是蛮力法。如果蛮力法比较两个字符串是否有相等字符，比较的时间复杂度为O(pq)。</li>
<li>通过哈希表来优化时间效率。对于每个字符串，用一个哈希表记录该字符串中的所有字符。因为题目假设的所有字符都是英文小写字母，只有26个可能的字符，因此最多只需要在每个字符串对应的哈希表中查询26次就能判断两个字符串是否包含相同的字符，因此比较的时间复杂度为O(1)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct_1</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[words.length][<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 生成哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">            flags[i][c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 判断word i 和 word j是否有相同的字符</span></span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flags[i][k] == <span class="keyword">true</span> &amp;&amp; flags[j][k] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// k = 26说明没有相同字符</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> prod = words[i].length() * words[j].length();</span><br><span class="line">                result = Math.max(result, prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>进一步分析此方法的时间和空间复杂度。</p>
<p>第一步，初始化每个字符串对应的哈希表。如果words的长度为n，凭均每个字符串的长度为k，那么初始化哈希表的时间复杂度为O(nk)。</p>
<p>第二步，根据哈希表判断每对字符串是否包含相同的字符。总共有O(n^2)对字符串，每次判断需要的时间为O(1)，因此这一步的时间复杂度为O(n^2)。</p>
<p><strong>于是这种解法的整体时间复杂度为O(nk + n^2)。</strong></p>
<p>为每一个字符串创建一个数组，所以<strong>空间复杂度为O(n)</strong></p>
</li>
</ol>
<p>思路2：用整数的二进制数位记录字符串中出现的字符</p>
<p>前面的解法是用一个长度为26的布尔型数组记录字符串中出现的字符。布尔值只有两种可能，true or false。这与二进制有些类似。因此，可以将长度为26的布尔型数组用26个二进制的数位代替，二进制的0对应布尔值的false，1对应true。</p>
<p>26bit就足以表示一个字符串中可能出现的字符，所以我们可以用int(32bit)来表示。<strong>用二进制数位表示的好处是可以更快地判断两个字符串是否包含相同的字符。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct_2</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] flags = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : words[i].toCharArray()) &#123;</span><br><span class="line">            flags[i] |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 说明两个字符串没有相同的字符</span></span><br><span class="line">            <span class="keyword">if</span> ((flags[i] &amp; flags[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> prod = words[i].length() * words[j].length();</span><br><span class="line">                result = Math.max(result, prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<p>与思路1时间空间复杂度均相同。</p>
<p>但是在比较是否存在相等字符时，只需要一次运算即可。而思路1中可能需要26次布尔运算，所以<strong>新的解法时间效率更高</strong>。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="#双指针"></a>#双指针</h3><p>方向相反的双指针经常用来求排序数组中的两个数字之和。</p>
<p>方向相同的双指针通常用来求正数数组中子数组的和或乘积。</p>
<h3 id="6-排序数组中的两个数字之和"><a href="#6-排序数组中的两个数字之和" class="headerlink" title="#6 排序数组中的两个数字之和"></a>#6 排序数组中的两个数字之和</h3><p>考点 <code>双指针</code></p>
<p>输入一个递增序列的数组和一个值k，请问如何在数组中找出两个和为k的数字并返回它们的下标？假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。</p>
<p>例如：输入数组[1,2,4,6,10], k的值为8，应该返回[1,3]</p>
<p>分析：</p>
<ol>
<li><p>最直观的暴力解法，固定数组中的一个数字，然后判断数组中其余数字与他的和是不是等于k。可以看成是用两个for循环遍历数组，<strong>时间复杂度为O(n^2)</strong></p>
</li>
<li><p>上述解法可以用二分查找优化。还是先固定一个数字i，然后用二分查找寻找k-i。时间复杂度为O(nlogn)。</p>
</li>
<li><p>上述解法还可以用空间换时间进行优化。可以先将数组中所有的数字都放入一个哈希表，然后逐一扫描数组中的每个数字。扫描i, 就在哈希表里找k-i。判断哈希表中是否存在一个数字的时间复杂度为O(1)，因此新解法的**时间复杂度为O(n)<strong>。同时它需要一个大小为O(n)的哈希表，因此</strong>空间复杂度也是O(n)**。</p>
</li>
<li><p>存在时间复杂度是O(n)，空间复杂度是O(1)的解法，就是我们最后要引出的<code>双指针</code>。</p>
<p>两个指针一个从前向后移动，一个从后向前移动。如果小于target前指针后移，如果大于target后指针前移。如果相等则返回指针对应的索引。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// 双指针，一个从前向后移动，一个从后向前移动</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = numbers.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] != target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] + numbers[j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-数组中和为0的3个数字"><a href="#7-数组中和为0的3个数字" class="headerlink" title="#7 数组中和为0的3个数字"></a>#7 数组中和为0的3个数字</h3><p>输入一个数组，如何找出数组中所有和为0的3个数字的三元组？需要注意的是，返回值中不得包含重复的三元组。</p>
<p>例如：在数组[-1,0,1,2,-1,-4]中有两个三元组的和为0，它们分别是[-1,0,1]和[-1,-1,2]。</p>
<p>分析：</p>
<p>这是上一题的加强版。如果输入的数组是排序的，我们就可以先固定一个数字i，然后再排序数组中查找和为-i的两个数字。我们已经有了用O(n)时间在排序数组中找出和为给定值的两个数字的方法，由于需要固定数组中的每个数字，因此查找此三元组的时间复杂度是O(n^2)。</p>
<p>但是这个题目并没有说给出的数组是排序的，因此需要先对数组排序。排序算法的时间复杂度通常是O(nlogn)，因此这种解法的总时间复杂度是O(logn + n^2), <strong>最后还是O(n^2)</strong></p>
<p>最后要注意去除重复的三元组。在指针移动时跳过所有相同的值即可。需要跳过相同值的地方共有两处，第一处是固定i的时候，第二处是双指针移动的时候。移动前指针和后指针都可以，移动的那个指针要考虑跳过重复值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length - <span class="number">2</span>) &#123;</span><br><span class="line">            twoSum(nums, i, result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过重复的数字</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">while</span> (nums[i] == temp &amp;&amp; i &lt; nums.length - <span class="number">2</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class="line">    <span class="comment">// 双指针，一个从前向后移动，一个从后向前移动</span></span><br><span class="line">    <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过重复的数字</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">            <span class="keyword">while</span> (nums[j] == temp &amp;&amp; j &lt; k) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-和大于或等于k的最短子数组"><a href="#8-和大于或等于k的最短子数组" class="headerlink" title="#8 和大于或等于k的最短子数组"></a>#8 和大于或等于k的最短子数组</h3><p>输入一个正整数组成的数组和一个正整数k，请问数组中和大于或等于k的连续子数组的最短长度是多少？如果不存在所有数字之和大于或等于k的子数组，则返回0。</p>
<p>例如：输入数组[5,1,4,3]，k的值为7，最后输出2。</p>
<p>考点 <code>双指针</code></p>
<p>分析：</p>
<p>用两个指针P1，P2来锁定子数组，子数组由两个指针之间所有数字组成。</p>
<p>初始化时两指针都指向数组的第一个元素。</p>
<p>如果子数组和大于等于k，则P1右移，相当于从子数组的最左边删除一个数字，子数组长度减1。如果子数组和小于k，则P1右移，相当于在子数组的最右边添加一个新的数字，子数组长度加1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; right &lt; nums.length; right++) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>尽管代码中有两个嵌套的循环，但是**时间复杂度仍然是O(n)**。因为left和right都只加不减，变化范围都是[0~n-1]。</p>
<h3 id="9-乘积小于k的子数组"><a href="#9-乘积小于k的子数组" class="headerlink" title="#9 乘积小于k的子数组"></a>#9 乘积小于k的子数组</h3><p>输入一个由正整数组成的数组和一个正整数k，请问数组中有多少个数字乘积小于k的连续子数组？</p>
<p>例如：输入数组[10,5,2,6]，k的值为100，有8个子数组的所有数字的乘积小于100。</p>
<p>考点 <code>双指针</code></p>
<p>分析：</p>
<p>与上一题思路类似，用双指针P1，P2锁定子数组，如果子数组中所有数字的乘积小于k，那么右移P2；反之则右移P1。当指针P1到某个位置时子数组的乘积小于k，就不需要再向右移动指针P1。因为只要保持指针P2不动，向右移动指针P1形成的所有子数组的数字乘积就一定小于k。<strong>此时两个指针之间有多少个数字，就找到了多少个数字乘积小于k的子数组。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; right &lt; nums.length; right++) &#123;</span><br><span class="line">        product *= nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; product &gt;= k) &#123;</span><br><span class="line">            product /= nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        result += right &gt;= left ? right - left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>和上一题同理，<strong>时间复杂度为O(n)</strong></p>
<h3 id="累加数组数字求子数组之和"><a href="#累加数组数字求子数组之和" class="headerlink" title="#累加数组数字求子数组之和"></a>#累加数组数字求子数组之和</h3><p>使用双指针解决子数组之和问题有一个前提条件：数组中的所有数字都是正数。如果数组中有正数、负数和零，那么双指针的思路并不适用。因为当数组中有负数时在子数组中添加数字不一定能增加子数组之和，从子数组中删除数字也不一定能减少子数组之和。</p>
<p>所以引出求子数组和的另一种思路：<code>累加数组数字</code></p>
<p>首先需要预处理。假设数组长度为n，从头到尾扫描一次，就能求出从下标0开始到下标0结束的所有子数组之和S_0，从下标0开始到下标1结束的子数组之和S_1，以此类推，直到求出从下标0开始到最后一个数字的子数组之和S_n-1。因此，<strong>从下标为i开始到下标为j结束的子数组的和就是S_j - S_i-1</strong>。</p>
<h3 id="10-和为k的子数组"><a href="#10-和为k的子数组" class="headerlink" title="#10 和为k的子数组"></a>#10 和为k的子数组</h3><p>输入一个整数数组和一个整数k，请问数组中有多少个数字之和等于k的连续子数组？</p>
<p>例如：输入数组[1,1,1]，k的值为2，有2个连续子数组之和等于2。</p>
<p>分析：</p>
<p>最先想到暴力解法。在一个长度为n的数组中有O(n^2)个子数组，如果求出每个子数组的和需要O(n)的时间，那么总共需要O(n^3)的时间就能求出所有子数组的和。</p>
<p>对暴力解法进一步优化。在计算长度为i的子数组数字之和时，应该把子数组堪称长度为i-1的子数组的基础上添加一个新的数字。因此，如果已经求出了长度为i-1的子数组的数字之和，那么只要再加上新添加的数字就能得出长度为i的子数组的数字之和。因为只需要1次加法，需要O(1)时间，优化后的时间复杂度为O(n^2)。</p>
<p>再换一种思路，我们从头到尾扫描数组中的数字时求出前i个数字之和，并将结果保存下来。当扫描到数组的第i个数字时并求得前i个数字之和是x时，需要知道在i之前存在多少个j，满足前j个数字之和等于x-k。<strong>所以，对于每个i，不但要保存前i个数字之和，还要保存每个和出现的次数。</strong> 分析到这儿就知道我们需要一个哈希表，键是前i个数字之和，值是每个和出现的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; sumToCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刚开始累加和为0</span></span><br><span class="line">    sumToCount.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        result += sumToCount.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">        sumToCount.put(sum, sumToCount.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>只需要从头至尾扫描数组一次，所以**时间复杂度为O(n)<strong>。需要一个哈希表保存前i个数字的和及出现的次数，所以</strong>空间复杂度为O(n)**。</p>
<h3 id="11-0和1个数相同的子数组"><a href="#11-0和1个数相同的子数组" class="headerlink" title="#11 0和1个数相同的子数组"></a>#11 0和1个数相同的子数组</h3><p>输入一个只包含0和1的数组，请问如何求0和1个数相同的最长连续子数组的长度？</p>
<p>例如：在数组[0,1,0]中有两个子数组包含相同个数的0和1，分别是[0,1]和[1,0]，他们的长度都是2，因此输出2。</p>
<p>分析：</p>
<p><strong>如果题目中所有的0都变成-1，那么01个数相同的子数组和必为1。这样此题就转换成了一个求和为k的子数组的问题。</strong>想要完成这样的转换也很简单，只需要在每次累加时，判断当前数字时否为0，如果为0则累加-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; sumToIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果累加和为0，说明01数量已经相等，长度=索引+1</span></span><br><span class="line">    sumToIndex.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i] == <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sumToIndex.containsKey(sum)) &#123;</span><br><span class="line">            result = Math.max(result, i - sumToIndex.get(sum));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sumToIndex.put(sum, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>与求和为k的子数组同理，<strong>时间复杂度空间复杂度都为O(n)</strong></p>
<h3 id="12-左右两边子数组的和相等"><a href="#12-左右两边子数组的和相等" class="headerlink" title="#12 左右两边子数组的和相等"></a>#12 左右两边子数组的和相等</h3><p>输入一个整数数组，如果一个数字左边的子数组的数字之和等于右边的子数组的数字之和，那么返回该数字的下标。如果存在多个这样的数字，则返回最左边一个数字的下标。如果不存在这样的数字，则返回-1。</p>
<p>例如：在数组[1,7,3,6,2,9]中，下标为3的数字左右两边子数组之和相等，因此应该输出3。</p>
<p>分析：</p>
<p>当扫描到第i个数字时，可以算出前i个数字的累加和。此时，i左边子数组的和等于前i个数字的和减i，i右边子数组的和等于整个数组的和total减前i个数字的累加和。所以此题还得求整个数组的累加和total。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pivotIntex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; nums.length; i++) &#123;</span><br><span class="line">        total += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum - nums[i] == total - sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>共有两个时间复杂度为O(n)的循环，因此**时间复杂度为O(n)<strong>。并没有使用数组、哈希表等辅助数据容器，因此</strong>空间复杂度为O(1)**。</p>
<h3 id="13-二维子矩阵的数字之和"><a href="#13-二维子矩阵的数字之和" class="headerlink" title="#13 二维子矩阵的数字之和"></a>#13 二维子矩阵的数字之和</h3><p>输入一个二维矩阵，如何计算给定左上角坐标和右下角坐标的子矩阵的数字之和？对于同一个二维矩阵，计算子矩阵的数字之和的函数可能由于输入不同的坐标而被反复调用多次。</p>
<p>例如：输入如下矩阵和坐标(2,1),(4,3)，应该返回8</p>
<p>[[3,0,1,4,2],</p>
<p>[5,6,3,2,1],</p>
<p>[1,2,0,1,5],</p>
<p>[4,1,0,1,7],</p>
<p>[1,0,3,0,5]]    </p>
<p>分析：</p>
<p>如果不考虑时间复杂度，采用蛮力法用两个嵌套的循环总是可以求出一个二维矩阵的数字之和。如果矩阵的行数和列数分别是m和n，那么这种蛮力法的时间复杂度是O(mn)。但是由于题目提到，计算函数可能被反复调用多次，因此应该优化求和的过程，尽快地实现子矩阵求和函数。</p>
<p>我们用[(r1,c1)(r2,c2)]来表示左上角坐标为(r1,c1)，右下角坐标为(r2,c2)的子矩阵的数字之和。通过观察发现，此矩阵的数字之和可以用4个左上角坐标为(0,0)的子矩阵的数字之和求得。[(r1,c1)(r2,c2)] = [(0,0)(r2,c2)] - [(0,0)(r2,c1-1)] - [(0,0)(r1-1,c2)] + [(0,0)(r1-1,c1-1)]。</p>
<p>再进一步思考，只要在预处理阶段求出(0,0)到每个右下角坐标的子矩阵的数字之和，然后存到一个辅助矩阵中，目标子矩阵的数字之和就可以在常数时间内计算完毕。 </p>
<p>那要怎么计算子矩阵呢？可以把[(0,0),(i,j)]看成两部分。第一部分是[(0,0),(i-1,j)],第二部分是矩阵中第i行中列号从0到j的所有数字。<strong>为了计算方便，可以在初始化时创建一个比原数组行列多1的辅助矩阵。这样在计算辅助矩阵的第一行时也可以在循环中进行。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] NumMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] sums = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length+<span class="number">1</span>][matrix[<span class="number">0</span>].length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> rowSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            rowSum += matrix[i][j];</span><br><span class="line">            sums[i+<span class="number">1</span>][j+<span class="number">1</span>] = sums[i][j+<span class="number">1</span>] + rowSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> sums[][], <span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> 	sums[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] </span><br><span class="line">        	- sums[row1][col2 + <span class="number">1</span>] </span><br><span class="line">        	- sums[row2 + <span class="number">1</span>][col1] </span><br><span class="line">        	+ sums[row1][col1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>用两个嵌套的for循环计算辅助矩阵，时间复杂度为O(mn)。同时，辅助矩阵需要的空间也为O(mn)。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>java中String类型所表达的字符串时无法改变的。如果对字符串进行写操作，那么修改的内容在返回值的字符串中，原来的字符串保持不变。</p>
<p>由于每次对String实例进行修改将创建一个新的String实例，因此如果连续多次对String实例进行修改将连续创建多个新的String实例，不必要的内存开销较大。所以可以借助StringBuilder或StringBuffer(线程安全效率低)来容纳修改后的结果。</p>
<h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="#双指针"></a>#双指针</h3><p>如果将字符串看成一个由字符串组成的数组，那么也可以用两个指针来定位一个子字符串。</p>
<p>可以在移动这两个指针的同时，统计两个指针之间的字符串中字符出现的次数，这样可以解决很多常见的面试题，如定位变位词等。</p>
<p>由于这种类型的面试题都与统计字母出现的次数有关，我们经常使用哈希表来存储每个元素出现的次数，因此解决这种类型的面试题通常需要同时使用<strong>双指针和哈希表</strong>。</p>
<h3 id="14-字符串中的变位词"><a href="#14-字符串中的变位词" class="headerlink" title="#14 字符串中的变位词"></a>#14 字符串中的变位词</h3><p>输入字符串s1和s2，如何判断字符串s2中是否包含字符串s1的某个变位词？如果字符串s2中包含字符串s1的某个变位词，则字符串s1至少有一个变位词是字符串s2的子字符串。假设两个字符串中只包含英文小写字母。</p>
<p>例如：</p>
<ol>
<li>字符串s1为”ac”, s2为”dgcaf”, 输出true</li>
<li>字符串s1为”ab”, s2为”dgcaf”, 输出false</li>
</ol>
<p>分析：</p>
<p>还是最先想到暴力法。可以先求出字符串s1的所有排列，然后判断每个排列是不是字符串s2的子字符串。如果一个字符串有n个字符，那么它一共有n!个排列，因此这种解法的时间复杂度不会低于O(n!)。</p>
<p>下面尝试更高效的解法。我们可以以用一个哈希表来存储每个字符出现的次数。首先扫描s1，每扫描到一个字符，就找到它在哈希表中的位置并把对应的值加1。然后考虑s2中是否有s1的变位词。假设字符串s2中有一个子字符串是s1的变位词，逐个扫描这个变位词中的字母，并把字母在哈希表中对应的值减1。<strong>如果同位词存在，最后操作完，哈希表中所有的值应该都是0。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s2.length() &lt; s1.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 先判断第一组和s1等长的子字符串是否是其变位词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i 为第一个指针的索引， i - s1.length() + 1为第二个指针的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s1.length(); i &lt; s2.length(); i++) &#123;</span><br><span class="line">            counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            counts[s2.charAt(i - s1.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areAllZero</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：需要扫描字符串s1和s2各一次，如果他们的长度分别是m和n，那么**时间复杂度是O(m+n)<strong>。这种解法用到了一个长度为26的数组，是一个常数，所以</strong>空间复杂度是O(1)**。</p>
<h3 id="15-字符串中所有的变位词"><a href="#15-字符串中所有的变位词" class="headerlink" title="#15 字符串中所有的变位词"></a>#15 字符串中所有的变位词</h3><p>输入字符串s1和s2，如何找出字符串s2的所有变位词在字符串s1中的起始下标？假设两个字符串中只包含英文小写字母。</p>
<p>例如：字符串s1为”cbadabacg”, 字符串s2为”abc”，应该输出0和5。</p>
<p>分析：就是上一题的变种。在成功找到变位词时返回对应子字符串第一个字符的索引即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; indices = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s1.length() &lt; s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 方便添加进列表</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先判断第一组子字符串</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s2.length(); i++) &#123;</span><br><span class="line">        counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">        indices.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = s2.length(); i &lt; s1.length(); i++) &#123;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        counts[s1.charAt(i - s2.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">            <span class="comment">// 注意: 前一个指针的索引是 i - s2.length() + 1</span></span><br><span class="line">            indices.add(i - s2.length() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areAllZero</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：与上一题同理，<strong>时间复杂度为O(n)</strong>, **空间复杂度为O(1)**。</p>
<h3 id="16-不含重复字符的最长子字符串"><a href="#16-不含重复字符的最长子字符串" class="headerlink" title="#16 不含重复字符的最长子字符串"></a>#16 不含重复字符的最长子字符串</h3><p>输入一个字符串，求该字符串中不含重复字符的最长子字符串的长度。</p>
<p>例如：输入字符串”babcca”，其最长的不含重复字符的子字符串是”abc”，长度为3。</p>
<p>分析：</p>
<p>用左右两个指针锁定子字符串，用哈希表存放字符出现的次数。如果两指针之间的子字符串不包含重复字符，则向前移动右指针，否则向前移动左指针。两指针初始化时都在起始位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ASCII码一共256个字符</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 用字符标识索引时，字符会自动转换成对应的ASCII码</span></span><br><span class="line">        counts[s.charAt(i)]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hasGreaterThan1(counts)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            counts[s.charAt(j)]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的j并不是左指针的位置，而是左指针前面的位置，所以不需要i-j+1</span></span><br><span class="line">        longest = Math.max(longest, i - j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasGreaterThan1</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>进一步分析：</p>
<p>每次移动指针的时候都要扫描一次哈希表，虽然哈希表的长度固定，但是这个常数还是有点大。所以最好能有一个不需要多次遍历整个哈希表的解法。</p>
<p>其实我们真正关心的是哈希表中有没有比1大的数字，因为如果有大于的数字就说明子数组中包含重复的数字。可以定义一个变量countDup来存储哈希表中大于1的数字的个数**(其实这个值最大就是1，用boolean变量存也可以)**。当移动右指针导致哈希表中某个数字从1变成2时，变量countDup加1。当移动左指针导致哈希表中某个数字从2变成1时，变量countDup减1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ASCII码一共256个字符</span></span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> countDup = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 用字符标识索引时，字符会自动转换成对应的ASCII码</span></span><br><span class="line">            counts[s.charAt(i)]++;</span><br><span class="line">            <span class="keyword">if</span> (counts[s.charAt(i)] == <span class="number">2</span>) &#123;</span><br><span class="line">                countDup++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (countDup &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                counts[s.charAt(j)]--;</span><br><span class="line">                <span class="comment">// 检查是否有数字从2变成1</span></span><br><span class="line">                <span class="keyword">if</span> (counts[s.charAt(j)] == <span class="number">1</span>) &#123;</span><br><span class="line">                    countDup--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里的j并不是左指针的位置，而是左指针前面的位置，所以不需要i-j+1</span></span><br><span class="line">            longest = Math.max(longest, i - j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="17-包含所有字符串的最短字符串"><a href="#17-包含所有字符串的最短字符串" class="headerlink" title="#17 包含所有字符串的最短字符串"></a>#17 包含所有字符串的最短字符串</h3><p>输入两个字符串s和t，请找出字符串s中包含字符串t的所有字符的最短子字符串。</p>
<p>例如：输入的字符串s为”ADDBANCAD”，字符串t为”ABC”，则字符串s中包含字符’A’, ‘B’, ‘C’的最短子字符串是”BANC”。如果不存在符合条件的子字符串，则返回空字符串””。如果存在多个符合条件的子字符串，则返回任意一个。</p>
<p>分析：</p>
<p>用两个指针定位子字符串。如果某一时刻两个指针之间之间的子字符串还没有包含字符串t的所有字符，则在子字符串中添加新的字，于是向右移动第二个指针。如果已经包含字符串t的所有字符，则向右移动第一个指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; charToCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : t.toCharArray()) &#123;</span><br><span class="line">        charToCount.put(ch, charToCount.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当count等于0时，两指针之间的子字符串就包含t中的所有字符</span></span><br><span class="line">    <span class="keyword">int</span> count = charToCount.size();</span><br><span class="line">    <span class="comment">// start, end分别为两个指针</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, minStart = <span class="number">0</span>, minEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; s.length() || (count == <span class="number">0</span> &amp;&amp; end == s.length())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">// end &lt; s.length()</span></span><br><span class="line">            <span class="keyword">char</span> endCh = s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span> (charToCount.containsKey(endCh)) &#123;</span><br><span class="line">                charToCount.put(endCh, charToCount.get(endCh) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (charToCount.get(endCh) == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向右移动第二个指针</span></span><br><span class="line">            end++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// count == 0 &amp;&amp; end == s.length()</span></span><br><span class="line">            <span class="keyword">if</span> (end - start &lt; minLength) &#123;</span><br><span class="line">                minLength = end - start;</span><br><span class="line">                minStart = start;</span><br><span class="line">                minEnd = end;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> startCh = s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (charToCount.containsKey(startCh)) &#123;</span><br><span class="line">                charToCount.put(startCh, charToCount.get(startCh) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (charToCount.get(startCh) == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向右移动第一个指针</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minLength &lt; Integer.MAX_VALUE ? s.substring(minStart, minEnd) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>只有一个while循环，把两个变量从0增加到字符串s的长度。所以**时间复杂度为O(n)<strong>。哈希表的键为字符，假设字符串中只有英文字母，所以哈希表的大小不会超过256。因此</strong>空间复杂度为O(1)**。</p>
<h3 id="18-有效的回文"><a href="#18-有效的回文" class="headerlink" title="#18 有效的回文"></a>#18 有效的回文</h3><p>给定一个字符串，请判断它是不是回文。假设只需考虑字母和数字字符，并忽略大小写。</p>
<p>例如：”Was it a cat I saw”是一个回文字符串，而”race a car”不是回文字符串。</p>
<p>分析：</p>
<p>可以用双指针，一个从前向后移动，另一个从后向前移动。如果两指针指向的字符相同，则继续移动，直到两个指针相遇。<strong>注意：题目只考虑字母和数字字符，所以如果指针指向的字符既不是字母也不是数字，则跳过该字符。同时，由于忽略大小写，所以要把所有字母转换成相同的形式再做比较。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = s.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> ch2 = s.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (!Character.isLetterOrDigit(ch1)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isLetterOrDigit(ch2)) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ch1 = Character.toLowerCase(ch1);</span><br><span class="line">            ch2 = Character.toLowerCase(ch2);</span><br><span class="line">            <span class="keyword">if</span> (ch1 != ch2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在改变字母大小写时，建议操作字符而不是字符串。因为java中字符串不可变，修改字符串会创建新的字符串，造成内存浪费。</strong></p>
<p>复杂度分析：</p>
<p>两个指针遍历字符串，**时间复杂度为O(n)**。</p>
<h3 id="19-最多删除一个字符得到回文"><a href="#19-最多删除一个字符得到回文" class="headerlink" title="#19 最多删除一个字符得到回文"></a>#19 最多删除一个字符得到回文</h3><p>给定一个字符串，请判断如果最多从字符串中删除一个字符能不能得到一个回文字符串。</p>
<p>例如：如果输入字符串”abca”，由于删除字符串’b’或’c’就能得到一个回文字符串，因此输出为true。</p>
<p>分析：</p>
<p>与上一题类似，还是用双指针从两侧开始向里逐步比较。如果字符相同，则继续比较。如果字符不同，则按题目要求，删除一个字符后比较剩下的字符。因为不知道删除两个不同字符中的哪一个，因此都可以进行尝试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当start == s.length() / 2说明是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(; start &lt; s.length() / <span class="number">2</span>; start++, end--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start) != s.charAt(end)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> start == s.length() / <span class="number">2</span></span><br><span class="line">                || isPalindrome(s, start, end - <span class="number">1</span>)</span><br><span class="line">                || isPalindrome(s, start + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) != s.charAt(end)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start &gt;= end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：最坏情况，从左右两端第一个字符开始就出现分歧，需要判断删除的情况。此时需要遍历字符串两遍，**时间复杂度O(n)**。</p>
<h3 id="20-回文子字符串的个数"><a href="#20-回文子字符串的个数" class="headerlink" title="#20 回文子字符串的个数"></a>#20 回文子字符串的个数</h3><p>给定一个字符串，请问该字符串中有多少个回文连续子字符串？</p>
<p>例如：字符串”aaa”有6个回文子字符串，分别为”a”, “a”, “a”, “aa”, “aa” 和 “aaa”。</p>
<p>分析：</p>
<p>同样用双指针来求解，但是思路略有不同。我们考虑从字符串的中心开始向两端延申。<strong>注意：回文的长度可以是奇数也可以是偶数。长度为奇数的回文对称中心只有一个字符，而长度为偶数的回文对称中心有两个字符。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        count+= countPalindrome(s, i, i);</span><br><span class="line">        count+= countPalindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.length()</span><br><span class="line">           &amp;&amp; s.charAt(start) == s.charAt(end)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        start--;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>for循环嵌套while循环，**时间复杂度为O(n^2)**。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单向链表的简单定义"><a href="#单向链表的简单定义" class="headerlink" title="#单向链表的简单定义"></a>#单向链表的简单定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="哨兵节点"><a href="#哨兵节点" class="headerlink" title="#哨兵节点"></a>#哨兵节点</h3><p>哨兵节点是为了简化处理链表边界条件而引入的附加链表节点。哨兵节点通常位于链表的头部，它的值没有任何意义。在一个有哨兵节点的链表中，从第2个节点开始才真正保存有意义的信息。</p>
<p><strong>用哨兵节点简化链表的插入操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">append</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode newNode = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="comment">// 索引到链表的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.next = newNode;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码需要用if语句来单独处理输入头节点head为null的情形。可以用哨兵节点简化代码的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">append</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode newNode = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">    ListNode node = dummy;</span><br><span class="line">    <span class="comment">// 索引到链表的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.next = newNode;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>用哨兵节点简化链表的删除操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">delete</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断删除的节点是否是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head.val == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next.val == value) &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码用两条if语句来处理两个特殊情况</p>
<ol>
<li>输入的链表为空</li>
<li>被删除的节点是原始链表的头节点</li>
</ol>
<p>可以用哨兵节点简化代码逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">delete</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode node = dummy;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next.val == value) &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>合理应用哨兵节点，就不再需要单独处理这些特殊的输入。</strong></p>
<h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="#双指针"></a>#双指针</h3><p>按移动方式可以细分成两种不同的方法。</p>
<ol>
<li>前后双指针，即一个指针在链表中提前朝着指向下一个节点的指针移动若干步，然后移动第二个指针。<strong>前后双指针的经典应用是查找链表的倒数第k个节点。</strong></li>
<li>快慢双指针，即两个指针在链表中移动的速度不一样，通常是快的指针朝着指向下一个节点的指针一次移动两步，慢的指针一次只移动一步。<strong>采用这种方法，在一个没有环的链表中，当快的指针到达链表尾节点的时候慢的指针正好指向链表的中间节点。</strong></li>
</ol>
<h3 id="21-删除倒数第k个节点"><a href="#21-删除倒数第k个节点" class="headerlink" title="#21 删除倒数第k个节点"></a>#21 删除倒数第k个节点</h3><p>如果给定一个链表，请问如何删除链表中的倒数第k个节点？假设链表中节点的总数为n，那么1&lt;=k&lt;=n。要求只能遍历链表一次。</p>
<p>例如：</p>
<p>输入链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，删除倒数第2个节点之后的链表为</p>
<p>1-&gt;2-&gt;3-&gt;4-&gt;6</p>
<p>分析：</p>
<p>如果可以遍历链表两次，那么这个问题就会变得简单。在第1次遍历链表时，可以得出链表的节点总数n。在第2次遍历链表时，可以找出链表的第n-k个节点(即倒数第k+1个节点)，然后通过修改指针，即可删除倒数第k个节点。</p>
<p>但是题目要求只能遍历链表一次。我们可以定义两个指针，来遍历一次就找到倒数第k+1个节点。第一个指针P1从链表头节点开始先走k步，第二个指针P2保持不动；从第k+1步开始指针P2也从链表的头节点开始和指针P1以相同的速度遍历。由于两个指针的距离始终保持为k，当指针P1指向链表的尾节点时指针P2正好指向倒数第k+1个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode front = head, back = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        front = front.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为前指针是从head开始，相当于开始时多走了一步</span></span><br><span class="line">    <span class="comment">// 所以判断条件为front != null 而不是 front.next != null</span></span><br><span class="line">    <span class="keyword">while</span> (front != <span class="keyword">null</span>) &#123;</span><br><span class="line">        front = front.next;</span><br><span class="line">        back = back.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    back.next = back.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：遍历列表一边，**时间复杂度为O(n)**。</p>
<h3 id="22-链表中环的入口节点"><a href="#22-链表中环的入口节点" class="headerlink" title="#22 链表中环的入口节点"></a>#22 链表中环的入口节点</h3><p>如果一个链表中包含环，那么应该如何找出环的入口节点？从链表的头节点开始顺着next指针方向进入环的第1个节点为环的入口节点。</p>
<p>例如：下图所示的链表中，环的入口节点是3。</p>
<p><img src="image-20211102122856262.png" alt="image-20211102122856262"></p>
<p>分析：</p>
<ol>
<li><p>第一步是确定一个链表中是否包含环。如果链表中没有环，自然不存在环的入口节点，此时应该返回null。</p>
<p>可以用两个指针来判断链表中是否有环。指针P1，P2同时从头节点出发，P1一次走一步，P2一次走两步。如果链表中不包含环，P2指针直至抵达链表的尾节点都不会和走得慢的指针相遇。如果链表中包含环，走得快的指针在环里绕了一圈之后将会追上走得慢的指针。因此，<strong>可以根据一快一慢两个指针能否相遇来判断链表中是否包含环。</strong></p>
</li>
<li><p>第二步是如何找到环的入口节点，还是可以用两个指针来解决。先定义两个指针P1，P2指向指向链表的头节点。如果链表中的环有n个节点，指针P1先在链表中向前移动n步，然后两个指针以相同的速度向前移动。当指针P2指向环的入口时，指针P1已经围绕环走了一圈又回到了入口节点。</p>
<p><img src="image-20211102124559505.png" alt="image-20211102124559505"></p>
</li>
<li><p>最后一个问题是如何得到环中节点的数目。前面用一快一慢两个指针判断链表中是否存在环时，两个指针相遇的节点一定在环中。可以从这个相遇的节点出发一边继续向前移动一边计数，当再次回到这个节点时就可以得到环中节点的数目。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">getNodeInLoop</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实两个指针不是必须都从头节点出发</span></span><br><span class="line">    <span class="comment">// 只要一快一慢两个指针相遇，即可判断成环</span></span><br><span class="line">    ListNode slow = head.next;</span><br><span class="line">    ListNode fast = slow.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle1</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode inLoop = getNodeInLoop(head);</span><br><span class="line">    <span class="keyword">if</span> (inLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到环中的节点数量n</span></span><br><span class="line">    <span class="keyword">int</span> loopCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ListNode n = inLoop; n.next != inLoop; n = n.next) &#123;</span><br><span class="line">        loopCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针先向前移动n步</span></span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopCount; i++) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针一起移动直至相遇</span></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>分析：</p>
<ol start="4">
<li><p>上述解法需要求出链表的环中节点的数目。但是如果仔细分析，就会发现没必要求出环中节点的数目。慢的指针一次走一步，假设在相遇时慢的指针走了k步。由于快的指针一次走两步，因此在相遇时快的指针一共走了2k步。因此相遇时慢的指针比快的指针多走了k步。另外，两指针相遇时快的指针比慢的指针在环中多转了若干全，也就是说，<strong>快指针多走的步数k一定是环中节点数目的整数倍。满指针走过的步数k也是环中节点数目的整数倍。</strong></p>
<p>基于此思想，可以让一个指针指向相遇的节点，该指针的位置是之前慢的指针走了k步到达的位置。接着让另一个指针指向链表的头节点，然后两个指针以相同的速率一起移动，<strong>此时两指针相遇，前指针比后指针多走k步，相遇的节点刚好是环的入口节点</strong>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode inLoop = getNodeInLoop(head);</span><br><span class="line">    <span class="keyword">if</span> (inLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inLoop提前移动了k步，node指向头节点</span></span><br><span class="line">    <span class="comment">// 然后两者以相同速率一起移动</span></span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != inLoop) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        inLoop = inLoop.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="23-两个链表的第1个重合节点"><a href="#23-两个链表的第1个重合节点" class="headerlink" title="#23 两个链表的第1个重合节点"></a>#23 两个链表的第1个重合节点</h3><p>输入两个单向链表，如何找出它们的第1个重合节点。</p>
<p>例如：</p>
<p><img src="image-20211102144127782.png" alt="image-20211102144127782"></p>
<p>此时两个链表的第1个重合节点的值是4。</p>
<p>分析：</p>
<p>很直观地想到暴力法求解。在第1个链表中按顺序遍历每个节点，每遍历到一个节点时，在第2个链表中顺序遍历每个节点，然后进行比较。如果第1个链表的长度为m，第2个链表的长度为n，那么该方法的时间复杂度是O(mn)。蛮力法一般不是最好的解法， 所以进一步分析此种链表的特点以求突破。</p>
<p>特点1：可以在重合的两个链表的基础上构造一个包含环的链表。</p>
<p><img src="image-20211102145829302.png" alt="image-20211102145829302"></p>
<p>此时，环的入口节点即是两个链表的第1个重合节点。可以利用上一题的方法解决。</p>
<p>特点2：如果两个单向链表有重合节点，那么从某个节点开始这两个链表的next指针都指向同一个节点。</p>
<p>那么如果我们可以从链表的尾部开始比较，最后一个相同的节点就是我们要找的节点。想要实现从尾部开始比较，可以利用栈这种先进后出的结构。将两个链表分别入栈，然后比较栈顶结点。如果两链表的长度分别为m，n，此种方法的**时间复杂度为O(m+n)<strong>。</strong>空间复杂度也为O(m+n)**。</p>
<p>上述方法之所以要用栈，是因为我们希望能同时到达两个链表的尾节点。当两个链表的长度不同时，如果从头开始遍历，到达尾节点的时间就不一致。其实解决这个问题有更简单的方法：首先遍历两个链表得到它们的长度，这样就能知道哪个链表比较长，以及长链表比短链表多几个节点。假设长链表比短链表多k个节点。第2次遍历时，指针P1，P2分别指向长短链表的头部。指针P1先在长链表中移动k步，然后两指针同时移动，此时两指针相遇的节点即是第一个公共节点。此种方法的**时间复杂度也是O(m+n)<strong>，</strong>由于不需要用栈，空间复杂度为O(1)**。</p>
<p><img src="image-20211102151210407.png" alt="image-20211102151210407"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count1 = countList(headA);</span><br><span class="line">    <span class="keyword">int</span> count2 = countList(headB);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> delta = Math.abs(count1 - count2);</span><br><span class="line">    ListNode longer = count1 &gt; count2 ? headA : headB;</span><br><span class="line">    ListNode shorter = count1 &gt; count2 ? headB : headA;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++) &#123;</span><br><span class="line">        longer = longer.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (longer != shorter) &#123;</span><br><span class="line">        shorter = shorter.next;</span><br><span class="line">        longer = longer.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="#24 反转链表"></a>#24 反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>例如：</p>
<p><img src="image-20211102152116962.png" alt="image-20211102152116962"></p>
<p>分析：</p>
<p>在调整节点指针时，除了需要知道节点本身，还要知道它的前一个节点和后一个节点。所以在遍历链表逐个反转每个节点的next指针时需要用到3个指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：遍历链表一边，**时间复杂度O(n)<strong>，</strong>空间复杂度O(1)**。</p>
<h3 id="25-链表中的数字相加"><a href="#25-链表中的数字相加" class="headerlink" title="#25 链表中的数字相加"></a>#25 链表中的数字相加</h3><p>给定两个表示非负整数的单向链表，请问如何实现这两个整数的相加并把它们的和仍然用单向链表表示？链表中的每个节点表示整数十进制的一位，并且头节点对应整数的最高位而尾节点对应整数的个位。</p>
<p>例如：</p>
<p><img src="image-20211102154056177.png" alt="image-20211102154056177"></p>
<p>分析：</p>
<p>第一反应是，根据链表求出整数，然后将整数相加，最后把结果用链表表示。<strong>这种思路最大的问题是没考虑到整数有可能会溢出</strong>，当链表较长时，可能会超出int甚至long的范围。</p>
<p>通常两整数相加，都是先算低位再算高位，因为还要考虑进位的问题。所以想到可以把链表反转，然后在逐个节点上实现加法。最后把表示和的链表反转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    head1 = reverseList(head1);</span><br><span class="line">    head2 = reverseList(head2);</span><br><span class="line">    ListNode reversedHead = addReversed(head1, head2);</span><br><span class="line">    <span class="keyword">return</span> reverseList(reversedHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">addReversed</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode sumNode = dummy;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> || head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (head1 == <span class="keyword">null</span> ? <span class="number">0</span> : head1.val)</span><br><span class="line">            + (head2 == <span class="keyword">null</span> ? <span class="number">0</span> : head2.val) + carry;</span><br><span class="line">        carry = sum &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        sum = sum &gt;= <span class="number">10</span> ? sum - <span class="number">10</span> : sum;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line"></span><br><span class="line">        sumNode.next = newNode;</span><br><span class="line">        sumNode = sumNode.next;</span><br><span class="line"></span><br><span class="line">        head1 = head1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : head1.next;</span><br><span class="line">        head2 = head2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : head2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后的进位</span></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sumNode.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="26-重排链表"><a href="#26-重排链表" class="headerlink" title="#26 重排链表"></a>#26 重排链表</h3><p>给定一个链表，链表中节点的顺序是L0-&gt;L1-&gt;L2-&gt;…-&gt;Ln-1-&gt;Ln，请问如何重排链表使节点的顺序变成L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;L2-&gt;Ln-2…</p>
<p>例如：</p>
<p><img src="image-20211102160234120.png" alt="image-20211102160234120"></p>
<p>分析：</p>
<p>观察输入链表和输出链表之间的关系，发现重排链表实际上是把链表分成前后两半。在示例链表中，前半段包含1、2、3三个节点，后半段包含4、5、6三个节点。然后把后半段链表反转，再与前半段链表拼接。</p>
<p>首先需要解决的问题是如何把一个链表分成两半，即找到链表的中间节点。可以一快一慢两个指针实现。两个指针同时从链表的头节点出发，快的指针一次走两步，慢的指针一次走一步，当快的指针走到链表的尾节点时，慢的指针刚好走到链表的中间节点。要注意：链表的节点总数可能是奇数也可能是偶数。当链表的节点总数是奇数时，要确保链表的前半段比后半段多一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode fast = dummy;</span><br><span class="line">    ListNode slow = dummy;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode temp = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    link(head, reverseList(temp), dummy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(ListNode node1, ListNode node2, ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = head;</span><br><span class="line">    <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = node1.next;</span><br><span class="line"></span><br><span class="line">        prev.next = node1;</span><br><span class="line">        node1.next = node2;</span><br><span class="line">        prev = node2;</span><br><span class="line"></span><br><span class="line">        node1 = temp;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.next = node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，当变量fast指向尾节点时，变量slow指向前半段的最后一个节点。</p>
<h3 id="27-回文链表"><a href="#27-回文链表" class="headerlink" title="#27 回文链表"></a>#27 回文链表</h3><p>如何判断一个链表是不是回文？要求解法的时间复杂度是O(n)，并且不得使用超过O(1)的辅助空间。</p>
<p>例如：</p>
<p><img src="image-20211107151640955.png" alt="image-20211107151640955"></p>
<p>分析：</p>
<p>如果不考虑辅助空间的限制，直观的解法是创建一个新的链表，链表中的节点顺序和输入链表的节点顺序正好相反。二者比较即可判断是否是回文链表，此时需要O(n)的辅助空间。</p>
<p>分析回文链表的特点以找出更好的解法。回文链表的一个特性是对称性，也就是说，如果把链表分为前后两半，那么前半段链表反转之后与后半段链表是相同的。因此可以想到把链表分成前后两半，然后把其中一半反转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode secondHalf = slow.next;</span><br><span class="line">    <span class="comment">// 如果fast.next != null，说明链表中节点个数为奇数</span></span><br><span class="line">    <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 跳过中间节点</span></span><br><span class="line">        secondHalf = slow.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> equals(secondHalf, reverseList(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.val != head2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head1 = head1.next;</span><br><span class="line">        head2 = head2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head1 == <span class="keyword">null</span> &amp;&amp; head2 == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，不管链表的节点总数是奇数还是偶数，变量slow都指向链表前半段的最后一个节点。</p>
<h3 id="双向链表和循环链表"><a href="#双向链表和循环链表" class="headerlink" title="双向链表和循环链表"></a>双向链表和循环链表</h3><p>由于单向链表只能从头节点开始遍历到尾节点，遍历的顺序受到限制，在很多场景下使用起来不太方便，因此双向链表应运而生。双向链表在单向链表节点的基础上增加了指向前一个节点的指针，这样一来，既可从前往后遍历，也可以从后向前遍历。</p>
<p>如果把链表尾节点的下一个节点的指针指向链表的头节点，那么此时链表就变成一个循环链表。循环链表既可以是单向链表，也可以是双向链表。</p>
<h3 id="28-展平多级双向链表"><a href="#28-展平多级双向链表" class="headerlink" title="#28 展平多级双向链表"></a>#28 展平多级双向链表</h3><p>在一个多级双向链表中，节点除了有两个指针分别指向前后两个节点，还有一个指针指向它的子链表，并且子链表也是一个双向链表，它的节点也有指向子链表的指针。请将这样的多级双向链表展成普通的双向链表，即所有节点都没有子链表。</p>
<p>例如：</p>
<p><img src="image-20211107160039114.png" alt="image-20211107160039114"></p>
<p>分析：</p>
<p>展平的规则是一个节点的子链表展平之后将插入该节点和它的下一个节点之间。由于子链表中的节点也有可能有子链表，<strong>因此这里的链表是一个递归的结构</strong>。在展平子链表时，如果它也有自己的子链表，那么它嵌套的子链表也要一起展平。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    flattenGetTail(head);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">flattenGetTail</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node node = head;</span><br><span class="line">    Node tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        <span class="keyword">if</span> (node.child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node child = node.child;</span><br><span class="line">            Node childTail = flattenGetTail(node.child);</span><br><span class="line"></span><br><span class="line">            node.child = <span class="keyword">null</span>;</span><br><span class="line">            node.next = child;</span><br><span class="line">            child.prev = node;</span><br><span class="line">            childTail.next = next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                next.prev = childTail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tail = childTail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，递归函数flattenGetTail在展平以head为头节点的链表之后返回链表的尾节点。在该函数中需要逐一扫描链表中的节点。如果一个节点node有子链表，由于子链表也可能有嵌套的子链表，因此先递归调用flattenGetTail函数展平子链表，子链表展平之后头节点时child，尾节点是childTail。最后将展平的子链表插入节点node和它的下一个节点next之间，即把展平的子链表头节点child插入节点node之后，并将尾节点childTail插入节点next之前。</p>
<p>这种解法每个节点都会遍历一次，如果链表总共有n个节点，那么时间复杂度时O(n)。函数flattenGetTail的递归调用次数取决于链表嵌套的次数，因此，如果链表的层数为k，那么该节点的空间复杂度是O(k)。</p>
<h3 id="29-排序的循环链表"><a href="#29-排序的循环链表" class="headerlink" title="#29 排序的循环链表"></a>#29 排序的循环链表</h3><p>在一个循环链表中节点的值递增排序，请设计一个算法在该循环链表中插入节点，并保证插入节点之后循环链表仍然是排序的。</p>
<p>例如：</p>
<p><img src="image-20211107163817220.png" alt="image-20211107163817220"></p>
<p>分析：</p>
<p>再插入节点4时，新的节点位于3，5节点之间。为了使插入新节点后循环链表仍然是排序的，新节点的前一个节点的值应该比新节点的值小，后一个节点的值应该比新节点大。</p>
<p>但是特殊情况需要特殊处理。</p>
<p>特殊情况1：如果新节点是链表中最大或最小的节点，新的节点将被插入到最大值和最小值之间。</p>
<p>特殊情况2：如果链表中的节点数小于2，那么应该有两种可能。第1种可能是开始的时候链表是空的，一个节点都没有，此时插入一个新的节点，该节点成为循环链表中唯一的节点，那么next指针指向节点自己。第2种可能是开始的时候链表中只有一个节点，插入一个新的节点之后，两个节点的next指针互相指向对方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">insert</span> <span class="params">(Node head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(insertVal);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        head.next = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == head) &#123;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.next = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertCore(head, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertCore</span><span class="params">(Node head, Node node)</span> </span>&#123;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = head.next;</span><br><span class="line">    Node biggest = head;</span><br><span class="line">    <span class="comment">// 如果是因为不满足next != head退出，表示新节点是链表中最大或最小的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!(cur.val &lt;= node.val &amp;&amp; next.val &gt;= node.val &amp;&amp; next != head)) &#123;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; biggest.val) &#123;</span><br><span class="line">            biggest = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur.val &lt;= node.val &amp;&amp; next.val &gt;= node.val) &#123;</span><br><span class="line">        cur.next = node;</span><br><span class="line">        node.next = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.next = biggest.next;</span><br><span class="line">        biggest.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="30-插入、删除和随机访问都是O-1-的容器"><a href="#30-插入、删除和随机访问都是O-1-的容器" class="headerlink" title="#30 插入、删除和随机访问都是O(1)的容器"></a>#30 插入、删除和随机访问都是O(1)的容器</h3><p>设计一个数据结构，使如下3个操作的时间复杂度都是O(1)。</p>
<ul>
<li>insert(value)：如果数据集种不包含一个数值，则把它添加到数据集中。</li>
<li>remove(value)：如果数据集中包含一个数值，则把它删除。</li>
<li>getRandom()：随机返回数据集中的一个数值，要求数据集中每个数字被返回的概率都相同。</li>
</ul>
<p>分析：</p>
<p>由于要求插入和删除的时间复杂度都是O(1)，因此需要用哈希表来实现。</p>
<p>如果只用哈希表，则不能等概率地返回其中的每个数值。如果数值是保存在数组中的，那么很容易实现等概率地返回其中的每个数值。假设数组的长度是n，那么等概率生成从0到n-1的一个数字。如果生成的随机数是i，则返回数组中下标为i的数值。由此可以发现，需要结合哈希表和数组来设计这个数据容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; numToLocation;</span><br><span class="line">    ArrayList&lt;Integer&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        numToLocation = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numToLocation.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        numToLocation.put(val, nums.size());</span><br><span class="line">        nums.add(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!numToLocation.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用数组中最后一个元素覆盖要删除的元素，并修改哈希表中对应位置的键值对</span></span><br><span class="line">        <span class="keyword">int</span> location = numToLocation.get(val);</span><br><span class="line">        numToLocation.put(nums.get(nums.size() - <span class="number">1</span>), location);</span><br><span class="line">        numToLocation.remove(val);</span><br><span class="line">        nums.set(location, nums.get(nums.size() - <span class="number">1</span>));</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> r = random.nextInt(nums.size());</span><br><span class="line">        <span class="keyword">return</span> nums.get(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="31-最近最少使用缓存"><a href="#31-最近最少使用缓存" class="headerlink" title="#31 最近最少使用缓存"></a>#31 最近最少使用缓存</h3><p>设计实现一个最近最少使用(Least Recently Used, LRU)缓存，要求如下两个操作的时间复杂度都是O(1)。</p>
<ul>
<li>get(key)：如果缓存中存在键key，则返回它对应的值，否则返回-1</li>
<li>put(key,value)：如果缓存中之前包含key，则它的值设为value；否则添加键key及对应的值value。在添加一个键时，如果缓存容量已经满了，则在添加新键之前删除最近最少使用的键(缓存中最长时间没有被使用过的元素)。</li>
</ul>
<p>分析：</p>
<p>哈希表的get和put操作的时间复杂度都是O(1)，但普通的哈希表无法找出最近最少使用的键，因此需要在哈希表的基础上进行改进。</p>
<p>由于需要知道缓存中最近最少使用的元素，因此可以把缓存中的元素存入链表中。每次访问一个元素(无论是通过get还是put操作)，该元素都被移到链表的尾部。这样，<strong>位于链表头部的元素就是最近最少使用的。</strong></p>
<p>如果这个链表是单向链表，那么找到一个节点的前一个节点需要从链表的头节点开始遍历链表，需要O(n)的时间。因此可以用双向链表来存储缓存中的元素。在双向链表中查找一个结点的前一个节点，只需要顺着prev指针向前走一步，时间复杂度为O(1)。</p>
<p>首先定义双向链表中的节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    <span class="keyword">public</span> ListNode prev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后定义最近最少使用缓存的数据结构。缓存中包含一个哈希表，哈希表的键就是缓存的键，哈希表的值是双向链表中的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line">    <span class="keyword">private</span> ListNode tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ListNode&gt; map;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个容量为cap的缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line"></span><br><span class="line">        capacity = cap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了便于在双向链表中添加和删除节点，上述代码创建了两个哨兵节点，即head和tail，他们分别位于双向链表的头部和尾部。函数put所添加的节点将位于这两个节点之间。</p>
<p>接下来实现get，put及辅助函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    ListNode node = map.get(key);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    moveToTail(node, node.value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">        moveToTail(map.get(key), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">            ListNode toBeDelete = head.next;</span><br><span class="line">            deleteNode(toBeDelete);</span><br><span class="line"></span><br><span class="line">            map.remove(toBeDelete.key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(key, value);</span><br><span class="line">        insertToTail(node);</span><br><span class="line"></span><br><span class="line">        map.put(key, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToTail</span><span class="params">(ListNode node, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    deleteNode(node);</span><br><span class="line"></span><br><span class="line">    node.value = newValue;</span><br><span class="line">    insertToTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.prev.next = node.next;</span><br><span class="line">    node.next.prev = node.prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertToTail</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    tail.prev.next = node;</span><br><span class="line">    node.prev = tail.prev;</span><br><span class="line">    node.next = tail;</span><br><span class="line">    tail.prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="32-有效的变位词"><a href="#32-有效的变位词" class="headerlink" title="#32 有效的变位词"></a>#32 有效的变位词</h3><p>给定两个字符串s和t，请判断它们是不是一组变位词。在一组变位词中，他们中的字符及每个字符出现的次数都相同， 但字符的顺序不能相同。</p>
<p>例如：</p>
<p>“anagram”和”nagaram”就是一组变位词。</p>
<p>分析：</p>
<p>由于变位词和字符出现的次数相关，因此可以用一个哈希表来存储每个字符出现的次数。哈希表的键是字符，而值是对应字符出现的次数。<strong>如果哈希表的键取值范围是固定的，而且范围不是很大，则可以用数组来模拟哈希表。</strong></p>
<p>如果只考虑英文字母，则用数组来模拟哈希表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram1</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 长度不同一定不是同位词</span></span><br><span class="line">    <span class="keyword">if</span> (str1.length() != str2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符顺序相同也不是同位词</span></span><br><span class="line">    <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str1.toCharArray()) &#123;</span><br><span class="line">        counts[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str2.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counts[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入字符串的长度为n，上述解法的**时间复杂度为O(n)<strong>。不管字符串的长度如何，辅助数组的长度都是固定的，因此</strong>空间复杂度是O(1)**。</p>
<p>如果考虑用字符串表示中文或其他非英语语言，那么ASCII码字符集是不够的。因为一个ASCII码字符的长度为8位，所以ASCII码字符集能包含256个不同的字符，中文及很多语言的字符集都远远超过这个数字。为了包含更多的字符，需要其他编码的字符集，目前使用最多的是Unicode编码。一个Unicode的字符的长度为16位，这样就能表示65536个字符。此种情况下，如果还和之前一样，创建一个长度为65536的数组，似乎会浪费内存。所以此时就可以创建一个类型为HashMap的真正的哈希表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram2</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1.length() != str2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str1.toCharArray()) &#123;</span><br><span class="line">        counts.put(ch, counts.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str2.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counts.containsKey(ch) || counts.get(ch) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counts.put(ch, counts.get(ch) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的**时间复杂度仍然是O(n)<strong>。但是如果输入的字符串中不同字符的数目越多，HashMap就需要越多的空间。因此，可以认为使用HashMap的</strong>空间复杂度是O(n)**。</p>
<h3 id="33-变位词组"><a href="#33-变位词组" class="headerlink" title="#33 变位词组"></a>#33 变位词组</h3><p>给定一组单词，请将他们按照变位词分组。假设单词中只包含英文小写字母。</p>
<p>例如：输入一组单词[“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]，这组单词可以分成三组，分别是[“eat”, “tea”, “ate”]、[“tan”, “nat”]、[“bat”]。</p>
<p>分析：</p>
<p>解决这个问题，就需要找出一组变位词共同的特性，然后依据此特性把它们分到一组。这里主要介绍两种方法：</p>
<ol>
<li><p>将单词映射到数字。把每个英文小写字母映射到一个质数，如把字母’a’映射到数字2，字母’b’映射到数字3，以此类推。字母’z’映射到第26个质数101。每给出一个单词，就把单词中的所有字母对应的数字相乘，于是每个单词都可以算出一个数字。例如，单词’eat’可以映射到数字1562(11*2*71)。’</p>
<p>如果两个单词护卫变位词，那么它们中每个字母出现的次数都对应相同，由于乘法满足交换律，因此上述算法把一组变位词映射到同一个数值。由于每个字母都是映射到一个质数，因此不互为变位词的两个单词一定会映射到不同的数字。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams1(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">int</span> hash[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Map&lt;Long, List&lt;String&gt;&gt; groups = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="keyword">long</span> wordHash = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            wordHash *= hash[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        groups.putIfAbsent(wordHash, <span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">        groups.get(wordHash).add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(groups.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入n个单词，平均每个单词有m个字母，那么该算法的时间复杂度是O(mn)。</p>
<p>该算法有一个潜在的问题：<strong>由于把单词映射到数字用到了乘法，因此当单词非常长时，乘法就有可能溢出</strong>。</p>
<ol start="2">
<li>将单词的字母排序。互为变位词的单词排序后会得到相同的字符串。因此可以定义一个哈希表，哈希表的键是把单词字母排序得到的字符串，而值是一组变位词。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams2(String[] strs) &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; groups = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        Arrays.sort(charArray);</span><br><span class="line">        String sorted = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">        groups.putIfAbsent(sorted, <span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">        groups.get(sorted).add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(groups.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果每个单词平均有m个字母，排序一个单词需要O(mlogm)的时间，假设总共有n个单词，该算法总的时间复杂度是<strong>O(nmlogm)<strong>。</strong>虽然该方法的时间效率不如前一种方法，但是该方法不用担心乘法可能带来的溢出问题。</strong></p>
<h3 id="34-外星语言是否排序"><a href="#34-外星语言是否排序" class="headerlink" title="#34 外星语言是否排序"></a>#34 外星语言是否排序</h3><p>y偶一门外星语言，它的子目标刚好包含所有的英文小写字母，只是字母表的顺序不同。给定一组单词和字母表顺序，请判断这些单词是否按照字母表的顺序排序。</p>
<p>例如：输入一组单词[“offer”, “is”, “comming”]，以及字母表顺序”zyxwvutsrqponmlkjihgfedcba”，由于字母’o’在字母表中位于’i’的前面，因此单词”offer”排在”is”的前面；同理，单词”is”排在”comming”的前面。因此，这一组单词是按照字母表顺序排序的，应该输出true。</p>
<p>分析：</p>
<p>为了方便查找每个字母在字母表中的顺序，可以创建一个哈希表，哈希表的键为字母表的每个字母，而值为字母在字母表中的顺序。字母表中字母的数目是固定的，一共26个。所以可以用数组来模拟哈希表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlienSorted</span><span class="params">(String[] words, String order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] orderArray = <span class="keyword">new</span> <span class="keyword">int</span>[order.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.length(); i++) &#123;</span><br><span class="line">            orderArray[order.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSorted(words[i], words[i + <span class="number">1</span>], orderArray)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(String word1, String word2, <span class="keyword">int</span>[] order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; word1.length() &amp;&amp; i &lt; word2.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = word1.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> ch2 = word2.charAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (order[ch1 - <span class="string">&#x27;a&#x27;</span>] &lt; order[ch2 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (order[ch1 - <span class="string">&#x27;a&#x27;</span>] &gt; order[ch2 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i == word1.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入n个单词，每个单词的平均长度为m，那么该算法的**时间复杂度是O(mn)<strong>，</strong>空间复杂度是O(1)**。</p>
<h3 id="35-最小时间差"><a href="#35-最小时间差" class="headerlink" title="#35 最小时间差"></a>#35 最小时间差</h3><p>给定一组范围在00:00至23:59的时间，求任意两个时间之间的最小时间差。</p>
<p>例如：输入时间数组[“23:50”, “23:59”, “00:00”]，”23:59”和”00:00”之间只有1分钟的间隔，是最小的时间差。</p>
<p>分析：</p>
<p>最直观的解法是求出任意两个时间的间隔，然后得出最小的是价差。如果输入n个时间，这种蛮力法需要O(n^2)的时间。</p>
<p>上述解法的一个优化是把n个时间排序，排序后只需要计算两相邻时间之间的间隔，这样就只需要计算O(n)个时间差。由于对n个时间进行排序通常需要O(nlogn)的时间，因此这种优化算法的总体时间复杂度是O(nlogn)。</p>
<p>一个特殊情况需要考虑：”00:00”也有可能是第二天的00:00，所以在计算时要考虑到两种情况: </p>
<ol>
<li>最小时间间隔出现在同一天</li>
<li>最小时间间隔需要和第二天00:00比较</li>
</ol>
<p>一天有24小时，即1440分钟。如果用一个长度为1440的数组表示一天的时间，那么数组的下标为0的位置对应时间00:00，下表为1的位置对应时间00:01。数组中的每个元素是true或false标识。由于数组的下标对应的是时间，因此两个时间之间的时间差就是他们在数组中对应的下标之差。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 列表长度大于1440，则一定出现了两个相同时间，所以最小时间间隔为0</span></span><br><span class="line">    <span class="keyword">if</span> (timePoints.size() &gt; <span class="number">1440</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> minutesFlags[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1440</span>];</span><br><span class="line">    <span class="keyword">for</span> (String time : timePoints) &#123;</span><br><span class="line">        String t[] = time.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> min = Integer.parseInt(t[<span class="number">0</span>]) * <span class="number">60</span> + Integer.parseInt(t[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 如果为true，则列表中出现了两个相同时间，即最小时间间隔为0</span></span><br><span class="line">        <span class="keyword">if</span> (minutesFlags[min]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        minutesFlags[min] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(minutesFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">boolean</span> minuteFlags[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minDiff = minuteFlags.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> first = minuteFlags.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minuteFlags.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minuteFlags[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                minDiff = Math.min(i - prev, minDiff);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prev = i;</span><br><span class="line">            first = Math.min(i, first);</span><br><span class="line">            last = Math.max(i, last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minDiff = Math.min(minuteFlags.length - last + first, minDiff);</span><br><span class="line">    <span class="keyword">return</span> minDiff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设输入时间的数目是n。上述代码中有两个for循环，主函数for的时间复杂度是O(n)；辅助函数helper的for循环执行次数为minuteFlags的长度1440，所以时间复杂度为O(1)。因此**总时间复杂度为O(n)<strong>。该方法需要创建一个长度为常数的辅助数组，</strong>空间复杂度为O(1)**。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="Java中stack的常用操作"><a href="#Java中stack的常用操作" class="headerlink" title="# Java中stack的常用操作"></a># Java中stack的常用操作</h3><table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>push(e)</td>
<td>元素e入栈</td>
</tr>
<tr>
<td>2</td>
<td>pop</td>
<td>位于栈顶的元素出栈，并返回该元素</td>
</tr>
<tr>
<td>3</td>
<td>peek</td>
<td>返回位于栈顶的元素，该元素不出栈</td>
</tr>
</tbody></table>
<h3 id="36-后缀表达式"><a href="#36-后缀表达式" class="headerlink" title="#36 后缀表达式"></a>#36 后缀表达式</h3><p>后缀表达式是一种算术表达式，它的操作符在操作数的后面。输入一个用字符串数组表示的后缀表达式，请输出该后缀表达式的计算结果。假设输入的一定是有效的后缀表达式。</p>
<p>例如：后缀表达式[“2”, “1”, “3”, “*”, “+”]对应的算术表达式是”2+1*3”，因此输出它的计算结果5。</p>
<p>分析：</p>
<p>先将操作数入栈，遇到操作符时从栈中取出两个操作数进行运算，运算结果再入栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    <span class="keyword">int</span> num1 = stack.pop();</span><br><span class="line">                    <span class="keyword">int</span> num2 = stack.pop();</span><br><span class="line">                    <span class="comment">// 注意: 先取出来的是第二个操作数</span></span><br><span class="line">                    stack.push(calculate(num2, num1, token));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    stack.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, String operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 + num2;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 - num2;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 * num2;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 / num2;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在进行减法(除法)运算时，注意先出栈的是减数(除数)，后出栈的是被减数(被除数)。</strong></p>
<p>如果输入数组的长度是n，那么对其中的每个字符串都有一次push操作：如果是操作符，那么还需要进行数学计算和两次pop操作。由于每个push操作、pop操作和数学计算都是O(1)，因此总体**时间复杂度是O(n)<strong>。由于栈中可能有O(n)个操作数，因此</strong>空间复杂度也是O(n)**。</p>
<h3 id="37-小行星碰撞"><a href="#37-小行星碰撞" class="headerlink" title="#37 小行星碰撞"></a>#37 小行星碰撞</h3><p>输入一个表示小行星的数组，数组中每个数字的绝对值表示行星的大小，数字的正负号表示小行星运动的方向，正号表示向右飞行，负号表示向左飞行。如果两颗小行星相撞，那么体积较小的小行星将会爆炸最终消失，体积较大的小行星不受影响。如果相撞的两颗小行星大小形同，那么他们都会爆炸消失。飞行方向相同的小行星永远不会相撞。求最终剩下的小行星。</p>
<p>例如：有6颗小行星[4,5,-6,4,8,5]，它们相撞之后最终剩下3颗小行星[-6,4,8]。</p>
<p>分析：</p>
<p>根据题设总结小行星相撞的规律。如果一颗小行星向右飞行，可以将它入栈。如果一颗小行星向左飞行，而位于栈顶的小行星向右飞行，那么它将与位于栈顶的小行星相撞。如果位于栈顶的小行星较小，那么它将爆炸消失(出栈)。然后判断它是否将与下一刻位于栈顶的小行星相撞。如果小行星与栈中所有小行星相撞之后仍然没有爆炸消失，那么将它入栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] asteroidCollision(<span class="keyword">int</span>[] asteroids) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> as : asteroids) &#123;</span><br><span class="line">        <span class="comment">// 栈中有向右飞行的小行星，当前小行星向左飞行，且体积更大</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() &gt; <span class="number">0</span> &amp;&amp; stack.peek() &lt; -as) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈中有向右飞行的小行星，与当前向左飞行的小行星体积相等</span></span><br><span class="line">        <span class="keyword">if</span> (!stack.empty() &amp;&amp; as &lt; <span class="number">0</span> &amp;&amp; stack.peek() == -as) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (as &gt; <span class="number">0</span> || stack.empty() || stack.peek() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            stack.push(as);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，每颗小行星只可能入栈、出栈一次，因此**时间复杂度是O(n)，空间复杂度也是O(n)**。</p>
<h3 id="38-每日温度"><a href="#38-每日温度" class="headerlink" title="#38 每日温度"></a>#38 每日温度</h3><p>输入一个数组，它的每个数字是某天的温度。请计算每天需要等几天才会出现更高的温度。</p>
<p>例如：输入数组[35,31,33,36,34]，那么输出为[3,1,1,0,0]。由于第1天的温度是35℃，要等3天才会出现更高的温度36℃，因此对应的输出为3。第4天的温度为36℃，后面没有更高的温度，它对应的输出是0。其他的以此类推。</p>
<p>分析：</p>
<p>用一个栈保存每天的温度在数组中的下标。每次从数组中读取一个温度，然后将其与栈中保存的温度(根据下标可以得到温度)进行比较。如果当前温度比位于栈顶的温度高，那么就能知道位于栈顶那一天需要等待几天才会出现更高的温度。然后出栈1次，将当前温度与下一个位于栈顶的温度进行比较。如果栈中已经没有比当前温度低的温度，则将当前温度在数组中的下标入栈。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>温度/℃</th>
<th>栈</th>
<th>等待天数</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>35</td>
<td>[0]</td>
<td>[0,0,0,0,0]</td>
<td>0入栈</td>
</tr>
<tr>
<td>2</td>
<td>31</td>
<td>[0,1]</td>
<td>[0,0,0,0,0]</td>
<td>比较31，35，1入栈</td>
</tr>
<tr>
<td>3</td>
<td>33</td>
<td>[0,2]</td>
<td>[0,1,0,0,0]</td>
<td>比较33, 31, 1出栈; 比较33, 35, 2入栈</td>
</tr>
<tr>
<td>4</td>
<td>36</td>
<td>[3]</td>
<td>[3,1,1,0,0]</td>
<td>比较36, 33, 2出栈; 比较36, 35, 1出栈; 3入栈</td>
</tr>
<tr>
<td>5</td>
<td>34</td>
<td>[3,4]</td>
<td>[3,1,1,0,0]</td>
<td>比较34, 36, 4入栈</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[temperatures.length];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = stack.pop();</span><br><span class="line">            result[prev] = i - prev;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设数组的长度是n，虽然有一个嵌套的二重循环，但它的**时间复杂度是O(n)<strong>，这是因为数组中每个温度入栈、出栈各1次。这种解法的</strong>空间复杂度也是O(n)**。</p>
<h3 id="39-直方图最大矩形面积"><a href="#39-直方图最大矩形面积" class="headerlink" title="#39 直方图最大矩形面积"></a>#39 直方图最大矩形面积</h3><p>直方图是由排列在同一基线上的相邻柱子组成的图形。输入一个由非负数组成的数组，数组中的数字是直方图中柱子的高。求直方图中最大矩形的面积。假设直方图中柱子的宽都为1。</p>
<p>例如：输入数组[3,2,5,4,6,1,4,2]，该直方图中最大矩形面积为12。(已4为顶, 宽为3的矩形)</p>
<p>分析：</p>
<p>如果直方图中一个矩形的下标从i开始，到j结束，那么这两根柱子之间的矩形(含两端的柱子)的宽是j-i+1。矩形的高是两根柱子之间所有主子最矮的高度。</p>
<p>这里介绍三种解法：</p>
<ol>
<li>蛮力法。如果能逐一找出直方图中所有的矩形并比较他们的面积，就能得到最大矩形面积。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea1</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = heights[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; heights.length; j++) &#123;</span><br><span class="line">            min = Math.min(min, heights[j]);</span><br><span class="line">            <span class="keyword">int</span> area = min * (j- i + <span class="number">1</span>);</span><br><span class="line">            maxArea = Math.max(maxArea, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入数组的长度为n，直方图中总共有O(n^2)个矩形，则计算每个矩形的面积需要O(1)的时间，这种解法的**时间复杂度是O(n^2)<strong>。此解法没用到额外的内存开销，因此</strong>空间复杂度是O(1)**。</p>
<ol start="2">
<li>分治法。仔细观察直方图矩阵可以发现，直方图中最矮的柱子在数组中的下标是5，它的高度是1。这个直方图的最大矩形有3种可能。<strong>第1种</strong>是矩形通过这根最矮的柱子。通过最矮的柱子的最大举行的高为1，宽为7。<strong>第2种</strong>是矩形的起始柱子和终止柱子都在最矮的柱子左侧，也就是从下标为0的柱子到下标为4的柱子的直方图的最大矩形。<strong>第3种</strong>是矩形的起始柱子和终止柱子都在最矮的柱子右侧，也就是从下标为6的柱子到下标为7的柱子的直方图的最大矩形。第2种和第3种从本质上来说和求整个直方图的最大矩形面积是同一个问题，可以调用递归函数解决。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea2</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(heights, <span class="number">0</span>, heights.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果相等，代表只有一列</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">1</span> == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> heights[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minIndex = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heights[i] &lt; heights[minIndex]) &#123;</span><br><span class="line">            minIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为预设的范围不包括end，所以这里end-start不需要加1</span></span><br><span class="line">    <span class="keyword">int</span> area = (end - start) * heights[minIndex];</span><br><span class="line">    <span class="keyword">int</span> left = helper(heights, start, minIndex);</span><br><span class="line">    <span class="keyword">int</span> right = helper(heights, minIndex + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    area = Math.max(area, left);</span><br><span class="line">    <span class="keyword">return</span> Math.max(area, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>单调栈法</p>
<p>非常高效、巧妙的解法。这种解法用一个栈保存直方图的柱子，并且栈中的柱子高度是递增排序的。为了方便计算矩形的宽度，栈中保存的是柱子在数组中的下标，可以根据下标得到柱子的高度。</p>
<p>这种解法的基本思想是确保保存在栈中的直方图的柱子的高度是递增排序的。假设从左到右逐一扫描数组中的每根柱子，如果当前柱子的高度大于位于栈顶的柱子的高度，那么将该柱子的下标入栈；否则，将位于栈顶的下标出栈，并且计算以位于栈顶的柱子为顶的最大矩形的面积。</p>
<p>一番操作过后，以每个柱子为顶的最大直方图面积都会被计算。</p>
<p><strong>细节：如果某下标为i的柱子左侧没有柱子，这意味着它的左侧所有的柱子都比它高。因此，可以想象在下标为-1的位置有一根比它矮的柱子。</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea3</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">            <span class="comment">// 因为不包括第i根柱子，所以要-1</span></span><br><span class="line">            <span class="keyword">int</span> width = i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            maxArea = Math.max(maxArea, height * width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">        <span class="keyword">int</span> width = heights.length - stack.peek() - <span class="number">1</span>;</span><br><span class="line">        maxArea = Math.max(maxArea, height * width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同方法二，**时间复杂度和空间复杂度都为O(n)**。</p>
<h3 id="40-矩阵中国的最大矩形"><a href="#40-矩阵中国的最大矩形" class="headerlink" title="#40 矩阵中国的最大矩形"></a>#40 矩阵中国的最大矩形</h3><p>请在一个由0、1组成的矩阵中找出最大只包含1的矩形并输出它的面积。</p>
<p>例如：</p>
<p>[[1,0,1,0,0],</p>
<p>[0,0,1,1,1],</p>
<p>[1,1,1,1,1],</p>
<p>[1,0,0,1,0]]</p>
<p>此矩阵中最大的只包含1的矩阵面积为6。</p>
<p>分析：</p>
<p>可以把一个有n行的矩阵转换成n个直方图，进而转换成求直方图最大矩形面积的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    heights[i] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    heights[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxArea = Math.max(maxArea, largestRectangleArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">            <span class="comment">// 因为不包括第i根柱子，所以要-1</span></span><br><span class="line">            <span class="keyword">int</span> width = i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            maxArea = Math.max(maxArea, height * width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">        <span class="keyword">int</span> width = heights.length - stack.peek() - <span class="number">1</span>;</span><br><span class="line">        maxArea = Math.max(maxArea, height * width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设输入矩阵的大小为mxn，该矩阵可以转换成m个直方图，如果采用单调栈法，那么求每个直方图的最大矩形面积需要O(n)的时间，因此这种解法的**时间复杂度为O(mn)<strong>。使用单调栈法计算直方图中最大矩阵的面积需要O(n)的空间，同时要一个长度为n的数组heights，用于记录直方图中主子的高度，因此这种解法的</strong>空间复杂度是O(n)**。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="Java中Queue的常用操作"><a href="#Java中Queue的常用操作" class="headerlink" title="#Java中Queue的常用操作"></a>#Java中Queue的常用操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>抛异常</th>
<th>不抛异常</th>
</tr>
</thead>
<tbody><tr>
<td>插入元素</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>删除元素</td>
<td>remove</td>
<td>poll</td>
</tr>
<tr>
<td>返回最前面的元素</td>
<td>element</td>
<td>peek</td>
</tr>
</tbody></table>
<p>在Java中实现了接口Queue的常用类型有LinkedList, ArrayDeque和PriorityQueue等。但PriorityQueue并不是真正的队列。</p>
<h3 id="41-滑动窗口的平均值"><a href="#41-滑动窗口的平均值" class="headerlink" title="#41 滑动窗口的平均值"></a>#41 滑动窗口的平均值</h3><p>请实现如下类型MovingAverage，计算滑动窗口中所有数字的平均值，该类型构造函数的参数确定滑动窗口的大小，每次调用成员函数next时都会在滑动窗口中添加一个整数，并返回滑动窗口中所有数字的平均值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>分析：</p>
<p>滑动窗口满足先进先出的特点，因此可以用队列来实现。记录当前窗口的所有数字之和(用sum表示)，那么插入一个新的数字v1之后，窗口中的所有数字之和就是sum+v1。如果此时窗口的大小超出了限制，还需要删除一个数字v2，那么窗口中的所有数字之和是sum+v1-v2。因此，最多只需要一次假发和一次减法就能求出窗口中所有数字之和，**时间复杂度为O(1)**。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        nums = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        nums.offer(val);</span><br><span class="line">        sum += val;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &gt; capacity) &#123;</span><br><span class="line">            sum -= nums.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) sum / nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="42-最近请求次数"><a href="#42-最近请求次数" class="headerlink" title="#42 最近请求次数"></a>#42 最近请求次数</h3><p>请设计如下实现类型RecentCounter，它是统计过去3000ms内的请求次数的计数器。该类型的构造函数RecentCounter初始化计数器，请求数初始化为0; 函数ping(int t)在时间t添加一个新请求(t表示以毫秒为单位的时间)，并返回过去3000ms内(时间范围为[t-3000,t])发生的所有请求数。假设每次调用函数ping的参数t都比之前调用的参数值大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>分析：</p>
<p>最近请求次数，同样符合先进先出原则，可以用队列来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; times;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> windowSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.times = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.windowSize = <span class="number">3000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        times.offer(t);</span><br><span class="line">        <span class="keyword">while</span> (times.peek() &lt; t - windowSize) &#123;</span><br><span class="line">            times.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> times.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设计数器的时间窗口大小是w毫秒，其中记录的时间的递增的，那么时间窗口中记录的时间的数目是O(w)，因此**空间复杂度是O(w)<strong>。每当收到一个新的请求ping时，由于可能需要删除O(w)个已经滑出时间窗口的请求，因此</strong>时间复杂度也是O(w)**。由于此题中w是个常数，因此可以认为时间复杂度和空间复杂度都是O(1)。</p>
<h3 id="二叉树的广度优先搜索"><a href="#二叉树的广度优先搜索" class="headerlink" title="#二叉树的广度优先搜索"></a>#二叉树的广度优先搜索</h3><p>通常基于队列来实现二叉树的广度优先搜索。从二叉树的根节点开始，先把根节点放入一个队列之中，然后每次从队列中取出一个节点遍历。如果该节点有左右子节点，则分别将他们添加到队列当中。重复此过程直到所有节点都遍历完位置，此时队列为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        result.add(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设一棵二叉树有n个节点。由于逐层遍历每个节点，因此上述代码的时间复杂度时O(n)。如果把父节点已经遍历到但自身尚未到达的节点存储在队列之中，那么最多需要存储一层的节点。在一棵满的二叉树中，最下面一层的节点数最多，最多可能有(n+1)/2个节点，因此二叉树广度优先搜索的空间复杂度时O(n)。</p>
<h3 id="43-在完全二叉树中添加节点"><a href="#43-在完全二叉树中添加节点" class="headerlink" title="#43 在完全二叉树中添加节点"></a>#43 在完全二叉树中添加节点</h3><p>在完全二叉树中，除最后一层之外其他层的节点都是满的。最后一层的节点可能不满，该层所有的节点尽可能向左边靠拢。</p>
<p>实现数据结构CBTInserter有如下三种方法。</p>
<ul>
<li>构造函数CBTiNSERTER(TreeNode root)，用一棵完全二叉树的根节点初始化该数据结构。</li>
<li>函数insert(int v)在完全二叉树中添加一个值为v的节点，并返回被插入节点的父节点。</li>
<li>函数get_root()返回完全二叉树的根节点。</li>
</ul>
<p>分析：</p>
<p>按照广度优先搜索的思路，找出第一个缺少子节点的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CBTInserter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;TreeNode&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CBTInserter</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line"></span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.peek().left != <span class="keyword">null</span> &amp;&amp; queue.peek().right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        TreeNode parent = queue.peek();</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.left = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = node;</span><br><span class="line"></span><br><span class="line">            queue.poll();</span><br><span class="line">            queue.offer(parent.left);</span><br><span class="line">            queue.offer(parent.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parent.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">get_root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造函数本质上来说是按照广度优先搜索的顺序找出二叉树中所有既有左子节点又有右子节点的节点，因此**时间复杂度是O(n)<strong>。调用函数insert在完全二叉树中每添加一个节点最多只需要在队列中删除一个节点并添加两个节点。通常，队列的插入、删除操作的时间复杂度都是O(1)，因此函数</strong>insert的时间复杂度是O(1)<strong>。最后，</strong>get_root的时间复杂度是O(1)<strong>。需要一个队列来实现广度优先搜索算法保存缺少左子节点或右子节点的节点，</strong>空间复杂度是O(n)**。</p>
<h3 id="44-二叉树中每层的最大值"><a href="#44-二叉树中每层的最大值" class="headerlink" title="#44 二叉树中每层的最大值"></a>#44 二叉树中每层的最大值</h3><p>输入一棵二叉树，请找出二叉树中每层的最大值。</p>
<p>分析：</p>
<p>这个题目提到了二叉树的层。既然要找出二叉树中每层的最大值，就要逐层遍历二叉树，也就是说，按照广度优先的顺序遍历二叉树。这里介绍两种解法：</p>
<ol>
<li><p>用一个队列实现二叉树的广度优先搜索：</p>
<p>由于要找出二叉树中每层的最大值，因此在遍历时需要知道每层什么时候开始、什么时候结束。如果还是和前面一样只用一个队列来保存尚未遍历到的节点，那么有可能位于不同的两层的节点同时在队列之中。此时，每次从队列之中取出节点来遍历时就需要知道这个节点位于哪一层。解决办法之一是计数，<strong>用current记录当前层节点的数量，用next记录下一层节点的数量</strong>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">largestValues1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            current = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 取出当前层节点并更新计数变量</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            current--;</span><br><span class="line">            max = Math.max(max, node.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前层节点遍历完毕，更新变量值</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(max);</span><br><span class="line">                max = Integer.MIN_VALUE;</span><br><span class="line">                current = next;</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>用两个队列实现二叉树的广度优先搜索：</p>
<p>用两个队列分别存放不同层的节点。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">largestValues2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue1.offer(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue1.poll();</span><br><span class="line">        max = Math.max(max, node.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            result.add(max);</span><br><span class="line">            max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过比较上述两种思路的代码不难发现，是用两个队列的代码逻辑稍微简单一些。</p>
<p>每个节点需要入队一次，**时间复杂度为O(n)<strong>。队列中最多存储一层的全部节点，如果是满二叉树，则</strong>最坏空间复杂度为O(n)**。</p>
<h3 id="45-二叉树最低层最左边的值"><a href="#45-二叉树最低层最左边的值" class="headerlink" title="#45 二叉树最低层最左边的值"></a>#45 二叉树最低层最左边的值</h3><p>如何在一棵二叉树中找出它最低层最左边节点的值？假设二叉树中最少有一个节点。</p>
<p>分析：</p>
<p>利用广度优先搜索的思路，遍历所有节点。用一个变量bottomLeft来保存每一层最左边的节点的值。在遍历二叉树时，每当遇到新的一层时就将变量bottomLeft的值更新为该层第1个节点的值。当整颗二叉树都被遍历完之后，变量bottomLeft的值就是最后一层的第1个节点的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue1.offer(root);</span><br><span class="line">    <span class="keyword">int</span> bottomLeft = root.val;</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue1.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">                bottomLeft = queue1.peek().val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bottomLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="46-二叉树的右侧视图"><a href="#46-二叉树的右侧视图" class="headerlink" title="#46 二叉树的右侧视图"></a>#46 二叉树的右侧视图</h3><p>给定一棵二叉树，如果站在该二叉树的右侧，那么从上到下看到的节点构成二叉树的右侧试图。(每层最右边的节点)</p>
<p>分析：</p>
<p>广度优先搜索遍历二叉树，存储每层最后一个节点的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; view = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue1.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue1.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            view.add(node.val);</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树的深度优先搜索"><a href="#二叉树的深度优先搜索" class="headerlink" title="#二叉树的深度优先搜索"></a>#二叉树的深度优先搜索</h3><p>二叉树的深度优先搜索又可以细分为中序遍历、前序遍历和后序遍历。</p>
<p><img src="image-20211112175208698.png" alt="image-20211112175208698"></p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>遍历顺序：4，2，5，1，6，3，7</p>
<p>中序遍历的递归实现很直观：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    dfs(root, nodes);</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; nodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dfs(root.left, nodes);</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        dfs(root.right, nodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归有固有的局限性。如果二叉树的深度(从根节点到叶节点的最长路径的长度)太大，那么递归的代码可能会导致调用栈溢出的问题。<strong>可以用栈把递归的代码改写成迭代的代码。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        nodes.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量cur表示当前遍历的节点。如果该节点有左子节点，按照中序遍历的顺序，应该先遍历它的左子树。于是顺着指向左子节点的指针一直向下移动，并将沿途遇到的每个节点都添加到栈stack之中。第二个while循环结束之后，最左子节点(顺着指向左子节点的指针到达的最远的节点)位于栈顶，将它从栈顶出栈并遍历。按照中序遍历的顺序，在遍历一个节点之后再遍历它的右子树，因此把变量cur指向它的右子节点，开始下一轮的遍历，直到所有的节点都遍历完为止。</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>遍历顺序: 1, 2, 4, 5, 3, 6, 7</p>
<p>递归实现前序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preorderTraversal1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    dfs(root, nodes);</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; nodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        dfs(root.left, nodes);</span><br><span class="line">        dfs(root.right, nodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>栈实现前序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.add(cur.val);</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>遍历顺序：4，5，2，6，7，3，1</p>
<p>递归实现后序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postorderTraversal1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    dfs(root, nodes);</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; nodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dfs(root.left, nodes);</span><br><span class="line">        dfs(root.right, nodes);</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>栈实现后序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前遍历的节点</span></span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="comment">// 上一个遍历的节点</span></span><br><span class="line">    TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span> &amp;&amp; cur.right != prev) &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            result.add(cur.val);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，变量prev就是遍历过的前一个节点，它初始化为null。在准备便利下一个节点时，就把它指向当前遍历的节点。</p>
<p>变量cur表示当前到达的节点。如果该节点有右子节点并且右子节点不是前一个遍历的节点，则表示它有右子树并且右子树还没有遍历过。按照后序遍历的顺序，应该先遍历它的右子树，因此把变量指向它的右子节点。</p>
<h4 id="三种遍历方法小结"><a href="#三种遍历方法小结" class="headerlink" title="三种遍历方法小结"></a>三种遍历方法小结</h4><p>不管哪种深度优先算法，也不管是递归代码还是迭代代码，如果二叉树有n个节点，那么它们的**时间复杂度都是O(n)<strong>。如果二叉树的深度为h，那么它们的</strong>空间复杂度都是O(h)**。在二叉树中，二叉树的深度h的最小值是log2(n+1)。</p>
<h3 id="47-二叉树剪枝"><a href="#47-二叉树剪枝" class="headerlink" title="#47 二叉树剪枝"></a>#47 二叉树剪枝</h3><p>一棵二叉树的所有节点的值要么是0要么是1，请剪除该二叉树中所有节点的值全部都是0的子树。</p>
<p>例如：</p>
<p><img src="image-20211113222017322.png" alt="image-20211113222017322"></p>
<p>分析：</p>
<p>首先总结什么样的节点可以被删除。首先，这个节点的值应该是0。其次，如果它有子树，那么它的子树的所有节点的值都为0。也就是说，如果一个节点可以被删除，那么它的子树的所有节点都可以被删除。</p>
<p>由此发现，后序遍历最适合用来解决这个问题。如果用后序遍历的顺序遍历到某个节点，那么它的左右子树的节点一定已经遍历过了。每遍历到一个节点，就要确定它是否有左右子树，如果左右子树都是空的，并且节点的值是0，那么也就可以删除这个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root.left = pruneTree(root.left);</span><br><span class="line">    root.right = pruneTree(root.right);</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="48-序列化和反序列化二叉树"><a href="#48-序列化和反序列化二叉树" class="headerlink" title="#48 序列化和反序列化二叉树"></a>#48 序列化和反序列化二叉树</h3><p>请设计一个算法将二叉树序列化成一个字符串，并能将该字符串反序列化出原来二叉树的算法。</p>
<p>分析：</p>
<p>以前序遍历的顺序遍历二叉树最适合序列化。如果采用前序遍历的顺序，那么二叉树的根节点最先序列化到字符串中，然后是左子树，最后是右子树。这样做的好处是在反序列化时最方便，从字符串中读出的第1个数值一定是根节点的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String leftStr = serialize(root.left);</span><br><span class="line">    String rightStr = serialize(root.right);</span><br><span class="line">    <span class="keyword">return</span> root.val + <span class="string">&quot;,&quot;</span>+ leftStr + <span class="string">&quot;,&quot;</span> + rightStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    String[] nodeStrs = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span>[] i = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> dfs(nodeStrs, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">dfs</span><span class="params">(String[] strs, <span class="keyword">int</span>[] i)</span> </span>&#123;</span><br><span class="line">    String str = strs[i[<span class="number">0</span>]];</span><br><span class="line">    i[<span class="number">0</span>]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str.equals(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(Integer.valueOf(str));</span><br><span class="line">    node.left = dfs(strs, i);</span><br><span class="line">    node.right = dfs(strs, i);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中定义了一个长度为1的整数数组i。这是因为递归函数dfs每反序列化一个节点时下标就会增加1，并且函数的调用者需要直到下标增加了。</p>
<h3 id="49-从根节点到叶节点的路径数字之和"><a href="#49-从根节点到叶节点的路径数字之和" class="headerlink" title="#49 从根节点到叶节点的路径数字之和"></a>#49 从根节点到叶节点的路径数字之和</h3><p>在一棵二叉树中，所有的节点都在0~9的范围之内，从根节点到叶节点的路径表示一个数字。求二叉树中所有路径表示的数字之和。</p>
<p>例如：</p>
<p><img src="image-20211114220905216.png" alt="image-20211114220905216"></p>
<p>此二叉树中有3条从根节点到叶节点的路径，它们分别表示数字395, 391, 302。这三个数字之和是1088。</p>
<p>分析：</p>
<p>首先考虑如何计算路径表示的数字。顺着指向子节点的指针路径向下遍历二叉树，每到达一个节点，相当于在路径表示的数字末尾添加一位数字。例如，在最开始到达根节点时，它表示数字3。然后到达节点9，此时路径表示数字39(3*10+9)。然后向下到达节点5，此时路径表示数字395(39*10+5)。<strong>这是典型的二叉树前序遍历。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断非叶子节点并返回0</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path = path * <span class="number">10</span> + root.val;</span><br><span class="line">    <span class="comment">// 只有是叶子节点时才会返回</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(root.left, path) + dfs(root.right, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="50-向下的路径节点之和"><a href="#50-向下的路径节点之和" class="headerlink" title="#50 向下的路径节点之和"></a>#50 向下的路径节点之和</h3><p>给定一棵二叉树和一个值sum，求二叉树中节点值之和等于sum的路径的数目。路径的定义为二叉树中顺着指向叶子节点的指针向下移动所经过的结点，但不一定从根节点开始，也不一定到叶节点结束。</p>
<p>例如：下图所示的二叉树中有两条路径的节点值之和等于8，其中第1条路径从节点5开始经过节点2到达节点1。第2条路径从节点2开始到节点6。</p>
<p><img src="image-20211118002034535.png" alt="image-20211118002034535"></p>
<p>分析：</p>
<p>如果在路径上移动时把所有累加的节点值之和都保存下来，就容易知道是否存在从任意节点出发的值为给定sum的路径。</p>
<p>当遍历到一个节点时，先累加从根节点开始的路径上的节点值之和，再计算到它的左右子节点的路径的节点值之和。这是典型的前序遍历顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.putIfAbsent(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(root, sum, map, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, Map&lt;Integer, Integer&gt; map, <span class="keyword">int</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path += root.val;</span><br><span class="line">    <span class="keyword">int</span> count = map.getOrDefault(path - sum, <span class="number">0</span>);</span><br><span class="line">    map.put(path, map.getOrDefault(path, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    count += dfs(root.left, sum, map, path);</span><br><span class="line">    count += dfs(root.right, sum, map, path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数结束之前要将当前节点从路径中删除</span></span><br><span class="line">    map.put(path, map.get(path) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="51-节点值之和最大的路径"><a href="#51-节点值之和最大的路径" class="headerlink" title="#51 节点值之和最大的路径"></a>#51 节点值之和最大的路径</h3><p>在二叉树中将路径定义为顺着节点之间的连接从任意一个节点开始到达任意一个节点所经过的所有节点。路径中至少包含一个节点，不一定经过二叉树的根节点，也不一定经过叶节点。给定非空的一棵二叉树，请求出二叉树所有路径上节点值之和的最大值。</p>
<p>例如，下图所示的二叉树中，从节点15开始经过节点20到达节点7的路径的节点值之和为42，是节点值之和最大的路径。</p>
<p><img src="image-20211118003721763.png" alt="image-20211118003721763"></p>
<p>分析：当路径到达某个节点时，该路径既可以前往它的左子树，也可以前往它的右子树。但如果路径同时经过它的左右子树，那么就不能经过它的父节点。所以需要先求出左右子树中路径节点值之和的最大值(左右子树中的路径不经过当前节点)，再求出经过根节点的路径节点值之和的最大值，最后对三者进行比较得到最大值。<strong>这是典型的后序遍历。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] maxSum = &#123;Integer.MIN_VALUE&#125;;</span><br><span class="line">    dfs(root, maxSum);</span><br><span class="line">    <span class="keyword">return</span> maxSum[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] maxSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] maxSumLeft = &#123;Integer.MIN_VALUE&#125;;</span><br><span class="line">    <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, dfs(root.left, maxSumLeft));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] maxSumRight = &#123;Integer.MIN_VALUE&#125;;</span><br><span class="line">    <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, dfs(root.right, maxSumRight));</span><br><span class="line"></span><br><span class="line">    maxSum[<span class="number">0</span>] = Math.max(maxSumLeft[<span class="number">0</span>], maxSumRight[<span class="number">0</span>]);</span><br><span class="line">    maxSum[<span class="number">0</span>] = Math.max(maxSum[<span class="number">0</span>], root.val + left + right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要包含当前节点并经过其父节点，就不能同时经过当前节点的左右子树</span></span><br><span class="line">    <span class="keyword">return</span> root.val + Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="#二叉搜索树"></a>#二叉搜索树</h3><p>二叉搜索树是一类特殊的二叉树，它的左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点。例如：</p>
<p><img src="image-20211119115312448.png" alt="image-20211119115312448"></p>
<p>二叉树的3种不同的深度优先搜索算法都适用于二叉搜索树，但中序遍历是解决二叉搜索树相关面试题最常用的思路，因为中序遍历按照节点值递增的顺序遍历二叉搜索树的每个节点。</p>
<p>在普通的二叉搜索树中根据节点的值查找对应节点需要遍历这棵二叉树，因此需要O(n)的时间。但如果是二叉搜索树就可以根据其特性进行优化。类似二分查找，如果二叉搜索树的高度为h，那么在二叉搜索树中根据节点值查找对应节点的时间复杂度是O(h)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; val) &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.val &lt; val) &#123;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="52-展平二叉搜索树"><a href="#52-展平二叉搜索树" class="headerlink" title="#52 展平二叉搜索树"></a>#52 展平二叉搜索树</h3><p>给定一棵二叉搜索树，请调整节点的指针使每个节点都没有左子节点。调整后的树看起来像一个链表，但仍然是二叉搜索树。</p>
<p>分析：</p>
<p>调整后的二叉搜索树从根节点开始顺着指向右子节点的指针向下经过的结点的值将是递增排序的。因此需要按照节点的值递增的顺序遍历二叉搜索树中的每个节点，并将节点用指向右子节点的指针连接起来。这就很容易联想到二叉树的<strong>中序遍历</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 调整后二叉树的根节点</span></span><br><span class="line">    TreeNode first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev.right = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            first = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur.left = <span class="keyword">null</span>;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="53-二叉搜索树的下一个节点"><a href="#53-二叉搜索树的下一个节点" class="headerlink" title="#53 二叉搜索树的下一个节点"></a>#53 二叉搜索树的下一个节点</h3><p>给定一棵二叉搜索树和它的一个节点p，请找出按中序遍历的顺序该节点p的下一个节点。假设二叉搜索树中节点的值都是唯一的。</p>
<p>分析：</p>
<p>从不同的角度看待二叉搜索树中的节点的下一个节点，有不同的解决方法。</p>
<ol>
<li><p>时间复杂度O(n)的解法：</p>
<p>最直观的思路就是采用二叉树的中序遍历。可以用一个布尔变量found来记录已经遍历到节点p。该变量初始化为false，遍历到节点p就将它设为true。在这个变量变成true之后遍历到的第一个节点就是要找的节点。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">inorderSuccessor1</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == cur) &#123;</span><br><span class="line">            found = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>时间复杂度为O(h)的解法：</p>
<p>如果当前节点小于或等于p，那么p的下一个节点应该在它的右子树上。如果当前节点大于p，那p的下一个节点可能是当前节点，也可能在当前节点的左子树上。我们重复这样的比较，直至找到最后一个大于p的节点，就是p的下一个节点。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">inorderSuccessor2</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; p.val) &#123;</span><br><span class="line">            result = cur;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="54-所有大于或等于节点的值之和"><a href="#54-所有大于或等于节点的值之和" class="headerlink" title="#54 所有大于或等于节点的值之和"></a>#54 所有大于或等于节点的值之和</h3><p>给定一棵二叉搜索树，请将它的每个节点的值替换成树中大于或等于该节点的所有节点值之和。假设二叉搜索树中节点的值唯一。</p>
<p>例如：</p>
<p><img src="image-20211120214235348.png" alt="image-20211120214235348"></p>
<p>分析：</p>
<p>此题与节点值的大小顺序有关。在二叉搜索树的常用遍历算法中，只有中序遍历是按照节点值递增的顺序遍历所有节点的。当遍历到某个节点时，比该节点的值小的节点都已经遍历过，因此也就知道了所有比该节点的值小的所有节点的值之和sum。因此，可以先遍历一边二叉树求出所有节点的值之和total，再用total-sum即可。此思路需要遍历二叉搜索树两次，第一次不管用什么算法只要遍历所有节点即可，第二次则必须采用中序遍历。</p>
<p><strong>是否可以只遍历二叉搜索树一次？</strong>答案是肯定的。只需要改变中序遍历的顺序，先遍历右子树再遍历根节点，最后遍历左子树，这昂遍历的顺序就颠倒过来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        sum += cur.val;</span><br><span class="line">        cur.val = sum;</span><br><span class="line">        cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="55-二叉搜索树迭代器"><a href="#55-二叉搜索树迭代器" class="headerlink" title="#55 二叉搜索树迭代器"></a>#55 二叉搜索树迭代器</h3><p>请实现二叉搜索树的迭代器BSTIterator，它主要有如下三个函数。</p>
<ul>
<li>构造函数：输入二叉搜索树的根节点初始化该迭代器</li>
<li>函数next：返回二叉搜索树中下一个最小的节点的值</li>
<li>函数hasNext：返回二叉搜索树是否还有下一个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    TreeNode cur;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cur = root;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur != <span class="keyword">null</span> || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> val = cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="56-二叉搜索树中两个节点的值之和"><a href="#56-二叉搜索树中两个节点的值之和" class="headerlink" title="#56 二叉搜索树中两个节点的值之和"></a>#56 二叉搜索树中两个节点的值之和</h3><p>给定一棵二叉搜索树和一个值k，请判断该二叉搜索树中是否存在值之和等于k的两个节点。假设二叉搜索树中节点的值均唯一。</p>
<p>分析：</p>
<p>解决这个问题自然需要遍历二叉树中的所有节点，因此这是一个关于二叉树遍历的问题。这里给出两种解法</p>
<ol>
<li><p>利用哈希表，空间复杂度为O(n)的解法。</p>
<p>解决这个问题最直观的思路是利用哈希表保存节点的值。可以采用任意遍历算法遍历输入的二叉搜索树，每遍历到一个节点(节点值记为v)，就在哈希表中查看是否存在值为k-v的节点。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findTarget1</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (set.contains(k - cur.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>应用双指针，空间复杂度为O(h)的解法。</p>
<p>面试题6介绍了如何利用双指针判断在排序数组中是否包含两个和为k的数字。实际上，在某种程度上可以把二叉搜索树看成一个排序的数组。采用55题BSTIterator，则可以每次按照从小到大的顺序从二叉搜索树中取出一个节点。<strong>此时BSTIterator就相当于第一个指针</strong>。受54题启发，我们可以实现从大到小遍历二叉搜索树。因此可以用类似的思路实现<strong>一个颠倒顺序的二叉搜索树的迭代器，相当于第二个指针</strong>。</p>
</li>
</ol>
<p>迭代器如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIteratorReversed</span> </span>&#123;</span><br><span class="line">    TreeNode cur;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIteratorReversed</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cur = root;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur != <span class="keyword">null</span> || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> val = cur.val;</span><br><span class="line">        cur = cur.left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>基于双指针的思路，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findTarget2</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BSTIterator iterNext = <span class="keyword">new</span> BSTIterator(root);</span><br><span class="line">    BSTIteratorReversed iterPrev = <span class="keyword">new</span> BSTIteratorReversed(root);</span><br><span class="line">    <span class="keyword">int</span> next = iterNext.next();</span><br><span class="line">    <span class="keyword">int</span> prev = iterPrev.prev();</span><br><span class="line">    <span class="keyword">while</span> (next != prev) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next + prev == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next + prev &lt; k) &#123;</span><br><span class="line">            next = iterNext.next();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = iterPrev.prev();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多数情况下，二叉树的深度远小于二叉树的节点数，因此第2种算法的总体空间效率要优于第1种算法。</p>
<h3 id="TreeSet和TreeMap的应用"><a href="#TreeSet和TreeMap的应用" class="headerlink" title="#TreeSet和TreeMap的应用"></a>#TreeSet和TreeMap的应用</h3><p>二叉搜索树是一种很有用的数据结构。实现一棵平衡的二叉搜索树对于面试来说不是一件容易的事情。Java根据红黑树这种平衡的二叉树实现TreeSet和TreeMap两种数据结构。</p>
<h4 id="TreeSet的常用函数"><a href="#TreeSet的常用函数" class="headerlink" title="TreeSet的常用函数"></a>TreeSet的常用函数</h4><table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>ceiling</td>
<td>返回键大于或等于给定值的最小键: 如果没有则返回null</td>
</tr>
<tr>
<td>2</td>
<td>floor</td>
<td>返回键小于或等于给定值的最大键: 如果没有则返回null</td>
</tr>
<tr>
<td>3</td>
<td>higher</td>
<td>返回键大于等于给定值的最小键: 如果没有则返回null</td>
</tr>
<tr>
<td>4</td>
<td>lower</td>
<td>返回键小于给定值的最大键: 如果没有则返回null</td>
</tr>
</tbody></table>
<h4 id="TreeMap的常用函数"><a href="#TreeMap的常用函数" class="headerlink" title="TreeMap的常用函数"></a>TreeMap的常用函数</h4><table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>ceilingEntry/ceilingKey</td>
<td>返回键大于或等于给定值的最小映射/键: 如果没有则返回null</td>
</tr>
<tr>
<td>2</td>
<td>floorEntry/floorKey</td>
<td>返回键小于或等于给定值的最大映射/键: 如果没有则返回null</td>
</tr>
<tr>
<td>3</td>
<td>higherEntry/higherKey</td>
<td>返回键大于给定值的最小映射/键: 如果没有则返回null</td>
</tr>
<tr>
<td>4</td>
<td>lowerEntry/lowerKey</td>
<td>返回键小于给定值的最大映射/键: 如果没有则返回null</td>
</tr>
</tbody></table>
<p>由于TreeSet或TreeMap能够保证其内部的二叉搜索树是平衡的，因此它们的查找、添加和删除操作的时间复杂度都是O(logn)，综合来看他们比动态排序数组更加高效。</p>
<h3 id="57-值和下标之差都在给定的范围内"><a href="#57-值和下标之差都在给定的范围内" class="headerlink" title="#57 值和下标之差都在给定的范围内"></a>#57 值和下标之差都在给定的范围内</h3><p>给定一个整数数组nums和两个正数k、t，请判断是否存在两个不同的下标i和j满足i和j之差的绝对值不大于给定的k，并且两个数值nums[i]和nums[j]的差的绝对值不大于给定t。</p>
<p>分析：</p>
<p>首先考虑最直观的解法。可以逐一扫描数组中的每个数字，对于每个数字nums[i]，需要逐一检查在他前面的k个数字是否存在从nums[i]-t到nums[i]+t范围内的数字。如果存在则返回true。这种思路很容易用两个嵌套的循环实现。由于数组中的每个数字都要和k个数字进行比较，如果数组的长度为n，那么这种解法的时间复杂度是O(nk)。</p>
<p>下面尝试优化时间复杂度。</p>
<ol>
<li><p>时间复杂度为O(nlogk)的解法。</p>
<p>逐一扫描数组中的每个数字。对于每个数字nums[i]，应该先从它前面的k个数字中找出小于或等于nums[i]的最大的数字，如果这个数字与nums[i]的差的绝对值不大于t，那么就找到了一组符合条件的两个数字。否则，就再找出大于或等于nums[i]的最小的数字进行比较。</p>
<p>需要从一个大小为k的数据容器中找出小于或等于某个数字的最大值及大于或等于某个数字的最小值，这正是TreeSet或TreeMap适用的场景。因为这个容器只需要保存数字，所以可以用TreeSet来保存每个数字nums[i]前面的k个数字。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containNearbyAlmostDuplicate1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        Long lower = set.floor((<span class="keyword">long</span>) nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (lower != <span class="keyword">null</span> &amp;&amp; lower &gt;= (<span class="keyword">long</span>)nums[i] - t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long upper = set.ceiling((<span class="keyword">long</span>) nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (upper != <span class="keyword">null</span> &amp;&amp; upper &lt;= (<span class="keyword">long</span>)nums[i] + t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set.add((<span class="keyword">long</span>) nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">            set.remove((<span class="keyword">long</span>)nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，变量set是一个TreeSet，它的大小是k，因此空间复杂度是O(k)。对它做查找、添加和删除操作的时间复杂度都是O(logk)，因此对一个长度为n的数组而言，它的时间复杂度是O(nlogk)。</p>
<ol start="2">
<li><p>时间复杂度为O(n)的解法。</p>
<p>可以将数字放入若干大小为t+1的桶中。例如将从0到t的数字放入编号为0的桶中，从t+1到2t+1的数字放入编号为1的桶中。这样做的好处是如果两个数字被放入同一个桶中，那么他们的差的绝对值一定小于或等于t。如果桶中之前没有数字，则再判断编号为id-1和id+1这两个相邻的桶中是否存在与num的差的绝对值小于或等于t的数字。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containNearbyAlmostDuplicate2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; buckets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> bucketSize = t + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i];</span><br><span class="line">        <span class="keyword">int</span> id = getBucketID(num, bucketSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buckets.containsKey(id)</span><br><span class="line">            || (buckets.containsKey(id-<span class="number">1</span>) &amp;&amp; buckets.get(id-<span class="number">1</span>) + t &gt;= num)</span><br><span class="line">            || (buckets.containsKey(id+<span class="number">1</span>) &amp;&amp; buckets.get(id+<span class="number">1</span>) - t &lt;= num)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buckets.put(id, num);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">            buckets.remove(getBucketID(nums[i-k], bucketSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBucketID</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &gt;= <span class="number">0</span> ? num / bucketSize : (num + <span class="number">1</span>) / bucketSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希表buckets的大小是k，因此，空间复杂度是O(k)。哈希表中的查找/添加和删除操作的时间复杂度都是O(1)，因此，对于一个长度为n的数组而言，它的时间复杂度是O(n)。</p>
<h3 id="58-日程表"><a href="#58-日程表" class="headerlink" title="#58 日程表"></a>#58 日程表</h3><p>请实现一个类型MyCalendar用来记录自己的日程安排，该类型用方法book(int start, int end)在日程表中添加一个时间区域为[start, end)的事项(这是一个半开半闭区间)。如果[start, end)中之前没有安排其他事项，则成功添加该始想并返回true；否则，不能添加该事项并返回false。</p>
<p>分析：</p>
<p>如果添加的事项占用的时间区间是[m, n), 就需要找出开始时间小于m的所有事项中开始最晚的一个，以及开始时间大于m的所有事项中开始最早的一个。如果待添加的事项和这两个事项都没有重叠，那么该事项可以添加在日程表中。由于每个时间区间都有开始时间和结束时间，也就是说树的每个节点需要保存两个数字。一个简单的办法是用TreeMap。可以把时间区间的开始作为映射的键，把结束时间作为映射的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;Integer, Integer&gt; events;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        events = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; event = events.floorEntry(start);</span><br><span class="line">        <span class="keyword">if</span> (event != <span class="keyword">null</span> &amp;&amp; event.getValue() &gt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        event = events.ceilingEntry(start);</span><br><span class="line">        <span class="keyword">if</span> (event != <span class="keyword">null</span> &amp;&amp; event.getKey() &lt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        events.put(start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的基础知识"><a href="#堆的基础知识" class="headerlink" title="#堆的基础知识"></a>#堆的基础知识</h3><p>堆是一种特殊的树形数据结构。根据根结点的值与子节点的值的大小关系，堆又分为最大堆和最小堆。在最大堆中，每个节点的值总是大于或等于其任意子节点的值，因此最大堆的根节点就是整个堆的最大值。在最小堆中，每个节点的值总是小于或等于其任意子节点的值，因此最小堆的根节点就是整个堆的最小值。</p>
<p>堆通常用完全二叉树实现。完全二叉树又可以用数组实现，因此堆也可以用数组实现。</p>
<p>如果数组中的一个元素的下标为i，那么它在堆中对应节点的父节点在数组中的下标为(i-1)/2，而它的左右子节点在数组中的下标分别为2i+1和2i+2。</p>
<p>为了在最大堆中添加新的节点，应该先从上到下、从左到右找出第1个空缺的位置，并将新节点添加到该空缺的位置。如果新结点的值比它的父节点的值大，那么交换它和它的父节点。重复这个过程，直到新节点的值小于或等于它的父节点，或者它已经到达堆顶部的位置。在最小堆中添加新节点的过程与此类似。</p>
<p>通常只删除位于堆顶部的元素。如果删除最大堆的顶部节点，则将堆最低层最右边的节点移到堆的顶部。如果此时它的左子节点或右子节点的值大于它，那么它和左右子节点中值较大的节点交换。如果交换之后节点的值仍然小于它的子节点的值，则再次交换，直到该节点的值大于或等于它的左右子节点的值，或者到达最低层为止。删除最小堆的顶部节点的过程与此类似。</p>
<p>Java提供了类型PriorityQueue实现数据结构堆。PriorityQueue在默认情况下是一个最小堆，如果使用最大堆调用构造函数就需要传入Comparator改变比较排序的规则。PriorityQueue实现了接口Queue，它常用的函数如下：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>抛异常</th>
<th>不抛异常</th>
</tr>
</thead>
<tbody><tr>
<td>插入元素</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>删除堆顶元素</td>
<td>remove</td>
<td>poll</td>
</tr>
<tr>
<td>返回堆顶元素</td>
<td>element</td>
<td>peek</td>
</tr>
</tbody></table>
<h3 id="堆的应用"><a href="#堆的应用" class="headerlink" title="#堆的应用"></a>#堆的应用</h3><p>如果需要求出一个动态数据集合中的最大值或最小值，那么可以考虑使用堆来解决问题。</p>
<p>堆经常用来求取一个数据集合中值最大或最小的k个元素。通常，最小堆用来求取数据集合中k个值最大的元素，最大堆用来求取数据集合中k个值最小的元素。</p>
<h3 id="59-数据流的第k大数字"><a href="#59-数据流的第k大数字" class="headerlink" title="#59 数据流的第k大数字"></a>#59 数据流的第k大数字</h3><p>请设计一个类型KthLargest，它每次从一个数据流中读取一个数字，并得出数据流已经读取的数字中第k(k&gt;=1)大的数字。该类型的构造函数有两个参数: 一个是整数k，另一个是包含数据流中最开始数字的整数数组nums(假设数组nums)的长度大于k。该类型还有一个函数add，用来添加数据流中的新数字并返回数据流中已经读取的数字的第k大数字。</p>
<p>分析：</p>
<p>如果能够找出k个最大的数字，那么第k大的数字就是这k个最大数字中最小的一个。由于每次都需要找出k个数字中的最小值，因此可以把这k个数字保存到最小堆中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = k;</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() &lt; size) &#123;</span><br><span class="line">            minHeap.offer(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; minHeap.peek()) &#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">            minHeap.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="60-出现频率最高的k个数字"><a href="#60-出现频率最高的k个数字" class="headerlink" title="#60 出现频率最高的k个数字"></a>#60 出现频率最高的k个数字</h3><p>请找出数组中出现频率最高的k个数字。</p>
<p>例如：当k等于2时，输入数组[1,2,2,1,3,1]，由于数字1出现了3次，数字2出现了2次，数字3出现了1次，因此出现频率最高的2个数字时1和2。</p>
<p>分析：</p>
<p>首先想到解决这个题目要用到哈希表。哈希表可以用来统计数组中数字出现的频率，哈希表的键时数组中出现的数字，值是数字出现的频率。</p>
<p>接下来找出出现频率最高的k个数字。可以用一个最小堆存储频率最高的k个数字，堆中的每个元素是数组中的数字及其在数组中出现的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; numToCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        numToCount.put(num, numToCount.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (e1, e2) -&gt; e1.getValue() - e2.getValue()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : numToCount.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() &lt; k) &#123;</span><br><span class="line">            minHeap.offer(entry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() &gt; minHeap.peek().getValue()) &#123;</span><br><span class="line">                minHeap.poll();</span><br><span class="line">                minHeap.offer(entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : minHeap) &#123;</span><br><span class="line">        result.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上述代码需要一个大小为O(n)的哈希表和一个大小为O(k)的最小堆，因此**总空间复杂度为O(n)<strong>。在大小为k的堆中进行添加或删除操作的时间复杂度是O(logk)，因此</strong>总时间复杂度是O(nlogk)**。</p>
<h3 id="61-和最小的k个树对"><a href="#61-和最小的k个树对" class="headerlink" title="#61 和最小的k个树对"></a>#61 和最小的k个树对</h3><p>给定两个递增排序的整数数组，从两个数组中各取一个数字u和v组成一个数对(u,v)，请找出最小的k个数对。</p>
<p>例如两个数组[1,5,13,21]和[2,4,9,15]，和最小的3个数对为(1,2)、(1,4)和(2,5)。</p>
<p>分析：</p>
<p>假设第一个数组nums1的长度为m，第二个数组nums2的长度为n，那么从两个数组中各取一个数字能组成mxn个数对。</p>
<ol>
<li><p>使用最大堆</p>
<p>用最大堆存储这k个和最小的数对。</p>
<p>因为输入的数组是递增排序的，因此，不管数组nums1有多长，最多只需要考虑前k个数字。同理，不管输入的数组nums2有多长，最多也只需要考虑前k个数字。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs1(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (p1, p2) -&gt; p2[<span class="number">0</span>] + p2[<span class="number">1</span>] - p1[<span class="number">0</span>] - p1[<span class="number">1</span>]</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(k, nums1.length); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Math.min(k, nums2.length); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxHeap.size() &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] root = maxHeap.peek();</span><br><span class="line">                <span class="keyword">if</span> (root[<span class="number">0</span>] + root[<span class="number">1</span>] &gt; nums1[i] + nums2[j]) &#123;</span><br><span class="line">                    maxHeap.poll();</span><br><span class="line">                    maxHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] vals = maxHeap.poll();</span><br><span class="line">        result.add(Arrays.asList(vals[<span class="number">0</span>], vals[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(k^2logk)。</p>
<ol start="2">
<li><p>使用最小堆</p>
<p>我们先用nums1的前k个数字和nums2的第1个数字组成数对，存入最小堆中。如果和最小的数对的两个数字在两个数组中的下标分别为i1和i2，将该数对添加到结果中并将其从最小堆中删除，再将燥起两个数组中分下标分别为i1和i2+1的两个新数字作为新的候选数对添加到最小堆中。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs2(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (p1, p2) -&gt; nums1[p1[<span class="number">0</span>]] + nums2[p1[<span class="number">1</span>]] - nums1[p2[<span class="number">0</span>]] - nums2[p2[<span class="number">1</span>]]</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (nums2.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(k, nums1.length); i++) &#123;</span><br><span class="line">            minHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 只需要k次操作就可以得出最小的k组数对</span></span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !minHeap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ids = minHeap.poll();</span><br><span class="line">        result.add(Arrays.asList(nums1[ids[<span class="number">0</span>]], nums2[ids[<span class="number">1</span>]]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ids[<span class="number">1</span>] &lt; nums2.length - <span class="number">1</span>) &#123;</span><br><span class="line">            minHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;ids[<span class="number">0</span>], ids[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(klogk)。</p>
<h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><h3 id="前缀树的基础知识"><a href="#前缀树的基础知识" class="headerlink" title="#前缀树的基础知识"></a>#前缀树的基础知识</h3><p>前缀树，又称为字典树，它用一个树状的数据结构存储一个字典中的所有单词。如果一个字典中包含单词”can”、”cat”、”come”、”do”、”i”、”in”和”inn”，那么保存该字典所有单词的前缀树如图所示：</p>
<p><img src="image-20211124150911045.png" alt="image-20211124150911045"></p>
<p>前缀树是一棵多叉树，一个节点可能有多个子节点。本章中如果没有特殊说明，那么前缀树中都只包含英文小写字母。</p>
<h3 id="62-实现前缀树"><a href="#62-实现前缀树" class="headerlink" title="#62 实现前缀树"></a>#62 实现前缀树</h3><p>请设计一棵前缀树Tire，它有如下操作。</p>
<p>函数insert，在前缀树中添加一个字符串</p>
<p>函数search，查找字符串。如果前缀树中包含该字符串，则返回true，否则返回false。</p>
<p>函数startWith，查找字符串前缀。如果前缀树中包含以该前缀开头的字符串，则返回true，否则返回false。</p>
<p>分析：</p>
<p>如果只考虑英文小写字母，那么字符可能是从’a’到’z’的任意一个，因此前缀树中的节点可能有26个子节点。可以将26个子节点放到一个数组中，数组中的第1个元素是对应字母’a’的子节点，第2个元素是对应字母’b’的子节点，其余的以此类推。</p>
<p>节点中还需要一个布尔类型的字段表示到达该节点的路径对应的字符串是否为字典中一个完整的单词。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        TrieNode children[];</span><br><span class="line">        <span class="keyword">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node.isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="63-替换单词"><a href="#63-替换单词" class="headerlink" title="#63 替换单词"></a>#63 替换单词</h3><p>英语中有一个概念叫词根。在词根后面加上若干字符就能拼出更长的单词。例如”an”是一个词根，在它后面加上”other”就能得到另一个单词”another”。现在给定一个由词根组成的字典和一个英语句子，如果句子中的单词在字典中有它的词根，则用它的词根替换该单词；如果单词没有词根，则保留该单词。请输出替换后的句子。</p>
<p>例如：如果词根字典包含[“cat”, “bat”, “rat”]，英语句子为”the catle was ratled by the battery”，则替换之后的句子为”the cat was rat by the bat”.</p>
<p>分析：</p>
<p>这个题目中的词根其实就是前缀，因此很容易想到用前缀树来解决。用前缀树解决问题通常分为两步，第1步是创建前缀树，第2步是在前缀树中查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Trie.<span class="function">TrieNode <span class="title">buildTrie</span><span class="params">(List&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">        Trie.TrieNode root = <span class="keyword">new</span> Trie.TrieNode();</span><br><span class="line">        <span class="keyword">for</span> (String word : dict) &#123;</span><br><span class="line">            Trie.TrieNode node = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Trie.TrieNode();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">findPrefix</span><span class="params">(Trie.TrieNode root, String word)</span> </span>&#123;</span><br><span class="line">    Trie.TrieNode node = root;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.isWord || node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        builder.append(ch);</span><br><span class="line">        node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有最后node.isWord == true，才说明满足前缀</span></span><br><span class="line">    <span class="keyword">return</span> node.isWord ? builder.toString() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> </span>&#123;</span><br><span class="line">    Trie.TrieNode root = buildTrie(dict);</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    String[] words = sentence.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        String prefix = findPrefix(root, words[i]);</span><br><span class="line">        <span class="keyword">if</span> (!prefix.isEmpty()) &#123;</span><br><span class="line">            words[i] = prefix;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, words);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="64-神奇的字典"><a href="#64-神奇的字典" class="headerlink" title="#64 神奇的字典"></a>#64 神奇的字典</h3><p>请实现有如下两个操作的神奇字典。</p>
<ul>
<li>函数buildDict，输入单词数组用来创建一个字典</li>
<li>函数search，输入一个单词，判断能否修改该单词中的一个字符，使修改之后的单词使字典中的一个单词。</li>
</ul>
<p>例如：</p>
<p>输入[“happy”, “new”, “year”]创建神奇字典。输入单词”now”进行查找操作，返回true。</p>
<p>分析：</p>
<p>可以根据深度优先的顺序搜索前缀树的每条路径。如果到达的节点与字符串中的字符不匹配，则表示此时修改了字符串中的一个字符以匹配前缀树中的路径。如果到达对应字符串最后一个字符对应的节点时该节点的isWord字段的值为true，而且此时正好修改了字符串中的一个字符，那么就找到了修改字符串中一个字符对应的路径，符合题目的条件，可以返回true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> TrieNode[] children;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MagicDictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(String[] dict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : dict) &#123;</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, word, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 当前查找的字符串中字符的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> edit 字符串中当前已经修改的字符的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TrieNode root, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> edit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.isWord &amp;&amp; i == word.length() &amp;&amp; edit == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; word.length() &amp;&amp; edit &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span> &amp;&amp; !found; j++) &#123;</span><br><span class="line">                <span class="comment">// 判断当前字符是否与第i个字母相同，若不相同则更新edit+1</span></span><br><span class="line">                <span class="keyword">int</span> next = j == word.charAt(i) - <span class="string">&#x27;a&#x27;</span> ? edit : edit + <span class="number">1</span>;</span><br><span class="line">                found = dfs(root.children[j], word, i + <span class="number">1</span>, next);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> found;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="65-最短的单词编码"><a href="#65-最短的单词编码" class="headerlink" title="#65 最短的单词编码"></a>#65 最短的单词编码</h3><p>输入一个包含n个单词的数组，可以把它们编码成一个字符串和n个下标。</p>
<p>例如：单词数组[“time”, “me”, “bell”]可以编码成一个字符串”time#bell#”, 然后这些单词就可以通过下标[0,2,5]得到。给定一个单词数组，请问按照上述规则把这些单词编码之后得到的最短字符串的长度是多少？</p>
<p>分析：</p>
<p>如果一个单词A是另一个单词B的后缀，那么单词A在编码字符串中就不需要单独出现，这是因为单词A可以通过在单词B中偏移下标得到。</p>
<p>可以把字符串的后缀转换成前缀，存储在前缀树中。然后统计路径长度即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        TrieNode root = buildTrie(words);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] total = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dfs(root, <span class="number">1</span>, total);</span><br><span class="line">        <span class="keyword">return</span> total[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> TrieNode <span class="title">buildTrie</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = word.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TrieNode root, <span class="keyword">int</span> length, <span class="keyword">int</span>[] total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isLeaf = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TrieNode child : root.children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            isLeaf = <span class="keyword">false</span>;</span><br><span class="line">            dfs(child, length + <span class="number">1</span>, total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">        total[<span class="number">0</span>] += length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="66-单词之和"><a href="#66-单词之和" class="headerlink" title="#66 单词之和"></a>#66 单词之和</h3><p>qing设计实现一个类型MapSum，它有如下两个操作</p>
<ul>
<li>函数insert，输入一个字符串和一个整数，在数据集合中添加一个字符串及其对应的值。如果数据集合中已经包含该字符串，则将该字符串对应的值替换成新值。</li>
<li>函数sum，输入一个字符串，返回数据集合中所有以该字符串为前缀的字符串对应的值之和。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> TrieNode[] children;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getSum(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(TrieNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = node.value;</span><br><span class="line">        <span class="keyword">for</span> (TrieNode child : node.children) &#123;</span><br><span class="line">            result += getSum(child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="67-最大的异或"><a href="#67-最大的异或" class="headerlink" title="#67 最大的异或"></a>#67 最大的异或</h3><p>输入一个整数数组(每个数字都大于或等于0)，请计算其中任意两个数字的异或的最大值。</p>
<p>例如，在数组[1,3,4,7]中，3和4的异或结果最大，异或结果为7。</p>
<p>分析：</p>
<p>整数的异或有一个特点，如果两个相同数位异或的结果是0，那么两个相反的数位异或的结果为1。如果想找到某个整数k和其他整数的最大异或值，那么尽量找和k的数位不同的整数。</p>
<p>因此，这个问题可以转化为查找的问题，而且还是按照整数的二进制数位进行查找的问题。需要将整数的每个数位都保存下来。前缀树可以实现这种思路，前缀树的每个节点对应整数的一个数位，路径对应一个整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> TrieNode[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TrieNode <span class="title">buildTrie</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[bit] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[bit] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[bit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    TrieNode root = buildTrie(nums);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[<span class="number">1</span>-bit] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                xor = (xor &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                node = node.children[<span class="number">1</span>-bit];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                xor = xor &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                node = node.children[bit];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        max = Math.max(max, xor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="二分查找的基础知识"><a href="#二分查找的基础知识" class="headerlink" title="#二分查找的基础知识"></a>#二分查找的基础知识</h3><p>在递增排序数组中进行二分查找的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二分查找的时间复杂度为O(logn)</strong></p>
<h3 id="68-查找插入的位置"><a href="#68-查找插入的位置" class="headerlink" title="#68 查找插入的位置"></a>#68 查找插入的位置</h3><p>输入一个排序的整数数组nums和一个目标值t，如果数组nums中包含t，则返回t在数组中的下标；如果数组nums中不包含t，则返回将t按顺序插入数组nums中的下标。假设数组中没有相同的数字。</p>
<p>例如：输入数组nums[1,3,6,8]，如果目标值t为3，则输出1；如果t为5，则返回2。</p>
<p>分析：</p>
<p>当数组中包含目标值时，返回它在数组中的位置。由于数组中没有相同的数字，因此它前一个数字一定小于目标值。于是可以将目标值t是否在数组中出现的两种情况统一起来，即查找满足两个条件的位置：一是该位置上的数字大于或等于t，二是该位置的前一个数字小于t。</p>
<p>要注意两个特殊情况。</p>
<ol>
<li>当mid等于0时如果nums[mid]依然大于目标值t，则意味着数组中的所有数字都比目标值大，应该返回0。</li>
<li>当数组中不存在大于或等于目标值t的数字时，那么t应该添加到所有数组的值的后面，即返回数组的长度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="69-山峰数组的顶部"><a href="#69-山峰数组的顶部" class="headerlink" title="#69 山峰数组的顶部"></a>#69 山峰数组的顶部</h3><p>在一个长度大于或等于3的数组，任意相邻的两个数字都不相等。该数组的前若干个数字时递增的，之后的数字时递减的，因此它的值看起来像一座山峰。请找出山峰顶部，即数组中最大值的位置。</p>
<p>例如：</p>
<p>在数组[1,3,5,4,2]中，最大值是5，输出它在数组中的下标2。</p>
<p>分析：</p>
<p>根据山峰数组的特点，最大值是数组中唯一一个比它左右两边数字都大的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="70-排序数组中只出现一次的数字"><a href="#70-排序数组中只出现一次的数字" class="headerlink" title="#70 排序数组中只出现一次的数字"></a>#70 排序数组中只出现一次的数字</h3><p>在一个排序的数组中，除一个数字只出现一次之外，其他数字都出现了两次，请找出这个唯一只出现一次的数字。</p>
<p>例如：</p>
<p>在数组[1,1,2,2,3,4,4,5,5]中，数字3只出现了一次。</p>
<p>分析：</p>
<p>如果题目稍加改动，输入的数组没有经过排序，其他条件不变，那么这就是另一类很经典的面试题。由于两个相同的数字异或的结果是0，因此如果将数组中所有数字异或，最终的结果就是那个唯一只出现一次的数字。这种解法的时间复杂度是O(n)。</p>
<p>但是既然是在排序数组中查找某个数字，就尝试应用二分查找算法。在一个排序数组中，如果所有数字都出现了两次，那么将数组中的数字每两个分成一组，每组的两个数字都是相等的。但如果在数组中添加一个只出现一次的数字，那么这个规律就会被打破。</p>
<p>其规律是：最初若干组的两个数字都是相同的。但是遇到了只出现一次的数字之后，导致后面所有出现两次的数字都被分到两个不同的组，即后面所有组的两个数字都不相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i = mid * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] != nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[i - <span class="number">2</span>] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果数组的长度是n(n为奇数)，每两个数字分成一组，则可以分成n/2+1组，最后一组只有一个数字。把这些分组从0开始编号，那么可以编号为0~n/2。在上述代码中，left是查找范围内的第1个分组的编号，right是查找范围内最后一个分组的编号。</p>
<h3 id="71-按权重生成随机数"><a href="#71-按权重生成随机数" class="headerlink" title="#71 按权重生成随机数"></a>#71 按权重生成随机数</h3><p>输入一个正整数数组w，数组中的每个数字w[i]表示下标i的权重，请实现一个函数pickIndex根据权重比例随机选择一个下标。</p>
<p>例如：</p>
<p>如果权重数组w为[1,2,3,4]，那么函数pickIndex将有10%的概率选择0、20%的概率选择1、30%的概率选择2、40%的概率选择3。</p>
<p>分析：</p>
<p>首先考虑如何根据权重比例计算选择下标的概率。先把权重数组中的所有权重加起来得到权重之和，然后用每个权重除以权重之和就能得到每个下标被选择的概率。</p>
<p>接着考虑如何根据权重比例随机选择一个下标。还是以权重数组[1,2,3,4]为例。先按照等概率生成0到9之间的一个整数p，如果p是0就选择0，p是1或2就选择1，以此类推。</p>
<p>可以创建另一个和权重数组的长度一样的数组sums，新数组的第i个数值sums[i]是权重数组中前i个数字之和。有了这个数组sums就能很方便地根据等概率随机生成的数字p按照权重比例选择下标。</p>
<p>sums数组满足递增条件，是排序数组。可以用二分查找法在其中查找需要的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[w.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length; i++) &#123;</span><br><span class="line">            total += w[i];</span><br><span class="line">            sums[i] = total;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> p = random.nextInt(total);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = sums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sums[mid] &gt; p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == <span class="number">0</span> || (sums[mid - <span class="number">1</span>] &lt;= p)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="72-求平方根"><a href="#72-求平方根" class="headerlink" title="#72 求平方根"></a>#72 求平方根</h3><p>输入一个非负整数，请计算它的平方根。正数的平方根有两个，只输出其中的正数平方根。如果平方根不是整数，那么只需要输出它的整数部分。</p>
<p>例如：</p>
<p>如果输入4则输出2；如果输入18则输出4。</p>
<p>分析：</p>
<p>除0之外，非负整数n的平方根一定在从1到n的范围内，在此范围内应用二分查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt;= n / mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid + <span class="number">1</span>) &gt; n / (mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变量mid表示某个范围的中间值。上述代码将mid * mid &lt;= n 写成了mid &lt;= n / mid。虽然这两个不等式在数学上是等价的，但计算mid * mid可能会产生溢出。</strong></p>
<h3 id="73-狒狒吃香蕉"><a href="#73-狒狒吃香蕉" class="headerlink" title="#73 狒狒吃香蕉"></a>#73 狒狒吃香蕉</h3><p>狒狒很喜欢吃香蕉。一天它发现了n堆香蕉，第i堆有piles[i]根香蕉。门卫刚好走开，H小时后才会回来。狒狒吃香蕉喜欢细嚼慢咽，但又想在门卫回来之前吃完所有的香蕉。请问狒狒每小时至少吃多少根香蕉？如果狒狒决定每小时吃k根香蕉，而它在吃的某一堆剩余的香蕉数目少于k，那么它只会将一堆香蕉吃完，下一个小时才会开始吃另一堆的香蕉。</p>
<p>例如：</p>
<p>有4堆香蕉，表示香蕉数目的数组piles为[3,6,7,11]，门卫将于8小时之后回来，那么狒狒每小时吃香蕉的数目为4根。如果它每小时吃4根香蕉，那么它用8小时吃完所有香蕉。如果它每小时只吃3根香蕉，则需要10小时，不能在门卫回来之前吃完。</p>
<p>分析：</p>
<p>它每小时至少要吃1根香蕉。由于它一小时内只吃一堆香蕉，因此它每小时吃香蕉数目的上限是最大一堆香蕉的数目，记为max根。</p>
<p>在此范围内应用二分查找，判断每小时要吃的香蕉数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">        max = Math.max(max, pile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = max;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> hours = getHours(piles, mid);</span><br><span class="line">        <span class="keyword">if</span> (hours &lt;= H) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">1</span> || getHours(piles, mid - <span class="number">1</span>) &gt; H) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHours</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hours = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">        hours += (pile + speed - <span class="number">1</span>) / speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hours;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="74-合并区间"><a href="#74-合并区间" class="headerlink" title="#74 合并区间"></a>#74 合并区间</h3><p>输入一个区间的集合，请将重叠的区间合并。每个区间用两个数字比较，分别表示区间的起始位置和结束位置。</p>
<p>例如：</p>
<p>输入区间[[1,3],[4,5],[8,10],[2,6],[9,12],[15,18]], 合并重叠的区间之后得到[[1,6],[8,12],[15,18]]。</p>
<p>分析：</p>
<p>如果先将所有区间按照起始位置排序，那么只需要比较相邻两个区间的结束位置就能知道它们是否重叠。如果它们重叠就将他们合并，然后判断合并区间是否和下一个区间重叠。重复这个过程，直到所有重叠的区间都合并为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    Arrays.sort(intervals, (i1, i2) -&gt; i1[<span class="number">0</span>] - i2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; merged = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.length) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; intervals.length &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= temp[<span class="number">1</span>]) &#123;</span><br><span class="line">            temp[<span class="number">1</span>] = Math.max(temp[<span class="number">1</span>], intervals[j][<span class="number">1</span>]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        merged.add(temp);</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[merged.size()][];</span><br><span class="line">    <span class="keyword">return</span> merged.toArray(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入数组有n个区间，那么将它排序的时间复杂度是O(nlogn)，接着逐一扫描排序的区间数组并将相邻的区间合并。虽然代码中有嵌套的二重循环，但每个区间只会扫描一次，因此时间复杂度是O(n)。上述算法的总体时间复杂度是O(nlogn)。</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="#计数排序"></a>#计数排序</h3><p>计数排序是一种线性时间的整数排序算法。如果数组的长度为n，整数范围(数组中最大整数与最小整数的差值)为k，对于k远小于n的场景(如对某公司所有员工的年龄排序)，那么计数排序的时间复杂度优于其他基于比较的排序算法(如归并排序、快速排序等)。</p>
<p>计数排序的参考代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        counts[num - min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = min; num &lt;= max; num++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (counts[num - min] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i++] = num;</span><br><span class="line">            counts[num - min]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果数组的长度是n，整数的范围是k，那么计数排序的**时间复杂度就是O(n+k)<strong>。由于需要创建一个长度为O(k)的辅助数组counts，因此</strong>空间复杂度是O(k)**。当k较小时，无论从时间复杂度还是空间复杂度来看计数排序都是非常高效的算法。当k很大时，计数排序可能就不如其他排序算法高效。</p>
<h3 id="75-数组相对排序"><a href="#75-数组相对排序" class="headerlink" title="#75 数组相对排序"></a>#75 数组相对排序</h3><p>输入两个数组arr1和arr2，其中数组arr2中的每个数字都唯一，并且都是数组arr1中的数字。请将数组arr1中的数字按照数组arr2中的数字的相对顺序排序。如果数组arr1中的数字再数组arr2中没有出现，那么将这些数字按递增的顺序排在后面。假设数组中的所有数字都在0到1000的范围内。</p>
<p>例如：</p>
<p>输入的数组arr1和arr2分别是[2,3,3,7,3,9,2,1,7,2]，和[3,2,1]，则数组arr1排序之后为[3,3,3,2,2,2,1,7,7,9]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr1) &#123;</span><br><span class="line">        counts[num]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr2) &#123;</span><br><span class="line">        <span class="keyword">while</span> (counts[num] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr1[i] = num;</span><br><span class="line">            i++;</span><br><span class="line">            counts[num]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; counts.length; num++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (counts[num] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr1[i] = num;</span><br><span class="line">            i++;</span><br><span class="line">            counts[num]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果数组arr1的长度为m，数组arr2的长度为n，那么时间复杂度时O(m+n)。辅助数组counts的长度为1001，是一个常数，因此空间复杂度可以认为是O(1)。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="#快速排序"></a>#快速排序</h3><p>快速排序是一种非常高效的算法，从其名字可以看出这种排序算法最大的特点就是快。当表现良好时，快速排序的速度比其他主要对手(如归并排序)快2~3倍。</p>
<p>快速排序的基本思想是分治法，排序过程如下：在输入数组中随机选取一个元素作为中间值(pivot)，然后对数组进行分区(partition)，使所有比中间值小的数据移到数组的左边，所有比中间值大的数据移到数组的右边。接下来对中间值左右两侧的子数组用相同的步骤排序，直到子数组中只有一个数字为止。</p>
<p>递归代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    quicksort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &gt; start) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(nums, start, end);</span><br><span class="line">        quicksort(nums, start, pivot - <span class="number">1</span>);</span><br><span class="line">        quicksort(nums, pivot + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nextInt(end - start + <span class="number">1</span>) + start;</span><br><span class="line">    swap(nums, random, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[end]) &#123;</span><br><span class="line">            small++;</span><br><span class="line">            swap(nums, i, small);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    small++;</span><br><span class="line">    swap(nums, small, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 != index2) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速排序的时间复杂度取决于所选取的中间值在数组中的为止。如果每次选取的中间值在排序数组中都接近数组中间的为止，那么快速排序的时间复杂度是O(nlogn)。如果每次选取的中间值都位于排序数组的头部或尾部，那么快速排序的时间复杂度是O(n^2)。这也是随机选取中间值的原因，避免在某些情况下快速排序退化成时间复杂度为O(n^2)的算法。在随机选取中间值的前提下，**快速排序的平均时间复杂度是O(nlogn)**。</p>
<h3 id="76-数组中第k大的数字"><a href="#76-数组中第k大的数字" class="headerlink" title="#76 数组中第k大的数字"></a>#76 数组中第k大的数字</h3><p>请从一个乱序数组中找出第k大的数字。</p>
<p>例如，数组[3,1,2,4,5,6]中第3大的数字是5。</p>
<p>分析：</p>
<p>面试题59中介绍过一种基于最小堆的解法。此种解法的时间复杂度是O(nlogk)，空间复杂度是O(k)。</p>
<p>但59题中的数据位于一个数据流中，不能一次性地将所有数据全部读入内存。但本题不同，数据都保存在一个数组中，所有操作都在内存中完成。因此有更快找出第k大的数字的算法。</p>
<p>在长度为n的排序数组中，第k大的数字的下标是n-k。可以用快速排序的函数partition对数组分区，如果函数partition选取的中间值在分区之后的下标正好是n-k，那么它就是第k大的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> target = nums.length - k;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(nums, start, end);</span><br><span class="line">    <span class="keyword">while</span> (index != target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; target) &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index = partition(nums, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nextInt(end - start + <span class="number">1</span>) + start;</span><br><span class="line">    swap(nums, random, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[end]) &#123;</span><br><span class="line">            small++;</span><br><span class="line">            swap(nums, i, small);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    small++;</span><br><span class="line">    swap(nums, small, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 != index2) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="#归并排序"></a>#归并排序</h3><p>归并排序也是一种基于分治法的排序算法。为了排序长度为n的数组，需要先排序两个长度为n/2的子数组，然后合并这两个排序的子数组，于是整个数组也就排序完毕。归并排序可以用迭代代码实现，也可以用递归代码实现。</p>
<p>递归代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray1(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] src = nums;</span><br><span class="line">    <span class="keyword">int</span>[] dst = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="comment">// 归</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; length; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; length; start += seg * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = Math.min(start + seg, length);</span><br><span class="line">            <span class="keyword">int</span> end = Math.min(start + seg * <span class="number">2</span>, length);</span><br><span class="line">            <span class="keyword">int</span> i = start, j = mid, k = start;</span><br><span class="line">            <span class="comment">// 并</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; mid || j &lt; end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == end || (i &lt; mid &amp;&amp; src[i] &lt; src[j])) &#123;</span><br><span class="line">                    dst[k++] = src[i++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dst[k++] = src[j++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] temp = src;</span><br><span class="line">        src = dst;</span><br><span class="line">        dst = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>递归代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray2(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] dst = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dst = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    mergeSort(nums, dst, <span class="number">0</span>, nums.length);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span>[] dst, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分组少了两个节点</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">1</span> &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(dst, src, start, mid);</span><br><span class="line">    mergeSort(dst, src, mid, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start, j = mid, k = start;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid || j &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == end || (i &lt; mid &amp;&amp; src[i] &lt; src[j])) &#123;</span><br><span class="line">            dst[k++] = src[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dst[k++] = src[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并排序的**时间复杂度是O(nlogn)<strong>。需要创建一个长度为n的辅助数组。如果递归实现归并排序，那么递归调用栈需要O(logn)的空间。因此，归并排序的</strong>空间复杂度是O(n)**。</p>
<h3 id="77-链表排序"><a href="#77-链表排序" class="headerlink" title="#77 链表排序"></a>#77 链表排序</h3><p>输入一个链表的头节点，请将该链表排序。</p>
<p>分析：</p>
<p>由于题目没有限定数字的范围，因此计数排序就不太合适。可以考虑使用插入排序、冒泡排序等算法对链表进行排序，只是这些算法的时间复杂度是O(n^2)，并不高效。</p>
<p>可以创建一个长度为n的数组来实现堆，也就是说，通过O(n)的空间代价来实现堆排序。</p>
<p>如果使用快速排序，那么需要O(n)的时间才能根据节点的编号找到对应的节点。如果始终以某个固定位置的值作为中间值，可能会导致每次分区时两个子链表的大小都不均衡，从而使时间复杂度退化为O(n^2)。因此，虽然可以用快速排序算法对链表进行排序，但不如对数组排序高效。</p>
<p>接下来考虑归并排序算法。借由双指针，可以将链表分成两半。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分组少于两个节点</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode head1 = head;</span><br><span class="line">    ListNode head2 = split(head);</span><br><span class="line"></span><br><span class="line">    head1 = sortList(head1);</span><br><span class="line">    head2 = sortList(head2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(head1, head2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">split</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode second = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.val &lt; head2.val) &#123;</span><br><span class="line">            cur.next = head1;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = head2;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur.next = head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="78-合并排序链表"><a href="#78-合并排序链表" class="headerlink" title="#78 合并排序链表"></a>#78 合并排序链表</h3><p>输入k个排序的链表，请将它们合并成一个排序的链表。</p>
<p>思路1：利用最小堆选取值最小的节点。用k个指针分别指向k个链表的头节点，用一个大小为k的堆存储这些节点的值。通过操作此堆完成排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists1</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((n1, n2)</span><br><span class="line">                                                          -&gt; n1.val - n2.val);</span><br><span class="line">    <span class="keyword">for</span> (ListNode list : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minHeap.offer(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">        ListNode least = minHeap.poll();</span><br><span class="line">        cur.next = least;</span><br><span class="line">        cur = least;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (least.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minHeap.offer(least.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设k个排序链表总共有n个节点。如果堆的大小为k，那么**空间复杂度就是O(k)<strong>。每次用最小堆处理一个节点需要O(logk)的时间，因此这种解法的</strong>时间复杂度是O(nlogk)**。</p>
<p>思路2：按照归并排序的思路合并链表。输入的k个排序链表可以分成两部分，前k/2个链表和后k/2个链表。如果将前k/2个链表和后k/2个链表分别合并成两个排序的链表，再将两个排序的链表合并，那么所有链表都合并了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists2</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mergeLists(lists, <span class="number">0</span>, lists.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeLists</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分组中只有一个链表</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">1</span> == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    ListNode head1 = mergeLists(lists, start, mid);</span><br><span class="line">    ListNode head2 = mergeLists(lists, mid, end);</span><br><span class="line">    <span class="keyword">return</span> merge(head1, head2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.val &lt; head2.val) &#123;</span><br><span class="line">            cur.next = head1;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = head2;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur.next = head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的递归调用的深度是O(logk)，每次需要合并n个节点，因此**时间复杂度是O(nlogk)<strong>。</strong>空间复杂度是O(nlogk)**，来维护递归调用栈。</p>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯法可以看作蛮力法的升级版，它在解决问题时的每一步都尝试所有可能的选项，最终找出所有可行的解决方案。<strong>回溯法解决问题的过程可以形象地用一个树形结构表示。</strong></p>
<p>由于回溯法实在所有选项形成的树上进行深度优先遍历，如果解决问题的步骤较多或每个步骤都面临多个选项，那么遍历整棵树将需要较多的时间。如果明确知道某些子树没有必要遍历，那么再遍历的时候应该避开这些子树以优化效率**(剪枝)**。</p>
<h3 id="79-所有子集"><a href="#79-所有子集" class="headerlink" title="#79 所有子集"></a>#79 所有子集</h3><p>输入一个不含重复数字的数据集合，请找出它的所有子集。</p>
<p>例如：</p>
<p>数据集合[1,2]有4个子集，分别是[]、[1]、[2]和[1,2]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    helper(nums, <span class="number">0</span>, <span class="keyword">new</span> LinkedList&lt;Integer&gt;(), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, LinkedList&lt;Integer&gt; subset, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(subset));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; nums.length) &#123;</span><br><span class="line">        helper(nums, index + <span class="number">1</span>, subset, result);</span><br><span class="line"></span><br><span class="line">        subset.add(nums[index]);</span><br><span class="line">        helper(nums, index + <span class="number">1</span>, subset, result);</span><br><span class="line">        subset.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入的集合中有n个元素，由于每个元素都有2个选项，因此**总的时间复杂度是O(2^n)**。</p>
<h3 id="80-包含k个元素的集合"><a href="#80-包含k个元素的集合" class="headerlink" title="#80 包含k个元素的集合"></a>#80 包含k个元素的集合</h3><p>输入n和k，请输出从1到n中选取k个数字组成所有的组合。</p>
<p>例如：</p>
<p>如果n等于3，k等于2，将组成3个组合，分别是[1,2],[1,3]和[2,3]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; combination = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(n, k, <span class="number">1</span>, combination, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> i, LinkedList&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (combination.size() == k) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= n) &#123;</span><br><span class="line">        helper(n, k, i + <span class="number">1</span>, combination, result);</span><br><span class="line"></span><br><span class="line">        combination.add(i);</span><br><span class="line">        helper(n, k, i + <span class="number">1</span>, combination, result);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="81-允许重复选择元素的集合"><a href="#81-允许重复选择元素的集合" class="headerlink" title="#81 允许重复选择元素的集合"></a>#81 允许重复选择元素的集合</h3><p>给定一个没有重复数字的正整数集合，请找出所有元素之和等于某个给定值的所有组合。同一个数字可以在组合中出现任意次。</p>
<p>例如，</p>
<p>输入整数集合[2,3,5]，元素之和等于8的组合有3个，分别是[2,2,2,2]，[2,3,3]，[3,5]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; combination = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(nums, target, <span class="number">0</span>, combination, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> i, LinkedList&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; <span class="number">0</span> &amp;&amp; i &lt; nums.length) &#123;</span><br><span class="line">        helper(nums, target, i + <span class="number">1</span>, combination, result);</span><br><span class="line"></span><br><span class="line">        combination.add(nums[i]);</span><br><span class="line">        helper(nums, target - nums[i], i, combination, result);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="82-包含重复元素集合的组合"><a href="#82-包含重复元素集合的组合" class="headerlink" title="#82 包含重复元素集合的组合"></a>#82 包含重复元素集合的组合</h3><p>给定一个可能包含重复数字的整数集合，请找出所有元素之和等于某个给定值的所有组合。输出中不得包含重复的组合。</p>
<p>例如，</p>
<p>输入整数集合[2,2,2,4,3,3]，元素之和等于8的组合有2个，分别是[2,2,4]和[2,3,3]。</p>
<p>分析：</p>
<p>避免重复的组合的方法是当某一步决定跳过值为m的数字时，跳过所有值为m的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; combination = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(nums, target, <span class="number">0</span>, combination, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> i, LinkedList&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(combination));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; <span class="number">0</span> &amp;&amp; i &lt; nums.length) &#123;</span><br><span class="line">        helper(nums, target, getNext(nums, i), combination, result);</span><br><span class="line"></span><br><span class="line">        combination.add(nums[i]);</span><br><span class="line">        helper(nums, target - nums[i], i + <span class="number">1</span>, combination, result);</span><br><span class="line">        combination.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next = index;</span><br><span class="line">    <span class="keyword">while</span> (next &lt; nums.length &amp;&amp; nums[next] == nums[index]) &#123;</span><br><span class="line">        next++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="83-没有重复元素集合的全排列"><a href="#83-没有重复元素集合的全排列" class="headerlink" title="#83 没有重复元素集合的全排列"></a>#83 没有重复元素集合的全排列</h3><p>给定一个没有重复数字的集合，请找出它的所有全排列。</p>
<p>例如，集合[1,2,3]有6个全排列。分别是[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(nums, <span class="number">0</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        List&lt;Integer&gt; permutation = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            permutation.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(permutation);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            helper(nums, i + <span class="number">1</span>, result);</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="84-包含重复元素集合的全排列"><a href="#84-包含重复元素集合的全排列" class="headerlink" title="#84 包含重复元素集合的全排列"></a>#84 包含重复元素集合的全排列</h3><p>给定一个包含重复数字的集合，请找出它的所有全排列。</p>
<p>例如，</p>
<p>集合[1,1,2]有3个全排列，分别是[1,1,2],[1,2,1],[2,1,1]。</p>
<p>分析：</p>
<p>如果已经将某个值为m的数字交换为排列的第i个数字，那么再遇到其他值为m的数字就跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(nums, <span class="number">0</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        List&lt;Integer&gt; permutation = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            permutation.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.add(permutation);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(nums[j])) &#123;</span><br><span class="line">                set.add(nums[j]);</span><br><span class="line"></span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                helper(nums, i + <span class="number">1</span>, result);</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="85-生成匹配的括号"><a href="#85-生成匹配的括号" class="headerlink" title="#85 生成匹配的括号"></a>#85 生成匹配的括号</h3><p>输入一个正整数n，请输出所有包含n个左括号和n个右括号的组合，要求每个组合的左括号和右括号匹配。</p>
<p>例如，当n等于2时，有两个符合条件的括号组合，分别是”(())”和”()()”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(n, n, <span class="string">&quot;&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String parenthesis, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">        result.add(parenthesis);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        helper(left - <span class="number">1</span>, right, parenthesis + <span class="string">&quot;(&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        helper(left, right - <span class="number">1</span>, parenthesis + <span class="string">&quot;)&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="86-分割回文字符串"><a href="#86-分割回文字符串" class="headerlink" title="#86 分割回文字符串"></a>#86 分割回文字符串</h3><p>输入一个字符串，要求将它分割成若干子字符串，使每个子字符串都是回文。请列出所有可能的分割方法。</p>
<p>例如，输入”google”，将输出3种符合条件的分割方法，分别是[“g”, “o”, “o”, “g”, “l”, “e”]，[“g”, “oo”, “g”, “l”, “e”]，</p>
<p>[“goog”, “l”, “e”]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(s, <span class="number">0</span>, <span class="keyword">new</span> LinkedList&lt;&gt;(), result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String str, <span class="keyword">int</span> start, LinkedList&lt;String&gt; substrings, List&lt;List&lt;String&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == str.length()) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(substrings));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(str, start, i)) &#123;</span><br><span class="line">            substrings.add(str.substring(start, i + <span class="number">1</span>));</span><br><span class="line">            helper(str, i + <span class="number">1</span>, substrings, result);</span><br><span class="line">            substrings.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(start++) != str.charAt(end--)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="87-恢复IP地址"><a href="#87-恢复IP地址" class="headerlink" title="#87 恢复IP地址"></a>#87 恢复IP地址</h3><p>输入一个只包含数字的字符串，请列出所有可能的恢复出来的IP地址。</p>
<p>例如，输入字符串”10203040”，可能恢复出3个IP地址，分别为”10.20.30.40”、”102.0.30.40”、”10.203.0.40”。</p>
<p>分析：</p>
<p>根据IP地址的特点，一个IP地址被三个’.’字符分隔成4段，每段是从0到255之间的一个数字。另外，除”0”本身外，其他数字不能以’0’开头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    helper(s, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> segI, String seg, String ip, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == s.length() &amp;&amp; segI == <span class="number">3</span> &amp;&amp; isValidSeg(seg)) &#123;</span><br><span class="line">        result.add(ip + seg);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; s.length() &amp;&amp; segI &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">        <span class="comment">// 将当前字符拼接到当前分段数字的末尾</span></span><br><span class="line">        <span class="keyword">if</span> (isValidSeg(seg + ch)) &#123;</span><br><span class="line">            helper(s, i + <span class="number">1</span>, segI, seg + ch, ip, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前字符作为新的分段的开始</span></span><br><span class="line">        <span class="keyword">if</span> (seg.length() &gt; <span class="number">0</span> &amp;&amp; segI &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            helper(s, i + <span class="number">1</span>, segI + <span class="number">1</span>, <span class="string">&quot;&quot;</span> + ch, ip + seg + <span class="string">&quot;.&quot;</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidSeg</span><span class="params">(String seg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(seg) &lt;= <span class="number">255</span> &amp;&amp; (seg.equals(<span class="string">&quot;0&quot;</span>) || seg.charAt(<span class="number">0</span>) != <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归函数helper的参数i是字符串s中当前被处理的字符的下标。参数segI是当前分段数字的下标，由于IP地址有4个分段数字，因此参数segI的取值范围是从0到3。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>用动态规划解决问题的第1步是识别哪些问题适合运用动态规划。和适合运用回溯法的问题类似，适用动态规划的问题都存在若干步骤，并且每个步骤都面临若干选择。如果题目要求列举出所有的解，那么很有可能需要用回溯法解决。<strong>如果题目是求一个问题的最优解(通常是求最大值或最小值)，或者求问题的解的数目(或判断问题是否存在解)，那么这个题目有可能适合运用动态规划。</strong></p>
<p>采用动态规划时总是用递归的思路分析问题，即把大问题分解成小问题，再把小问题的解合起来形成大问题的解。如果将大问题分解成若干小问题之后，小问题相互重叠，那么直接用递归的代码实现就会存在大量的重复计算。<strong>小问题之间存在重叠部分，这是可以用动态规划求解问题的另一个显著特点。</strong></p>
<h3 id="88-爬楼梯的最少成本"><a href="#88-爬楼梯的最少成本" class="headerlink" title="#88 爬楼梯的最少成本"></a>#88 爬楼梯的最少成本</h3><p>一个数组cost的所有数字都是正数，它的第i个数字表示在一个楼梯的第i级台阶往上爬的成本，在支付了成本cost[i]之后可以从第i级台阶往上爬1级或2级。假设台阶上至少有2级，既可以从第0级台阶出发，也可以从第1级台阶出发，请计算爬上该楼梯的最少成本。</p>
<p>例如，输入数组[1,100,1,1,100,1]，则爬上该楼梯的最少成本时4，分别经过下标为0、2、3、5的这4级台阶。</p>
<p>分析：确定状态转移方程。</p>
<p>可以用函数f(i)表示从楼梯的第i级台阶再往上爬的最少成本。由于一次可以爬1级或2级台阶，即f(n-1)和f(n-2)的最小值就是这个问题的最优解。</p>
<p>状态转移方程: f(i)=min(f(i-1),f(i-2))+cost[i]。</p>
<p>递归代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs1</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = cost.length;</span><br><span class="line">    <span class="keyword">return</span> Math.min(helper1(cost, len - <span class="number">2</span>), helper1(cost, len - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper1</span><span class="params">(<span class="keyword">int</span>[] cost, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cost[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(helper1(cost, i - <span class="number">2</span>), helper1(cost, i - <span class="number">1</span>)) + cost[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然直观，但是存在大量重复计算，效率不高。</p>
<p>使用缓存的递归代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs2</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    helper2(cost, len - <span class="number">1</span>, dp);</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[len - <span class="number">2</span>], dp[len - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper2</span><span class="params">(<span class="keyword">int</span>[] cost, <span class="keyword">int</span> i, <span class="keyword">int</span>[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        dp[i] = cost[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        helper2(cost, i - <span class="number">2</span>, dp);</span><br><span class="line">        helper2(cost, i - <span class="number">1</span>, dp);</span><br><span class="line">        dp[i] = Math.min(dp[i - <span class="number">2</span>], dp[i - <span class="number">1</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**时间复杂度O(n)<strong>。同时，需要一个长度为n的数组，因此</strong>空间复杂度也是O(n)**。</p>
<p>空间复杂度为O(n)的迭代代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs3</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i - <span class="number">2</span>], dp[i - <span class="number">1</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[len - <span class="number">2</span>], dp[len - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>空间复杂度为O(1)的迭代代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs4</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cost[<span class="number">0</span>], cost[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">        dp[i % <span class="number">2</span>] = Math.min(dp[<span class="number">0</span>], dp[<span class="number">1</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，数组dp的长度时2，求解的f(i)的结果保存在数组下标为”i%2”的位置。</p>
<h3 id="89-房屋偷盗"><a href="#89-房屋偷盗" class="headerlink" title="#89 房屋偷盗"></a>#89 房屋偷盗</h3><p>输入一个数组表示某条街上的一排房屋内财产的数量。如果这条街上相邻的两幢房屋被盗就会自动触发报警系统。请计算小偷在这条街上最多能偷取到多少财产。</p>
<p>例如，街道上有5幢房屋，房屋内的财产用数组[2,3,4,5,3]表示，那么他能偷取到的最多的财务是9。</p>
<p>分析：</p>
<p>f(i)表示小偷从标号为0的房屋开始到标号为i的房屋为止能偷取到的财务的最大值。</p>
<p>状态转移方程：f(i)=max(f(i-2)+nums[i],f(i-1))</p>
<p>带缓存的递归代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    helper1(nums, nums.length - <span class="number">1</span>, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span>[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i] = nums[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        dp[i] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        helper1(nums, i - <span class="number">2</span>, dp);</span><br><span class="line">        helper1(nums, i - <span class="number">1</span>, dp);</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)。</p>
<p>空间复杂度为O(n)的迭代代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>空间复杂度为O(1)的迭代代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i % <span class="number">2</span>] = Math.max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>], dp[(i - <span class="number">2</span>) % <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[(nums.length - <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>还可以用两个状态转移方程解决问题。定义两个表达式f(i)，g(i)，其中f(i)表示小偷选择不进入标号为i的房屋偷东西时能偷得的最多财物数量，g(i)表示小偷选择进入标号为i的房屋偷东西时能偷得得最多财物数量。因此，f(n-1)和g(n-1)的最大值就是小偷能从n幢房屋内偷得的财物得最大值。</p>
<p>定义状态转移方程：</p>
<p>f(i) = max(f(i-1),g(i-1))</p>
<p>g(i) = f(i-1) + nums[i-1]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob4</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i % <span class="number">2</span>] = Math.max(dp[<span class="number">0</span>][(i - <span class="number">1</span>) % <span class="number">2</span>], dp[<span class="number">1</span>][(i - <span class="number">1</span>) % <span class="number">2</span>]);</span><br><span class="line">        dp[<span class="number">1</span>][i % <span class="number">2</span>] = dp[<span class="number">0</span>][(i - <span class="number">1</span>) % <span class="number">2</span>] +nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[<span class="number">0</span>][(len - <span class="number">1</span>) % <span class="number">2</span>], dp[<span class="number">1</span>][(len - <span class="number">1</span>) % <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，<strong>空间复杂度为O(1)。但实际使用得辅助空间比上一种方法多了一倍</strong>。</p>
<h3 id="90-环形房屋偷盗"><a href="#90-环形房屋偷盗" class="headerlink" title="#90 环形房屋偷盗"></a>#90 环形房屋偷盗</h3><p>一条环形街道上有若干房屋。输入一个数组表示该条街道上得房屋内财产的数量。如果这条街道上相邻的两幢房屋被盗就会自动触发报警系统。请计算小偷在这条街道上最多能偷取的财产的数量。</p>
<p>分析：</p>
<p>这个问题与#89题的区别在于小偷不能同时到标号为0和n-1这两幢房屋内偷东西。如果他考虑去标号为0的房屋，那么他一定不能去标号为n-1的房屋；反之亦然。因此，可以将这个问题分解成两个子问题，分别求小偷从标号0<del>n-2的房屋内偷得的最多财物数量，和从标号1</del>n-1的房屋内偷得的最多财物数量。这两个问题提解的最大值就是此问题的解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result1 = helper(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> result2 = helper(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(result1, result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[start];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="comment">// 确保从第0个位置开始更新</span></span><br><span class="line">        <span class="keyword">int</span> j = i - start;</span><br><span class="line">        dp[j % <span class="number">2</span>] = Math.max(dp[(j - <span class="number">1</span>) % <span class="number">2</span>], dp[(j - <span class="number">2</span>) % <span class="number">2</span>] + nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[(end - start) % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="91-粉刷房子"><a href="#91-粉刷房子" class="headerlink" title="#91 粉刷房子"></a>#91 粉刷房子</h3><p>一排n幢房子要刷成红色、绿色和蓝色，不同房子被粉刷成不同颜色的成本不同。用一个nx3的数组表示n幢房子分别用3种颜色粉刷的成本。要求任意相邻的两幢房子的颜色都不一样，请分别计算这n幢房子的最少成本。</p>
<p>例如，粉刷3幢房子的成本分别为[[17,2,16],[15,14,5],[13,3,1]]，粉刷的最少成本是10。</p>
<p>分析：</p>
<p>用r(i), g(i), b(i)分别表示将标号为i的房子粉刷成红色、绿色和蓝色时粉刷标号从0到i的i+1幢房子的最少成本。</p>
<p>r(i) = min(g(i-1),b(i-1))+cost[i][0]</p>
<p>g(i) = min(r(i-1),b(i-1))+cost[i][1]</p>
<p>b(i) = min(r(i-1),g(i-1))+cost[i][2]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        dp[j][<span class="number">0</span>] = costs[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev1 = dp[(j+<span class="number">2</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> prev2 = dp[(j+<span class="number">1</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">            dp[j][i%<span class="number">2</span>] = Math.min(prev1, prev2) + costs[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> last = (costs.length - <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[<span class="number">0</span>][last], Math.min(dp[<span class="number">1</span>][last], dp[<span class="number">2</span>][last]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="92-翻转字符"><a href="#92-翻转字符" class="headerlink" title="#92 翻转字符"></a>#92 翻转字符</h3><p>输入一个只包含’0’和’1’的字符串，其中’0’可以翻转成’1’，’1’可以翻转成’0’。请问至少需要翻转几个字符，才可以使翻转之后的字符串中所有的’0’位于’1’的前面？翻转之后的字符串可能只包含字符’0’或’1’。</p>
<p>例如：输入字符串”00110”，至少需要翻转一个字符才能使所有的’0’位于’1’的前面。</p>
<p>分析：</p>
<p>由于翻转下标为i的字符依赖于前i个字符翻转之后最后一个字符是’0’还是’1’，因此要分两种情况讨论。假设函数f(i)表示把字符串从下标为0的字符到下标为i的字符编程符合要求的字符串且最后一个字符是’0’所需要的最少翻转次数。g(i)类似，只不过最后一个字符是’1’。</p>
<p>当字符i是’0’时</p>
<ul>
<li>f(i) = f(i-1)</li>
<li>g(i) = min[f(i-1),g(i-1)]+1</li>
</ul>
<p>当字符i是’1’时</p>
<ul>
<li>f(i) = f(i-1) + 1</li>
<li>g(i) = min[f(i-1),g(i-1)]</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFlipsMonoIncr</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> ch = s.charAt(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = ch == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = ch == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ch = s.charAt(i);</span><br><span class="line">        <span class="keyword">int</span> prev0 = dp[<span class="number">0</span>][(i-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> prev1 = dp[<span class="number">1</span>][(i-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][i%<span class="number">2</span>] = prev0 + (ch == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">1</span>][i%<span class="number">2</span>] = Math.min(prev0, prev1) + (ch == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> last = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[<span class="number">0</span>][last%<span class="number">2</span>], dp[<span class="number">1</span>][last%<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度O(n)，空间复杂度O(1)。</strong></p>
<h3 id="93-最长斐波那契数列"><a href="#93-最长斐波那契数列" class="headerlink" title="#93 最长斐波那契数列"></a>#93 最长斐波那契数列</h3><p>输入一个没有重复数字的单调递增的数组，数组中至少有3个数字，请问数组中最长的斐波那契数列的长度是多少？</p>
<p>例如：如果输入的数组是[1,2,3,4,5,6,7,8]，由于其中最长的斐波那契数列是1、2、3、5、8，因此输出是5。</p>
<p>分析：</p>
<p>由于以A[i]为结尾的斐波那契数列的长度依赖于它前一个数字A[j]，不同的A[j]能和A[i]形成不同的斐波那契数列，它们的长度也可能不同。因此，状态转移方程有两个参数i和j，f(i,j)表示以A[i]为最后一个数字，A[j]为倒数第2个数字的斐波那契数列的长度。如果数组中存在一个数字k，使A[i] = A[j] + A[k](0&lt;=k&lt;j&lt;i)，那么f(i,j)=f(j,k)+1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        map.put(A[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][A.length];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = map.getOrDefault(A[i] - A[j], -<span class="number">1</span>);</span><br><span class="line">            dp[i][j] = k &gt;= <span class="number">0</span> &amp;&amp; k &lt; j ? dp[j][k] + <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            result = Math.max(result, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result &gt; <span class="number">2</span> ? result : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码用到了二重循环，因此**时间复杂度是O(n^2)<strong>。由于使用了一个大小为O(n^2)的二维数组和一个大小为O(n)的哈希表，因此</strong>空间复杂度也是O(n^2)**。</p>
<h3 id="94-最少回文分割"><a href="#94-最少回文分割" class="headerlink" title="#94 最少回文分割"></a>#94 最少回文分割</h3><p>输入一个字符串，请问至少需要几次分割才可以使分割出的每个字符串都是回文？</p>
<p>例如：输入字符串”aaba”，至少需要分割1次，从两个相邻字符’a’中间切一刀将字符串分割成两个回文子字符串”a”和”aba”。</p>
<p>分析：</p>
<p>用f(i)表示从下标为0到i的子字符串S[0..i]的符合条件的最少分割次数。如果子字符串S[0..i]本身就是一个回文，那么不需要分割就符合要求，此时f(i)等于0。如果子字符串S[0..i]不是一个回文，那么对每个下标j(1&lt;=j&lt;=i)逐一判断子字符串S[j..i]是不是回文。如果是回文，那么这就是一个有效的分割方法，此时的分割次数相当于子字符串S[0..j-1]的分割次数再加1。因此，f(i)就是所有符合条件的j对应的f(i-1)的最小值加1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] isPal = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> ch2 = s.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (ch1 == ch2 &amp;&amp; (i &lt;= j + <span class="number">1</span>) || isPal[j+<span class="number">1</span>][i-<span class="number">1</span>]) &#123;</span><br><span class="line">                isPal[j][i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPal[<span class="number">0</span>][i]) &#123;</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPal[j][i]) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了优化时间复杂度，上述代码需要预处理，先判断所有子字符串S[j..i]是不是回文，并将子字符串是否为回文的结果保存在”isPal[j][i]”中。判断子字符串S[j..i]是否为回文的标准使字符S[j]和S[i]相同，并且子字符串S[j+1][i-1]也是回文。优化之后只需要O(1)的时间就能判断子字符串S[j..i]是不是回文。</p>
<p>长度为n的子字符串有O(n^2)个子字符串，因此需要至少O(n^2)的时间才能判断所有的子字符串是不是回文。低2个二重循环是为了计算状态转移方程，时间复杂度也是O(n^2)。因此，上述解法的**总体时间复杂度是O(n^2)**。</p>
<p>上述代码使用了两个数组，一个是大小为O(n^2)的二维数组isPal，另一个是大小为O(n)的一维数组dp，因此<strong>总的空间复杂度是O(n^2)<strong>。正常求回文串的算法时间复杂度是O(n)，可以用一个大小为O(n^2)的数组将时间复杂度从O(n^3)优化到O(n^2)，因此</strong>这种优化是用空间换时间</strong>。</p>
<h3 id="95-最长公共子序列"><a href="#95-最长公共子序列" class="headerlink" title="#95 最长公共子序列"></a>#95 最长公共子序列</h3><p>输入两个字符串，请求出它们的最长公共子序列的长度。如果从字符串s1中删除若干字符之后能得到字符串s2，那么字符串s2就是字符串s1的一个子序列。</p>
<p>例如，从字符串”abcde”中删除两个字符之后能得到字符串”ace”，因此字符串”ace”是字符串”abcde”的一个子序列。但字符串”aec”不是字符串”abcde”的子序列。如果输入字符串”abcde”和”badfe”，呢么它们的最长公共子序列是”bde”，因此输出3。</p>
<p>分析：</p>
<p>用函数f(i,j)表示第1个字符串中下标从0到i的子字符串和第2个字符串中下标从0到j的最长公共子序列的长度。</p>
<p>可以将这个问题的状态转移方程总结为:</p>
<ul>
<li>f(i,j) = f(i-1,j-1)+1 (s1[i]==s2[j])</li>
<li>f(i,j) = max(f(i-1,j),f(i,j-1)) (s1[i] != s2[j])</li>
</ul>
<p>当上述状态转移方程的i或j等于0时，即求f(0,j)或f(i,0)时可能需要f(-1,j)或f(i,-1)的值。-1表示空串。任意空字符串和另一个字符串的公共子序列的长度都是0，所以f(-1,j)和f(i,-1)的值都等于0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence1</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i) == text2.charAt(j)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.max(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设两字符串的长度分别为m、n</p>
<p>f(i,j)的值保存在dp[i+1][j+1]中，这种解法的**空间复杂度是O(mn)**。</p>
<p>接着用二重循环填充数组dp中的每个数值，循环体内时按照状态转移方程写出的代码。这种解法的**时间复杂度是O(mn)**。</p>
<p>优化空间效率，只保存表格中的两行：</p>
<p>f(i,j)的值依赖于表格中左上角f(i-1,j-1)的值、正上方f(i-1,j)的值和同一行左边f(i,j-1)的值。由于计算f(i,j)时只需要使用上方一行的值和同一行左边的值，因此实际上只需要保存表格中的两行就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubquence2</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line">    <span class="comment">// 保证长的字符串在前</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">return</span> longestCommonSubquence2(text2, text1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i) == text2.charAt(j)) &#123;</span><br><span class="line">                dp[(i+<span class="number">1</span>)%<span class="number">2</span>][j+<span class="number">1</span>] = dp[i%<span class="number">2</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[(i+<span class="number">1</span>)%<span class="number">2</span>][j+<span class="number">1</span>] = Math.max(dp[i%<span class="number">2</span>][j+<span class="number">1</span>], dp[(i+<span class="number">1</span>)%<span class="number">2</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len1%<span class="number">2</span>][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于数组dp的行数是一个常数，因此此时**空间复杂度是O(min(m,n))<strong>。由于仍然需要二重循环，因此</strong>时间复杂度仍然是O(mn)**。</p>
<p>进一步优化空间效率，只需要一个一维数组：</p>
<p>为了让一个一维数组保存表格中的两行信息，一维数组的每个位置需要保存原来表格中上下两格的信息，即f(i,j)和f(i-1,j)都保存在数组dp下标j+1的位置。在计算f(i,j)之前，dp[j+1]中保存的是f(i-1,j)的值，在完成f(i,j)的计算之后，dp[j+1]被f(i,j)的值替换。</p>
<p>需要注意的是，在计算f(i,j+1)时，可能还需要f(i-1,j)的值，因此在<strong>计算f(i,j)之后不能直接用f(i,j)的值替换dp[j+1]中f(i-1,j)的值</strong>。可以先将这个值临时保存起来，这样在下一步计算时还能用到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence3</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line">    <span class="comment">// 保证长的字符串在前</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">return</span> longestCommonSubsequence3(text2, text1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i) == text1.charAt(j)) &#123;</span><br><span class="line">                cur = prev + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = Math.max(dp[j], dp[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prev = dp[j + <span class="number">1</span>];</span><br><span class="line">            dp[j + <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量prev保存的是f(i-1,j-1)的值。</p>
<p>在代码cur = Math.max(dp[j], dp[j+1])中，dp[j]对应的是f(i,j-1)，而dp[j+1]对应的是f(i-1,j)。</p>
<p><strong>虽然再次优化后的空间复杂度仍然是O(min(m,n))，但是所需的辅助空间减少到之前的一半。</strong></p>
<h3 id="96-字符串交织"><a href="#96-字符串交织" class="headerlink" title="#96 字符串交织"></a>#96 字符串交织</h3><p>输入3个字符串s1,s2,s3,请判断字符串s3能不能由字符串s1和s2交织而成，即字符串s3的所有字符串都是字符串s1或s2中的字符，字符串s1和s2中的字符都将出现在字符串s3中且相对位置不变。</p>
<p>例如：字符串”aadbbcbcac”可以由字符串”aabcc”和”dbbca”交织而成。</p>
<p>分析：</p>
<p>如果字符串的s1的长度为m，字符串s2的长度为n，那么它们交织得到的字符串s3的长度一定是m+n。</p>
<p>可以用函数f(i,j)表示字符串s1[0..i]和字符串s2[0..j]能否交织得到字符串s3[0..i+j+1]。</p>
<p>状态转移方程：</p>
<ul>
<li>f(i,j) = f(i-1,j) if {s3[i+j+1] = s1[i]}</li>
<li>f(i,j) = f(i,j-1) if {s3[i+j+1] = s2[j]}</li>
<li>f(i,j) = f(i-1,j) or f(i,j-1) if {s3[i+j+1] = s1[i] = s2[j]}</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave1</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        dp[i + <span class="number">1</span>][<span class="number">0</span>] = s1.charAt(i) == s3.charAt(i) &amp;&amp; dp[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j + <span class="number">1</span>] = s2.charAt(j) == s3.charAt(j) &amp;&amp; dp[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = s1.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> ch2 = s2.charAt(j);</span><br><span class="line">            <span class="keyword">char</span> ch3 = s3.charAt(i + j + <span class="number">1</span>);</span><br><span class="line">            dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (ch1 == ch3 &amp;&amp; dp[i][j + <span class="number">1</span>]) || (ch2 == ch3 &amp;&amp; dp[i + <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于需要一个二重循环，因此上述代码的<strong>时间复杂度是O(mn)</strong>; 由于需要用二维数组dp保存f(i,j)的计算结果，因此它的**空间复杂度也是O(mn)**。</p>
<p>优化空间效率：</p>
<p>由于f(i,j)的值只依赖于f(i-1,j)和f(i,j-1)的值，因此计算数组dp的行号为i+1的位置时只需要上面行号为i的一行的值，即只需要保留二维数组中的两行就可以。当数组dp只有两行时，f(i,j)的值保存在dp[(i+1)%2][j+1]中。</p>
<p>还可以进一步优化空间效率，只需要保留二维数组中的一行就可以。f(i,j)的值依赖于位于它上方的f(i-1,j)和它左方的f(i,j-1)，而它上方的f(i-1,j)在计算完f(i,j)之后就没用了，因此可以把它们存在同一个格子中，即计算完f(i,j)后覆盖f(i-1,j)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave2</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证长的字符串在前</span></span><br><span class="line">    <span class="keyword">if</span> (s1.length() &lt; s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> isInterleave2(s2, s1, s3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s2.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">        dp[j + <span class="number">1</span>] = s2.charAt(j) == s3.charAt(j) &amp;&amp; dp[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">0</span>] &amp;&amp; s1.charAt(i) == s3.charAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = s1.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> ch2 = s2.charAt(j);</span><br><span class="line">            <span class="keyword">char</span> ch3 = s3.charAt(i + j + <span class="number">1</span>);</span><br><span class="line">            dp[j + <span class="number">1</span>] = (ch1 == ch3 &amp;&amp; dp[j + <span class="number">1</span>]) || (ch2 == ch3 &amp;&amp; dp[j]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[s2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后代码的**时间复杂度仍然是O(mn)<strong>，但</strong>空间效率变成O(min(m,n))**。</p>
<h3 id="子序列数目"><a href="#子序列数目" class="headerlink" title="# 子序列数目"></a># 子序列数目</h3><p>输入字符串S和T，请计算字符串S中有多少个子序列等于字符串T。</p>
<p>例如，在字符串”appplep”中，由3个子序列等于字符串”apple”。</p>
<p>分析：</p>
<p>用f(i,j)表示字符串S下标从0到i的子字符串中等于字符串T下标从0到j的字符串的子序列数目。</p>
<p>当字符串S的长度小于字符串T的长度时，字符串S中不可能存在等于字符串T的子序列，所以当i小于j时，f(i,j)的值都等于0。</p>
<p>如果S[i]=T[j]，那么对S[i]有两个选择：</p>
<ul>
<li>用S[i]去匹配T[j]，此时f(i,j)=f(i-1,j-1)</li>
<li>舍去S[i]，此时f(i,j)=f(i-1,j)</li>
</ul>
<p>因此，当S[i]=T[j]，f(i,j)=f(i-1,j-1)+f(i-1,j)</p>
<p>如果S[i]!=T[j]，f(i,j)=f(i-1,j)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct1</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i &amp;&amp; j &lt; t.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + dp[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果字符串S的长度为m，字符串T的长度为n，那么**时间复杂度为O(mn)<strong>，</strong>空间复杂度也为O(mn)**。</p>
<p>优化空间效率：</p>
<p>在计算f(i,j)的值时，最多只需要用到它上一行f(i-1,j-1)和f(i-1,j)的值，因此可以只保存表格中的两行。可以创建一个只有两行的二维数组dp，列数仍然是n+1，将f(i,j)保存在dp[(i+1)%2][j+1]中。</p>
<p>还可以进一步优化空间效率。将f(i,j)和f(i-1,j)保存在数组的同一个位置，这样实际上只需要一个长度为n+1的一维数组。但是f(i-1,j)的值在计算f(i,j+1)的时候也会需要，所以计算完f(i,j)之后不能直接覆盖。这里给出两个解决方案：</p>
<ul>
<li>保存f(i-1,j)的值备用</li>
<li>从右向左计算(因为计算f(i,j)时并不需要依赖f(i,j-1)的值)，这样可以避免值覆盖的问题，也不会影响计算结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct2</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Math.min(i, t.length() - <span class="number">1</span>); j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                dp[j + <span class="number">1</span>] = dp[j + <span class="number">1</span>] + dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[t.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化之后的**时间复杂度仍然是O(mn)<strong>，但</strong>空间复杂度为O(n)**。且比用两行数组的优化方法需要的辅助空间减少一倍。</p>
<h3 id="98-路径的数目"><a href="#98-路径的数目" class="headerlink" title="#98 路径的数目"></a>#98 路径的数目</h3><p>一个机器人从mxn的格子的左上角出发，它每步要么向下要么向右，直到抵达格子的左下角。请计机器人从左上角到达右下角的路径的数目。</p>
<p>例如，如果格子的大小是3x3，那么机器人从左上角到达右下角有6条符合条件的不同路径。</p>
<p>分析：</p>
<p>用f(i,j)表示从格子的左上角坐标为(0,0)的位置出发到达坐标为(i,j)的位置的路径的数目。</p>
<p>当i=0，机器人位于格子最上面的一行，机器人只能从(i, j-1)的位置向右走一步。</p>
<p>当j=0，机器人位于格子最左边的一列，机器人只能从(i-1,j)的位置向下走一步。</p>
<p>当i,j都大于0时，有两种走法，所以f(i,j)=f(i-1,j)+f(i,j-1)</p>
<p>递归代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">return</span> helper(m - <span class="number">1</span>, n - <span class="number">1</span>, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = helper(i - <span class="number">1</span>, j, dp) + helper(i, j - <span class="number">1</span>, dp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    Arrays.fill(dp[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优化空间效率：</p>
<p>在计算f(i,j)时只需要用到f(i-1,j)和f(i,j-1)的值，因此只需要记录两行即可。将f(i,j)保存在dp[i%2][j]中。</p>
<p>可以进一步优化空间效率。在计算出f(i,j)之后，f(i-1,j)的值就没用了，因此可以把它们存在同一个位置，计算出f(i,j)后直接覆盖f(i-1,j)的值。这样用一个一维数组就可以实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths3</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="99-最小路径之和"><a href="#99-最小路径之和" class="headerlink" title="#99 最小路径之和"></a>#99 最小路径之和</h3><p>在一个mxn(m、n均大于0)的格子中，每个位置都有一个数字。一个机器人每步只能向下或向右，请计算它从格子的左上角到达右下角的路径的数字之和的最小值。</p>
<p>分析：</p>
<p>用f(i,j)表示从(0,0)到(i,j)数字之和的最小值。</p>
<p>当i等于0时，机器人位于格子最上面一行，那么此时只能从f(i,j-1)向右走一步到达。因此最小值只能是f(i,j-1)+grid[0][j]</p>
<p>当j等于0时，机器人位于格子最左边一列，那么此时只能从f(i-1,j)向下走一步到达。因此最小值只能是f(i-1,j)+grid[i][0]</p>
<p>当i,j都大于0时，f(i,j)=Math.min[f(i-1,j),f(i,j-1)]+grid[i][j]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum1</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j] + dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            dp[i][j] = grid[i][j] + prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[grid.length - <span class="number">1</span>][grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度空间复杂度都为O(mn)。</p>
<p>优化空间效率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum2</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid[<span class="number">0</span>].length];</span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">        dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] += grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j-<span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度为O(mn)，但空间复杂度降为O(n)。</strong></p>
<h3 id="100-三角形中最小路径之和"><a href="#100-三角形中最小路径之和" class="headerlink" title="#100 三角形中最小路径之和"></a>#100 三角形中最小路径之和</h3><p>在一个由数字组成的三角形中，第1行有1个数字，第2行有2个数字，以此类推，第n行有n个数字。如果每步只能前往下一行中相邻的数字，请计算从三角形顶部到底部的路径经过的数字之和的最小值。</p>
<p>分析：</p>
<p>可以用矩阵坐标来定位三角形中的数字。移动三角形每行的位置使他们左端对齐。如果三角形有n行数字，将这些行左对齐之后就形成了一个nxn的矩阵的左下半部分。如果三角形中某个数字再矩阵中的行号和列号分别是i和j，那么i&gt;=j。</p>
<p>用f(i,j)表示从三角形的顶部出发到达行号和列号分别为i和j(i&gt;=j)的位置时路径数字之和的最小值。有三种情况：</p>
<ul>
<li>j=0，当前到达某行的第1个数字。由于路径的每步都时前往正下方或右下方的数字，而此时当前位置的左上方没有数字，那么前一步一定来自它的正上方的数字，f(i,0)=f(i-1,0)+T[i][0]</li>
<li>i=j，当前到达某行的最后一个数字，此时它的正上方没有数字，前一步只能来自它左上方的数字，f(i,j)=f(i-1,j-1)+T[i][j]</li>
<li>其他情况，f(i,j)=Math.min(f(i-1,j),f(i-1,j-1))+T[i][j]</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal1</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[size][size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i][j] = triangle.get(i).get(j);</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i == j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : dp[size - <span class="number">1</span>]) &#123;</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度空间复杂度都为O(n^2)。</strong></p>
<p>优化时间复杂度：</p>
<p>计算f(i,j)时只需要f(i-1,j-1)，f(i-1,j)的值。因为需要左上角的值，所以计算完f(i,j)不能直接覆盖f(i-1,j)的值。但是可以从右往左计算，就可以避免这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal2</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.size()];</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; row : triangle) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = row.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = row.get(j) + dp[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == row.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[j] = row.get(j) + dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j - <span class="number">1</span>]) + row.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : dp) &#123;</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度O(n^2)，空间复杂度降为O(n)。</strong></p>
<h3 id="101-分割等和子集"><a href="#101-分割等和子集" class="headerlink" title="#101 分割等和子集"></a>#101 分割等和子集</h3><p>给定一个非空的正整数数组，请判断能否将这些数字分成和相等的两部分。</p>
<p>例如，如果输入数组为[3,4,1]，将这些数字分成[3,1]和[4]两部分，它们的和相等，因此输出true；如果输入数组为[1,2,3,5]，则不能将这些数字分成和相等的两部分，因此输出false。</p>
<p>分析：</p>
<p>如果能将数组中的数字分成和相等的两部分，那么数组中所有数字的和(记为sum)应该是一个偶数。</p>
<p>可以换一个角度来描述这个问题：能否从数组中选出若干数字，使它们的和等于sum/2。由于每个数字最多只能选择一次，因此这是一个0-1背包问题。</p>
<p>确定状态转移方程。可以用函数f(i,j)表示能否从前i个物品中选择若干物品放满容量为j的背包。如果总共有n个物品，背包的容量为t，那么f(n,t)就是问题的解。分情况确定状态转移方程：</p>
<ul>
<li>当j=0，即背包容量为0，不管有多少个物品，只要什么物品都不选择，就能使选中的物品的总重量为0，因此f(i,0)都为true。</li>
<li>当i=0，j&gt;0时，即物品的数量为0，肯定无法用0个物品来放慢容量大于0的背包，因此f(0,j)都为false。</li>
<li>其他情况，对于标号为i-1的物品有两个选择：<ul>
<li>将标号i-1的物品放入背包：f(i,j)=f(i-1, j - nums[i-1])</li>
<li>不将标号i-1的物品放入背包：f(i,j)=f(i-1,j)</li>
</ul>
</li>
</ul>
<p>根据状态转移方程写递归代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subsetSum(nums, sum / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[nums.length + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> helper(nums, dp, nums.length, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, Boolean[][] dp, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = helper(nums, dp, i - <span class="number">1</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (!dp[i][j] &amp;&amp; j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = helper(nums, dp, i - <span class="number">1</span>, j - nums[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度空间复杂度都为O(nt)。</strong></p>
<p>根据状态转移方程写迭代代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">subsetSum2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (!dp[i][j] &amp;&amp; j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[nums.length][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度和空间复杂度都是O(nt)。</strong></p>
<p>优化空间效率：</p>
<p>计算f(i,j)时只需要用到i-1行的值，而且都是&lt;=j列的值，因此可以只用一个一维数组，从右向左完成运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">subsetSum3</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[j] &amp;&amp; j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[j] = dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间复杂度降为O(t)</strong></p>
<h3 id="102-加减的目标值"><a href="#102-加减的目标值" class="headerlink" title="#102 加减的目标值"></a>#102 加减的目标值</h3><p>给定一个非空的正整数数组和一个目标值S，如果为每个数字添加”+”或”-“运算符，请计算有多少种方法可以使这些整数的计算结果为S。</p>
<p>例如，如果输入数组[2,2,2]并且S=2，有三种方法使结果为2：2+2-2；2-2+2；-2+2+2</p>
<p>分析：</p>
<p>假设所有需要添加”+”的数字之和为p，所有添加”-“的数字之和为q，按照题目要求p-q=S。又p+q=sum，所以p=(S+num)/2。因此这个题目等价于从计算数组中选出和为(S+sum)/2的数字的方法的数目。</p>
<p>确定状态转移方程：f(i,j)=</p>
<ul>
<li>1    j==0</li>
<li>0    i==0 &amp;&amp; j&gt;0</li>
<li>f(i-1,j) + f(i-1,j-nums[i])    i&gt;0 &amp;&amp; j &gt; nums[j]</li>
</ul>
<p>直接给出优化空间复杂度后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sum + S) % <span class="number">2</span> == <span class="number">1</span> || sum &lt; S) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subsetSum(nums, (sum + S) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= num; j--) &#123;</span><br><span class="line">            dp[j] = dp[j] + dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度为O(nt)，空间复杂度为O(t)。</strong></p>
<h3 id="103-最少的硬币数目"><a href="#103-最少的硬币数目" class="headerlink" title="#103 最少的硬币数目"></a>#103 最少的硬币数目</h3><p>给定正整数数组coins表示硬币的面额和一个目标总额t，请计算凑出总额t至少需要的硬币数目。每种硬币可以使用任意多枚。如果不能用输入的硬币凑出给定的总额，则返回-1。</p>
<p>例如，如果硬币的面额为[1,3,9,10]，总额t为15，那么至少需要3枚硬币，2 * 3 + 9</p>
<p>分析：</p>
<p>用f(i,j)表示用前i种硬币凑出总额为j需要的硬币的最少数目。</p>
<p>f(i,j)=min(f(i-1),j-k*coins[i-1]+k)(k*coins[i-1]&lt;=j)</p>
<p>当j=0，f(i,0)都等于0，即从前i种硬币中选出0个硬币，使总额等于0。</p>
<p>当i=0且j&gt;0时，显然是不可能的，可以用特殊值表示。</p>
<p>直接给出优化空间复杂度后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange1</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, target + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * coin &lt;= j; k++) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j - k * coin] + k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target] &gt; target ? -<span class="number">1</span> : dp[target];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度O(ntk)，空间复杂度O(t)。</strong>n是硬币类数，t是目标总额</p>
<p>换一种思路：</p>
<p>用函数f(i)表示凑出总额为i的硬币需要的最少数目。</p>
<p>f(i)=min(f(i-coins[j])+1)(coins[j]&lt;=i)</p>
<p>f(0)=0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange2</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        dp[i] = target + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target] &gt; target ? -<span class="number">1</span> : dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度O(nt)，空间复杂度O(t)。</strong>n是硬币类数，t是目标总额</p>
<h3 id="104-排列的数目"><a href="#104-排列的数目" class="headerlink" title="#104 排列的数目"></a>#104 排列的数目</h3><p>给定一个非空的正整数数组nums和一个目标值t，数组中的所有数字都是唯一的，请计算数字之和等于t的所有排列的数目。数组中的数字可以在排列中出现任意次。</p>
<p>例如，输入数组[1,2,3]，目标值t为3，那么总共有4个组合的数字之和等于3。分别为{1,1,1}、{1，2}、{2，1}、{3}。</p>
<p>分析：</p>
<p>用f(i)表示和为i的排列的数目。</p>
<p>f(i)=sumOf(i-nums[j])(nums[j]&lt;=i)</p>
<p>f(0)=1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">permutationSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= num) &#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**时间复杂度O(nt)，空间复杂度O(t)**。n为输入数组的长度，t为排列的目标和。</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="105-最大的岛屿"><a href="#105-最大的岛屿" class="headerlink" title="#105 最大的岛屿"></a>#105 最大的岛屿</h3><p>海洋岛屿地图可以用0、1组成的二维数组表示，水平或竖直方向相连的一组1表示一个岛屿，请计算最大岛屿的面积(即岛屿中1的数目)。</p>
<p>分析：</p>
<p>可以逐一扫描矩阵中的每个格子，如果遇到一个值为1的格子并且不在之前已知的岛屿上，那么久到达了一个新的岛屿，于是搜索这个岛屿并计算它的面积。在比较所有岛屿的面积之后就可以知道最大的岛屿的面积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> area = getArea(grid, visited, i, j);</span><br><span class="line">                maxArea = Math.max(maxArea, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码创建了一个和输入矩阵相同大小的矩阵visited，它的作用是用一个布尔值标识矩阵中的每个值为1的格子是否已经到达过，用来确保每个格子只搜索一次。</p>
<p>getArea方法需要搜索整个连通子图可以得到节点的数目，因此这是一个典型的图的搜索问题。</p>
<p>基于队列的广度优先搜索：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea1</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pos = queue.remove();</span><br><span class="line">        area++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = pos[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = pos[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length</span><br><span class="line">                &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length</span><br><span class="line">                &amp;&amp; grid[r][c] == <span class="number">1</span> &amp;&amp; visited[r][c]) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c&#125;);</span><br><span class="line">                visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>基于栈的深度优先搜索：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getArea2</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>[]&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pos = stack.pop();</span><br><span class="line">        area++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = pos[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = pos[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length</span><br><span class="line">                &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length</span><br><span class="line">                &amp;&amp; grid[r][c] == <span class="number">1</span> &amp;&amp; !visited[r][c]) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c&#125;);</span><br><span class="line">                visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>基于递归实现深度优先搜索：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getArea3</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">1</span>;</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> c = j + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length</span><br><span class="line">            &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length</span><br><span class="line">            &amp;&amp; grid[r][c] == <span class="number">1</span> &amp;&amp; !visited[r][c]) &#123;</span><br><span class="line">            area += getArea3(grid, visited, r, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个图的节点数目为v，边的数目为e，那么在该图上进行广度优先搜索和深度优先搜索的时间复杂度都是O(v+e)。</p>
<p>此题中节点数和边数都是O(mn)，因此**时间复杂度也是O(mn)**。</p>
<p>**空间复杂度为O(mn)**。</p>
<h3 id="106-二分图"><a href="#106-二分图" class="headerlink" title="#106 二分图"></a>#106 二分图</h3><p>如果能将一个图中的节点分成A、B两个部分，使任意一条边的一个节点属于A而另一个节点属于B，那么该图就是一个二分图。输入一个由数组graph表示的图，graph[i]中包含所有和节点i相邻的节点，请判断该图是否为二分图。</p>
<p>分析：</p>
<p>二分图的节点可以分成两种不同的类型，任意一条边的两个节点分别属于两种不同的类型。可以为图中的所有节点着色，两种不同类型的节点分别涂上不同的颜色。如果任意一条边的两个节点都能被涂上不同的颜色，那么整个图就是一个二分图。</p>
<p>一个图可能包含多个连通子图，逐一对每个子图的节点着色。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = graph.length;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    Arrays.fill(colors, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!setColor(graph, colors, i, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码创建了一个长度为n的数组colors记录每个节点的颜色，节点i的颜色保存在colors[i]中。如果节点i还没有被着色，那么colors[i]的值为-1；如果节点i已经被着色，那么colors[i]的值为0或1。</p>
<p>利用广度优先搜索对子图着色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setColor1</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] colors, <span class="keyword">int</span> i, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(i);</span><br><span class="line">    colors[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = queue.remove();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colors[neighbor] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (colors[neighbor] == colors[v]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.add(neighbor);</span><br><span class="line">                colors[neighbor] = <span class="number">1</span> - colors[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>利用深度优先搜索对子图着色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setColor2</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] colors, <span class="keyword">int</span> i, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已经被着色，且正好是想要的颜色</span></span><br><span class="line">    <span class="keyword">if</span> (colors[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> colors[i] == color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    colors[i] = color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!setColor2(graph, colors, neighbor, <span class="number">1</span> - color)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所有算法的时间复杂度均为O(v+e)</strong></p>
<h3 id="107-矩阵中的距离"><a href="#107-矩阵中的距离" class="headerlink" title="#107 矩阵中的距离"></a>#107 矩阵中的距离</h3><p>输入一个由0、1组成的矩阵M，请输出一个大小相同的矩阵D，矩阵D中的每个格子是矩阵M中对应格子离最近的0的距离。水平或竖直方向相邻的两个格子的距离为1。假设矩阵M中至少有一个0。</p>
<p>分析：</p>
<p>要求计算每个格子离0最近的距离。根据题目要求，上下左右相邻的两个格子的距离为1。可以将图看成一个无权图，这个题与无权图的最近距离相关，因此可以考虑应用广度优先搜索解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dists = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                dists[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dists[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pos = queue.remove();</span><br><span class="line">        <span class="keyword">int</span> dist = dists[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = pos[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = pos[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt; rows &amp;&amp; c &lt; cols) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dists[r][c] &gt; dist + <span class="number">1</span>) &#123;</span><br><span class="line">                    dists[r][c] = dist + <span class="number">1</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广度优先搜索能够保证从起始节点到达任意节点一定是沿着最短路径的，因此可以通过用“dist[r][c] &gt; dist + 1”避免重复访问某个格子。</p>
<h3 id="108-单词演变"><a href="#108-单词演变" class="headerlink" title="#108 单词演变"></a>#108 单词演变</h3><p>输入两个长度相同但内容不同的单词(beginWord和endWord)和一个单词列表，求从beginWord到endWord的演变序列的最短长度，要求每步只能改变单词中的一个字母，并且演变过程中每步得到的单词都必须在给定的单词列表中。如果不能从beginWord演变到endWord，则返回0。假设所有单词只包含英文小写字母。</p>
<p>分析：</p>
<p>应用图相关算法的前提是找出图中的节点和边。这个问题是关于单词的演变的，所以每个单词就是图中的一个节点。如果两个单词能相互演变，那他们之间有一条边相连。</p>
<p>又是求无权图的最短路径，想到用广度优先搜索。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength1</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; notVisited = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    queue1.add(beginWord);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        String word = queue1.remove();</span><br><span class="line">        <span class="keyword">if</span> (word.equals(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; neighbors = getNeighbors(word);</span><br><span class="line">        <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (notVisited.contains(neighbor)) &#123;</span><br><span class="line">                queue2.add(neighbor);</span><br><span class="line">                notVisited.remove(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回所有可能的neighbor</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; neighbors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> old = chars[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>; ch &lt;= <span class="string">&#x27;z&#x27;</span>; ch++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (old != ch) &#123;</span><br><span class="line">                chars[i] = ch;</span><br><span class="line">                neighbors.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chars[i] = old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>！！双向广度优先搜索：</strong></p>
<p>这个题目时关于单一起始节点、单一目标节点的最短路径问题。前面的解法是从起始节点出发不断朝着目标节点的方向搜索，直到到达目标节点。针对这类问题有一种常见的优化方法，即在从起始节点出发不断朝着目标节点的方向搜索的同时，也从目标节点出发不断朝着起始节点的方向搜索。这种双向搜索的方法能够缩小搜索空间，从而提高搜索的时间效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength2</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; notVisited = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    <span class="keyword">if</span> (!notVisited.contains(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">    set1.add(beginWord);</span><br><span class="line">    set2.add(endWord);</span><br><span class="line">    notVisited.remove(endWord);</span><br><span class="line">    <span class="keyword">while</span> (!set1.isEmpty() &amp;&amp; !set2.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 保证set1是size更大的集合</span></span><br><span class="line">        <span class="comment">// 也是双向搜索的保证</span></span><br><span class="line">        <span class="keyword">if</span> (set2.size() &lt; set1.size()) &#123;</span><br><span class="line">            Set&lt;String&gt; temp = set1;</span><br><span class="line">            set1 = set2;</span><br><span class="line">            set2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set3 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : set1) &#123;</span><br><span class="line">            List&lt;String&gt; neighbors = getNeighbors(word);</span><br><span class="line">            <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set2.contains(neighbor)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> length;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (notVisited.contains(neighbor)) &#123;</span><br><span class="line">                    set3.add(neighbor);</span><br><span class="line">                    notVisited.remove(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length++;</span><br><span class="line">        set1 = set3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="109-开密码锁"><a href="#109-开密码锁" class="headerlink" title="#109 开密码锁"></a>#109 开密码锁</h3><p>一个密码锁由4个环形转轮组成，每个转轮由0~9这10个数字组成。每次可以上下拨动一个转轮，如果可以将一个转轮从0拨到1，也可以从0拨到9。密码锁有若干死锁状态，一旦4个转轮被拨到某个死锁状态，这个锁就不可能打开。密码锁的状态可以用一个长度为4的字符串表示，字符串中的每个字符对应某个转轮上的数字。输入密码锁的密码和它的所有死锁状态，请问至少需要拨动转轮多少次才能从起始状态”0000”开始打开这个密码锁？如果锁不能打开，请返回-1。</p>
<p>分析：</p>
<p>首先要构建一个图。密码锁的每个状态都对应着图中的一个节点，如果转动某个转轮一次可以让密码锁从一个状态转移到另一个状态，那么这两个状态之间有一条边相连。</p>
<p>因为要搜索最少拨动的次数，所以想到用广度优先搜索。搜索时还要避开死锁状态对应的系欸但，因为一旦到达这些节点后就不能继续向下搜索。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; dead = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(deadends));</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    String init = <span class="string">&quot;0000&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (dead.contains(init) || dead.contains(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;String&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    queue1.offer(init);</span><br><span class="line">    visited.add(init);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        String cur = queue1.remove();</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> steps;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; nexts = getNeighbors(cur);</span><br><span class="line">        <span class="keyword">for</span> (String next : nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dead.contains(next) &amp;&amp; !visited.contains(next)) &#123;</span><br><span class="line">                queue2.add(next);</span><br><span class="line">                visited.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            steps++;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String cur)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; nexts = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = cur.charAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> newCh = ch == <span class="string">&#x27;0&#x27;</span> ? <span class="string">&#x27;9&#x27;</span> : (<span class="keyword">char</span>)(ch - <span class="number">1</span>);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(cur);</span><br><span class="line">        builder.setCharAt(i, newCh);</span><br><span class="line">        nexts.add(builder.toString());</span><br><span class="line"></span><br><span class="line">        newCh = ch == <span class="string">&#x27;9&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : (<span class="keyword">char</span>)(ch + <span class="number">1</span>);</span><br><span class="line">        builder.setCharAt(i, newCh);</span><br><span class="line">        nexts.add(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nexts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码实现的是单向广度优先搜索。同样也可以用双向广度优先搜索来解决这个问题。请自行尝试。</p>
<h3 id="110-所有路径"><a href="#110-所有路径" class="headerlink" title="#110 所有路径"></a>#110 所有路径</h3><p>一个有向无环图由n个节点(标号从0到n-1，n&gt;=2)组成，请找出从节点0到节点n-1的所有路径。图用一个数组graph表示，数组的graph[i]包含所有从节点i直接到达的节点。</p>
<p>例如，输入数组graph为[[1,2],[3],[3],[]]，则输出两条从节点0到节点3路径，分别为0-&gt;1-&gt;3和0-&gt;2-&gt;3。</p>
<p>分析：</p>
<p>题目要求找出有向无环图中从节点0到节点n-1的所有路径，自然需要搜索图中的所有节点。由于题目要求列出从节点0到节点n-1的所有路径，因此深度优先搜索是更合适的选择。</p>
<p>深度优先搜索通常用递归实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    dfs(<span class="number">0</span>, graph, path, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span>[][] graph, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    path.add(source);</span><br><span class="line">    <span class="keyword">if</span> (source == graph.length - <span class="number">1</span>) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(path));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[source]) &#123;</span><br><span class="line">            dfs(next, graph, path, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯思想</span></span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的实现和回溯法代码很像，这是因为回溯法从本质上来说就是深度优先搜索。</p>
<h3 id="111-计算除法"><a href="#111-计算除法" class="headerlink" title="#111 计算除法"></a>#111 计算除法</h3><p>输入两个数组equations和values，其中，数组equations的每个元素包含两个表示变量名字的字符串，数组values的每个元素是一个浮点数值。如果equations[i]的两个变量名分别是Ai和Bi，那么Ai/Bi=values[i]。再给点一个数组queries，它的每个元素也包含两个变量名。对于queries[j]的两个变量名Ci和Di，请计算Ci和Di的结果。假设任意values[i]大于0。如果不能计算，那么返回-1。</p>
<p>例如，数组equations为[[“a”, “b”], [“b”, “c”]]，数组values为[2.0, 3.0]，数组queries为[[“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”]]，那么对应的计算结果为[6.0, 0.5, -1.0, 1.0, -1.0]。</p>
<p>分析：</p>
<p>首先根据数组equations和values构建出对应的图。因为a/b=2.0，所以图中有一条从节点a到节点b的边，权重为2.0。由数学常识可知b/a=1/2，所以图中还有一条由节点b指向节点a的权重为1/2的边。其他节点同理。</p>
<p>接下来考虑如何计算除法。已知a/b=2.0，b/c=3.0，那么a/c=6.0，计算过程等价于找到一条从a-&gt;c的路径，并将边上的权重相乘。因此，这个问题从本质上来说还是一个图搜索问题，由于需要记录从一个节点到另一个节点的路径，深度优先搜索比较合适。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">    Map&lt;String, Map&lt;String, Double&gt;&gt; graph = buildGraph(equations, values);</span><br><span class="line">    <span class="keyword">double</span>[] results = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">        String from = queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">        String to = queries.get(i).get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!graph.containsKey(from) || graph.containsKey(to)) &#123;</span><br><span class="line">            results[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            results[i] = dfs(graph, from, to, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Map&lt;String, Double&gt;&gt; buildGraph(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values) &#123;</span><br><span class="line">    Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">        String var1 = equations.get(i).get(<span class="number">0</span>);</span><br><span class="line">        String var2 = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        graph.putIfAbsent(var1, <span class="keyword">new</span> HashMap&lt;String, Double&gt;());</span><br><span class="line">        graph.get(var1).put(var2, values[i]);</span><br><span class="line"></span><br><span class="line">        graph.putIfAbsent(var2, <span class="keyword">new</span> HashMap&lt;String, Double&gt;());</span><br><span class="line">        graph.get(var2).put(var1, <span class="number">1.0</span> / values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">dfs</span><span class="params">(Map&lt;String, Map&lt;String, Double&gt;&gt; graph, String from, String to, Set&lt;String&gt; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (from.equals(to)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited.add(from);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; entry : graph.get(from).entrySet()) &#123;</span><br><span class="line">        String next = entry.getKey();</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">            <span class="keyword">double</span> nextValue = dfs(graph, next, to, visited);</span><br><span class="line">            <span class="keyword">if</span> (nextValue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getValue() * nextValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited.remove(from);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="112-最长的递增路径"><a href="#112-最长的递增路径" class="headerlink" title="#112 最长的递增路径"></a>#112 最长的递增路径</h3><p>输入一个整数矩阵，请求最长递增路径的长度。矩阵中的路径沿着上、下、左、右4个方向前行。</p>
<p>分析：</p>
<p>求最长递增路径的长度，深度优先搜索比较适合。</p>
<p>因为不知道从哪个节点开始的递增路径是最长的，所以试着找出从矩阵的每个数字出发的最长递增路径的长度，通过比较可以得出整个矩阵中的最长递增路径的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] lengths = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = dfs(matrix, lengths, i, j);</span><br><span class="line">            longest = Math.max(longest, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[][] lengths, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lengths[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lengths[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> c = j + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; rows &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; cols</span><br><span class="line">            &amp;&amp; matrix[r][c] &gt; matrix[i][j]) &#123;</span><br><span class="line">            <span class="keyword">int</span> path = dfs(matrix, lengths, r, c);</span><br><span class="line">            length = Math.max(path + <span class="number">1</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lengths[i][j] = length;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="#拓扑排序"></a>#拓扑排序</h3><p>拓扑排序是指对一个有向无环图的节点进行排序之后得到的序列。如果存在一条从节点A指向节点B的边，那么在拓扑排序的序列中节点A出现在节点B的前面。一个有向无环图可以有一个或多个拓扑排序序列，但无向图或有环的有向图都不存在拓扑排序。</p>
<p>一种常用的拓扑排序算法是每次从有向无环图中取出一个入度为0的节点添加到拓扑排序的序列之中，然后删除该节点及所有以它为起点的边。重复这个步骤，直到图为空或图中不存在入度为0的节点。如果最终图为空，那么图是有向无环图，此时就找到了该图的一个拓扑排序序列。如果最终图不为空并且已经不存在入度为0的节点，那么图中一定有环。</p>
<h3 id="113-课程顺序"><a href="#113-课程顺序" class="headerlink" title="#113 课程顺序"></a>#113 课程顺序</h3><p>n门课程的编号为0~n-1。输入一个数组prerequisites，它的每个元素prerequisites[i]表示两门课程的先修顺序。如果prerequisites[i]=[ai, bi]，那么必须先修完bi才能修ai。请根据总课程数n和表示先修顺序的prerequisites得出一个可行的修课序列。如果有多个可行的修课序列，则输出任意一个可行的序列；如果没有可行的修课序列，则输出空序列。</p>
<p>例如，总共有4门课程，先修顺序prerequisites为[[1,0], [2,0], [3,1], [3,2]]，一个可行的修课序列是0-&gt;2-&gt;1-&gt;3。</p>
<p>分析：</p>
<p>将课程看成图中的节点，如果两门课程存在先修顺序，那么它们在图中对应的节点之间存在一条从先修课程到后修课程的边，因此这是一个有向图。可行的修课序列实际上是图的拓扑排序序列。拓扑排序得到的序列与先修顺序一定不会存在冲突，于是这个问题转变成如何求有向图的拓扑排序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] inDegrees = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] prereq : prerequisites) &#123;</span><br><span class="line">        graph.get(prereq[<span class="number">1</span>]).add(prereq[<span class="number">0</span>]);</span><br><span class="line">        inDegrees[prereq[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; order = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> course = queue.remove();</span><br><span class="line">        order.add(course);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(course)) &#123;</span><br><span class="line">            inDegrees[next]--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inDegrees[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order.size() == numCourses </span><br><span class="line">        ? order.stream().mapToInt(i-&gt;i).toArray() </span><br><span class="line">        : <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图中节点数目为m，边数为n，**拓扑排序的时间复杂度为O(m+n)**。</p>
<h3 id="114-外星文字典"><a href="#114-外星文字典" class="headerlink" title="#114 外星文字典"></a>#114 外星文字典</h3><p>一种外星语言的字母都是英文字母，但字母的顺序未知。给定该语言的单词列表，请推测可能的字母顺序。如果有多个可能的顺序，则返回任意一个。如果没有满足条件的字母顺序，则返回空字符串。</p>
<p>例如，如果输入排序的单词列表为[“ac”, “ab”, “bc”, “zc”, “zb”]。</p>
<p>分析：</p>
<p>与#113类似，可以把此题转换为求拓扑排序的问题。图的节点为字母，单词”ac”&lt;”ab”前，则’c’&lt;’b’，有一条从c-&gt;b的有向边。”ac”&lt;”bc”，则’a’&lt;’b’，有一条从a-&gt;b的有向边。以此类推。构建完图后，求解拓扑排序，即为此题的解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; inDegrees = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            graph.putIfAbsent(ch, <span class="keyword">new</span> HashSet&lt;Character&gt;());</span><br><span class="line">            inDegrees.putIfAbsent(ch, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        String w1 = words[i - <span class="number">1</span>];</span><br><span class="line">        String w2 = words[i];</span><br><span class="line">        <span class="keyword">if</span> (w1.startsWith(w2) &amp;&amp; !w1.equals(w2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w1.length() &amp;&amp; j &lt; w2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = w1.charAt(j);</span><br><span class="line">            <span class="keyword">char</span> ch2 = w2.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (ch1 != ch2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!graph.get(ch1).contains(ch2)) &#123;</span><br><span class="line">                    graph.get(ch1).add(ch2);</span><br><span class="line">                    inDegrees.put(ch2, inDegrees.get(ch2) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : inDegrees.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees.get(ch) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = queue.remove();</span><br><span class="line">        sb.append(ch);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> next : graph.get(ch)) &#123;</span><br><span class="line">            inDegrees.putIfAbsent(next, inDegrees.get(next) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegrees.get(next) == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.length() == graph.size() ? sb.toString() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中并没有把所有单词之间两两比较，而是值比较相邻的单词，从头找出第1组不同的两个字母，在图中添加一条较小字母指向较大字母的边。</p>
<p>有一类特殊的输入需要特别注意。如果排在后面的单词是排在前面的单词的前缀，那么无论什么样的字母顺序都是不可能的。例如，如果排序的单词列表是[“abc”, “ab”]，不管是什么样子的字母顺序，”abc”都不可能在”ab”前面，因此这是一个无效输入，可以直接返回空字符串列表表示无效的字母顺序。</p>
<h3 id="115-重建序列"><a href="#115-重建序列" class="headerlink" title="#115 重建序列"></a>#115 重建序列</h3><p>长度为n的数组org是数字1~n的一个排列，seqs是若干序列，请判断数组org是否可以由seqs重建的唯一序列。重建的序列是指seqs所有序列的最短公共超序列，即seqs中的任意序列都是该序列的子序列。</p>
<p>例如，如果数组org为[4,1,5,2,6,3]，而seqs为[[5,2,6,3], [4,1,5,2]], 因为用[[5,2,6,3], [4,1,5,2]]可以重建出唯一的序列[4,1,5,2,6,3], 所以返回true。如果数组org为[1,2,3]，而seqs为[[1,2], [1,3]]，因为用[[1,2], [1,3]]可以重建出两个序列, [1,2,3]或[1,3,2]，所以返回false。</p>
<p>分析：</p>
<p>可以将seqs中每个序列的每个数字看成图中的一个节点，两个相邻的数字之间有一条从前面数字指向后面数字的边。然后，这个问题就转变成一个判断一个有向图的拓扑排序序列是否唯一，即同一时刻，只能有一个入度为0的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sequenceReconstruction</span><span class="params">(<span class="keyword">int</span>[] org, List&lt;List&lt;Integer&gt;&gt; seqs)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegrees = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; seq : seqs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : seq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">1</span> || num &gt; org.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            graph.putIfAbsent(num, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            inDegrees.putIfAbsent(num, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = seq.get(i);</span><br><span class="line">            <span class="keyword">int</span> num2 = seq.get(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!graph.get(num1).contains(num2)) &#123;</span><br><span class="line">                graph.get(num1).add(num2);</span><br><span class="line">                inDegrees.put(num2, inDegrees.get(num2) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : inDegrees.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees.get(num) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; built = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (queue.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = queue.remove();</span><br><span class="line">        built.add(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(num)) &#123;</span><br><span class="line">            inDegrees.put(next, inDegrees.get(next) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegrees.get(next) == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[built.size()];</span><br><span class="line">    result = built.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(result, org);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="并查集"><a href="#并查集" class="headerlink" title="#并查集"></a>#并查集</h3><p>并查集是一种树形的数据结构，用来表示不相交集合的数据。并查集中的每个子集是一棵树，每个元素是某棵树中的一个节点。树中的每个节点有一个指向父节点的指针，树的根节点的指针指向它自己。</p>
<p>并查集支持两种操作，即合并和查找。</p>
<ul>
<li>合并：将两个子集合并成一个集合，只需要将一个子集对应的树的根节点的指针指向另一个子集对应的树的根节点</li>
<li>查找：确定某个元素v处于哪个子集中。并查集中的子集由对应的树的根节点代表。从元素v对应的节点开始沿着指向父节点的指针一直找到树的根节点，即节点的祖先节点。</li>
</ul>
<p><strong>并查集经常用来解决图的动态连接问题。</strong></p>
<h3 id="116-朋友圈"><a href="#116-朋友圈" class="headerlink" title="#116 朋友圈"></a>#116 朋友圈</h3><p>假设一个班级中由n个学生。学生之间有些是朋友，有些不是。朋友关系是可以传递的。例如，A是B的直接朋友，B是C的直接朋友，那么A是C的间接朋友。定义朋友圈就是一组直接朋友或间接朋友的学生。输入一个nxn的矩阵M表示班上的朋友关系，如果M[i][j]=1，那么学生i和学生j是直接朋友。请计算该班级中朋友圈的数目。</p>
<p>图的搜索算法可以用来计算图中子图的数目。扫描图中所有的节点。如果某个节点v之前没有访问过，就搜索他所在的子图。当所有节点都访问完之后，就可以知道图中有多少个子图。广度优先搜索和深度优先搜索都可以用来计算图中子图的数目。基于广度优先搜索的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[M.length];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            findCircle(M, visited, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findCircle</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(i);</span><br><span class="line">    visited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = queue.remove();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> friend = <span class="number">0</span>; friend &lt; M.length; friend++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[t][friend] == <span class="number">1</span> &amp;&amp; !visited[friend]) &#123;</span><br><span class="line">                queue.add(friend);</span><br><span class="line">                visited[friend] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果班级中有n个学生，那么图中有n个节点和O(n^2)条边，广度优先搜索的时间复杂度是O(n^2)。</p>
<p>应用并查集：</p>
<p>创建长度为n的数组fathers存储n个节点的父节点。有了这个数组fathers，如果想知道节点i所在的子集的根节点，就可以从节点i开始沿着指向父节点的指针搜索，时间复杂度看起来是O(n)，但可以将从i到根节点的路径压缩，从而优化时间效率。</p>
<p>我们真正关心的是节点i的根节点是谁而不是它的父节点，因此可以在fathers[i]中存储它的根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] fathers = <span class="keyword">new</span> <span class="keyword">int</span>[M.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fathers.length; i++) &#123;</span><br><span class="line">        fathers[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = M.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span> &amp;&amp; union(fathers, i, j)) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fathers[i] != i) &#123;</span><br><span class="line">        fathers[i] = findFather(fathers, fathers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fathers[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fatherOfI = findFather(fathers, i);</span><br><span class="line">    <span class="keyword">int</span> fatherOfJ = findFather(fathers, j);</span><br><span class="line">    <span class="keyword">if</span> (fatherOfI != fatherOfJ) &#123;</span><br><span class="line">        fathers[fatherOfI] = fatherOfJ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总时间复杂度O(n^2)。</strong></p>
<h3 id="117-相似的字符串"><a href="#117-相似的字符串" class="headerlink" title="#117 相似的字符串"></a>#117 相似的字符串</h3><p>如果交换字符串X中的两个字符就能得到字符串Y，那么两个字符串X和Y相似。例如，字符串”tars”和”rats”相似(交换下标为0和2的两个字符)、字符串”rats”和”arts”相似(交换下标为0和1的字符)，但字符串”star”和”tars”不相似。</p>
<p>输入一个字符串数组，根据字符串的相似性分组，请问能把输入数组分成几组？如果一个字符串至少和一组字符串中的一个相似，那么它就可以放到该组中。假设输入数组中的所有字符串的长度相同并且两两互为变位词。</p>
<p>例如，输入数组为[“tars”, “rats”, “arts”, “star”]，可以分成两组，一组为{“tars”, “rats”, “arts”}, 另一组为{“star”}。</p>
<p>分析：解法与#116类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] fathers = <span class="keyword">new</span> <span class="keyword">int</span> [A.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fathers.length; i++) &#123;</span><br><span class="line">        fathers[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> groups = A.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (similar(A[i], A[j]) &amp;&amp; union(fathers, i, j)) &#123;</span><br><span class="line">                groups--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> groups;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">similar</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> diffCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1.charAt(i) != str2.charAt(i)) &#123;</span><br><span class="line">            diffCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diffCount &lt;= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fathers[i] != i) &#123;</span><br><span class="line">        fathers[i] = findFather(fathers, fathers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fathers[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fatherOfI = findFather(fathers, i);</span><br><span class="line">    <span class="keyword">int</span> fatherOfJ = findFather(fathers, j);</span><br><span class="line">    <span class="keyword">if</span> (fatherOfI != fatherOfJ) &#123;</span><br><span class="line">        fathers[fatherOfI] = fatherOfJ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="118-多余的边"><a href="#118-多余的边" class="headerlink" title="#118 多余的边"></a>#118 多余的边</h3><p>树可以看成无环的无向图。在一个包含n个节点(节点标号为从1到n)的树中添加一条边连接任意两个节点，这棵树就会变成一个有环的图。给定一个在树中添加了一条边的图，请找出这条多余的边(用这条边连接的两个节点表示)。输入的图用一个二维数组edges表示，数组中的每个元素是一条边的两个节点[u,v](u&lt;v)。如果有多个答案，请输出在数组edges中最后出现的边。</p>
<p>分析：</p>
<p>如果两个节点分别属于两个不同的子图，添加一条边连接这两个节点，会将他们所在的子图连接在一起，但不会形成环。如果两个节点同属于一个子图，添加一条边连接这两个节点就会形成一个环。</p>
<p>因此，为了遭到多余的边需要解决两个问题：一是如何判断两个节点是否属于同一个子图，二是如何合并两个子图。并查集刚好可以解决这两个问题，由此可见，这是一个适合用并查集解决的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxVertex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        maxVertex = Math.max(maxVertex, edge[<span class="number">0</span>]);</span><br><span class="line">        maxVertex = Math.max(maxVertex, edge[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] fathers = <span class="keyword">new</span> <span class="keyword">int</span>[maxVertex + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxVertex; i++) &#123;</span><br><span class="line">        fathers[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!union(fathers, edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> edge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fathers[i] != i) &#123;</span><br><span class="line">        fathers[i] = findFather(fathers, fathers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fathers[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] fathers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fatherOfI = findFather(fathers, i);</span><br><span class="line">    <span class="keyword">int</span> fatherOfJ = findFather(fathers, j);</span><br><span class="line">    <span class="keyword">if</span> (fatherOfI != fatherOfJ) &#123;</span><br><span class="line">        fathers[fatherOfI] = fatherOfJ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度O(n)。</strong></p>
<h3 id="119-最长连续序列"><a href="#119-最长连续序列" class="headerlink" title="#119 最长连续序列"></a>#119 最长连续序列</h3><p>输入一个无序的整数数组，请计算最长的连续数值序列的长度。</p>
<p>例如，输入数组[10, 5, 9, 2, 4, 3]，则最长的连续数值序列是[2, 3, 4, 5]，因此输出4。</p>
<p>分析：</p>
<p>如果把数组中每个数值当作一个节点，相邻的整数组成一个岛屿，那么连续整数的数目就是岛屿的面积。可以通过广度优先搜索或深度优先搜索求最大岛屿的面积。</p>
<p>基于广度优先搜索：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!set.isEmpty()) &#123;</span><br><span class="line">        Iterator&lt;Integer&gt; iter = set.iterator();</span><br><span class="line">        longest = Math.max(longest, bfs(set, iter.next()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(Set&lt;Integer&gt; set, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(num);</span><br><span class="line">    set.remove(num);</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = queue.poll();</span><br><span class="line">        <span class="keyword">int</span>[] neighbors = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i - <span class="number">1</span>, i + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(neighbor)) &#123;</span><br><span class="line">                queue.offer(neighbor);</span><br><span class="line">                set.remove(neighbor);</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>应用并查集解决问题：</p>
<p>在初始化并查集的时候输入数组中的每个整数放入一个子集中，父节点的指针指向它子集。然后对于每个整数n，如果存在整数n-1和n+1，则将他们所在的子集合并。每个子集的根节点记录它所在子集的元素的数目，在合并子集的时候需要更新合并之后新子集的根节点中子集元素的数目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; fathers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; all = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        fathers.put(num, num);</span><br><span class="line">        counts.put(num, <span class="number">1</span>);</span><br><span class="line">        all.add(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (all.contains(num + <span class="number">1</span>)) &#123;</span><br><span class="line">            union(fathers, counts, num, num + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (all.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            union(fathers, counts, num, num - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> length : counts.values()) &#123;</span><br><span class="line">        longest = Math.max(longest, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFather</span><span class="params">(Map&lt;Integer, Integer&gt; fathers, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fathers.get(i) != i) &#123;</span><br><span class="line">        fathers.put(i, findFather(fathers, fathers.get(i)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fathers.get(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Map&lt;Integer, Integer&gt; fathers, Map&lt;Integer, Integer&gt; counts, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fatherOfI = findFather(fathers, i);</span><br><span class="line">    <span class="keyword">int</span> fatherOfJ = findFather(fathers, j);</span><br><span class="line">    <span class="keyword">if</span> (fatherOfI != fatherOfJ) &#123;</span><br><span class="line">        fathers.put(fatherOfI, fatherOfJ);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> countOfI = counts.get(fatherOfI);</span><br><span class="line">        <span class="keyword">int</span> countOfJ = counts.get(fatherOfJ);</span><br><span class="line">        counts.put(fatherOfJ, countOfI + countOfJ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设输入n个整数，上述代码可能需要合并相邻的整数O(n)次，<strong>时间复杂度O(n)</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Toby</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dudu12091.github.io/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">https://dudu12091.github.io/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dudu12091.github.io" target="_blank">Tobyy的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="post_share"><div class="social-share" data-image="/img/%E5%89%91%E6%8C%87offer_1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/25/IDEA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"><img class="prev-cover" src="/img/idea%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IDEA无法启动</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/29/linux_hsp/"><img class="next-cover" src="/img/linux_hsp.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">linux韩顺平学习笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/tit.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Toby</div><div class="author-info__description">欢迎~</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dudu12091"><i></i><span>Toby's GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dudu12091" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:443126857@qq.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">announcement</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">整数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">#1 整数除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">#2 二进制加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%89%8Dn%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BD%A2%E5%BC%8F%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">#3 前n个数字二进制形式中1的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">1.4.</span> <span class="toc-text">#4 只出现一次的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF"><span class="toc-number">1.5.</span> <span class="toc-text">#5 单词长度的最大乘积</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">#双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-number">2.2.</span> <span class="toc-text">#6 排序数组中的两个数字之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA0%E7%9A%843%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">2.3.</span> <span class="toc-text">#7 数组中和为0的3个数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%92%8C%E5%A4%A7%E4%BA%8E%E6%88%96%E7%AD%89%E4%BA%8Ek%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.</span> <span class="toc-text">#8 和大于或等于k的最短子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.5.</span> <span class="toc-text">#9 乘积小于k的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E6%95%B0%E7%BB%84%E6%95%B0%E5%AD%97%E6%B1%82%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C"><span class="toc-number">2.6.</span> <span class="toc-text">#累加数组数字求子数组之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.7.</span> <span class="toc-text">#10 和为k的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-0%E5%92%8C1%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.8.</span> <span class="toc-text">#11 0和1个数相同的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89"><span class="toc-number">2.9.</span> <span class="toc-text">#12 左右两边子数组的和相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BA%8C%E7%BB%B4%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-number">2.10.</span> <span class="toc-text">#13 二维子矩阵的数字之和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="toc-number">3.1.</span> <span class="toc-text">#双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D"><span class="toc-number">3.2.</span> <span class="toc-text">#14 字符串中的变位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D"><span class="toc-number">3.3.</span> <span class="toc-text">#15 字符串中所有的变位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.4.</span> <span class="toc-text">#16 不含重复字符的最长子字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.</span> <span class="toc-text">#17 包含所有字符串的最短字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%96%87"><span class="toc-number">3.6.</span> <span class="toc-text">#18 有效的回文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E6%9C%80%E5%A4%9A%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87"><span class="toc-number">3.7.</span> <span class="toc-text">#19 最多删除一个字符得到回文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">#20 回文子字符串的个数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">#单向链表的简单定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">#哨兵节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="toc-number">4.3.</span> <span class="toc-text">#双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">4.4.</span> <span class="toc-text">#21 删除倒数第k个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9"><span class="toc-number">4.5.</span> <span class="toc-text">#22 链表中环的入口节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC1%E4%B8%AA%E9%87%8D%E5%90%88%E8%8A%82%E7%82%B9"><span class="toc-number">4.6.</span> <span class="toc-text">#23 两个链表的第1个重合节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">4.7.</span> <span class="toc-text">#24 反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0"><span class="toc-number">4.8.</span> <span class="toc-text">#25 链表中的数字相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="toc-number">4.9.</span> <span class="toc-text">#26 重排链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">4.10.</span> <span class="toc-text">#27 回文链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%92%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">4.11.</span> <span class="toc-text">双向链表和循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%B1%95%E5%B9%B3%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">4.12.</span> <span class="toc-text">#28 展平多级双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">4.13.</span> <span class="toc-text">#29 排序的循环链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E9%83%BD%E6%98%AFO-1-%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">#30 插入、删除和随机访问都是O(1)的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-number">5.2.</span> <span class="toc-text">#31 最近最少使用缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%9C%89%E6%95%88%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D"><span class="toc-number">5.3.</span> <span class="toc-text">#32 有效的变位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84"><span class="toc-number">5.4.</span> <span class="toc-text">#33 变位词组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E5%A4%96%E6%98%9F%E8%AF%AD%E8%A8%80%E6%98%AF%E5%90%A6%E6%8E%92%E5%BA%8F"><span class="toc-number">5.5.</span> <span class="toc-text">#34 外星语言是否排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE"><span class="toc-number">5.6.</span> <span class="toc-text">#35 最小时间差</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">6.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%ADstack%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">6.1.</span> <span class="toc-text"># Java中stack的常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">#36 后缀表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E"><span class="toc-number">6.3.</span> <span class="toc-text">#37 小行星碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-number">6.4.</span> <span class="toc-text">#38 每日温度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF"><span class="toc-number">6.5.</span> <span class="toc-text">#39 直方图最大矩形面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="toc-number">6.6.</span> <span class="toc-text">#40 矩阵中国的最大矩形</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%ADQueue%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.</span> <span class="toc-text">#Java中Queue的常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">7.2.</span> <span class="toc-text">#41 滑动窗口的平均值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">#42 最近请求次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">7.4.</span> <span class="toc-text">#二叉树的广度优先搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%9C%A8%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="toc-number">7.5.</span> <span class="toc-text">#43 在完全二叉树中添加节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%AF%8F%E5%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">7.6.</span> <span class="toc-text">#44 二叉树中每层的最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E4%BD%8E%E5%B1%82%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%80%BC"><span class="toc-number">7.7.</span> <span class="toc-text">#45 二叉树最低层最左边的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7%E8%A7%86%E5%9B%BE"><span class="toc-number">7.8.</span> <span class="toc-text">#46 二叉树的右侧视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">8.1.</span> <span class="toc-text">#二叉树的深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.1.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.2.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93"><span class="toc-number">8.1.4.</span> <span class="toc-text">三种遍历方法小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D"><span class="toc-number">8.2.</span> <span class="toc-text">#47 二叉树剪枝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.3.</span> <span class="toc-text">#48 序列化和反序列化二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E4%BB%8E%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-number">8.4.</span> <span class="toc-text">#49 从根节点到叶节点的路径数字之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E5%90%91%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C"><span class="toc-number">8.5.</span> <span class="toc-text">#50 向下的路径节点之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E8%8A%82%E7%82%B9%E5%80%BC%E4%B9%8B%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">8.6.</span> <span class="toc-text">#51 节点值之和最大的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">8.7.</span> <span class="toc-text">#二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E5%B1%95%E5%B9%B3%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">8.8.</span> <span class="toc-text">#52 展平二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">8.9.</span> <span class="toc-text">#53 二叉搜索树的下一个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E6%89%80%E6%9C%89%E5%A4%A7%E4%BA%8E%E6%88%96%E7%AD%89%E4%BA%8E%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="toc-number">8.10.</span> <span class="toc-text">#54 所有大于或等于节点的值之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">8.11.</span> <span class="toc-text">#55 二叉搜索树迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="toc-number">8.12.</span> <span class="toc-text">#56 二叉搜索树中两个节点的值之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet%E5%92%8CTreeMap%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">8.13.</span> <span class="toc-text">#TreeSet和TreeMap的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">8.13.1.</span> <span class="toc-text">TreeSet的常用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">8.13.2.</span> <span class="toc-text">TreeMap的常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E4%B9%8B%E5%B7%AE%E9%83%BD%E5%9C%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E8%8C%83%E5%9B%B4%E5%86%85"><span class="toc-number">8.14.</span> <span class="toc-text">#57 值和下标之差都在给定的范围内</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E6%97%A5%E7%A8%8B%E8%A1%A8"><span class="toc-number">8.15.</span> <span class="toc-text">#58 日程表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">9.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">9.1.</span> <span class="toc-text">#堆的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.2.</span> <span class="toc-text">#堆的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AC%ACk%E5%A4%A7%E6%95%B0%E5%AD%97"><span class="toc-number">9.3.</span> <span class="toc-text">#59 数据流的第k大数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84k%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">9.4.</span> <span class="toc-text">#60 出现频率最高的k个数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%A0%91%E5%AF%B9"><span class="toc-number">9.5.</span> <span class="toc-text">#61 和最小的k个树对</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">10.</span> <span class="toc-text">前缀树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">10.1.</span> <span class="toc-text">#前缀树的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">10.2.</span> <span class="toc-text">#62 实现前缀树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E6%9B%BF%E6%8D%A2%E5%8D%95%E8%AF%8D"><span class="toc-number">10.3.</span> <span class="toc-text">#63 替换单词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E7%A5%9E%E5%A5%87%E7%9A%84%E5%AD%97%E5%85%B8"><span class="toc-number">10.4.</span> <span class="toc-text">#64 神奇的字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-%E6%9C%80%E7%9F%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E7%BC%96%E7%A0%81"><span class="toc-number">10.5.</span> <span class="toc-text">#65 最短的单词编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-%E5%8D%95%E8%AF%8D%E4%B9%8B%E5%92%8C"><span class="toc-number">10.6.</span> <span class="toc-text">#66 单词之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-%E6%9C%80%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96"><span class="toc-number">10.7.</span> <span class="toc-text">#67 最大的异或</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">11.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">11.1.</span> <span class="toc-text">#二分查找的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68-%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">11.2.</span> <span class="toc-text">#68 查找插入的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-%E5%B1%B1%E5%B3%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%B6%E9%83%A8"><span class="toc-number">11.3.</span> <span class="toc-text">#69 山峰数组的顶部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">11.4.</span> <span class="toc-text">#70 排序数组中只出现一次的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71-%E6%8C%89%E6%9D%83%E9%87%8D%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">11.5.</span> <span class="toc-text">#71 按权重生成随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-number">11.6.</span> <span class="toc-text">#72 求平方根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-%E7%8B%92%E7%8B%92%E5%90%83%E9%A6%99%E8%95%89"><span class="toc-number">11.7.</span> <span class="toc-text">#73 狒狒吃香蕉</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">12.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#74-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">12.1.</span> <span class="toc-text">#74 合并区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">12.2.</span> <span class="toc-text">#计数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F"><span class="toc-number">12.3.</span> <span class="toc-text">#75 数组相对排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">12.4.</span> <span class="toc-text">#快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">12.5.</span> <span class="toc-text">#76 数组中第k大的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">12.6.</span> <span class="toc-text">#归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">12.7.</span> <span class="toc-text">#77 链表排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">12.8.</span> <span class="toc-text">#78 合并排序链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">回溯法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#79-%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86"><span class="toc-number">13.1.</span> <span class="toc-text">#79 所有子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80-%E5%8C%85%E5%90%ABk%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">13.2.</span> <span class="toc-text">#80 包含k个元素的集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#81-%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">13.3.</span> <span class="toc-text">#81 允许重复选择元素的集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82-%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">13.4.</span> <span class="toc-text">#82 包含重复元素集合的组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83-%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">13.5.</span> <span class="toc-text">#83 没有重复元素集合的全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84-%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">13.6.</span> <span class="toc-text">#84 包含重复元素集合的全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85-%E7%94%9F%E6%88%90%E5%8C%B9%E9%85%8D%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">13.7.</span> <span class="toc-text">#85 生成匹配的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">13.8.</span> <span class="toc-text">#86 分割回文字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87-%E6%81%A2%E5%A4%8DIP%E5%9C%B0%E5%9D%80"><span class="toc-number">13.9.</span> <span class="toc-text">#87 恢复IP地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">14.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#88-%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%91%E6%88%90%E6%9C%AC"><span class="toc-number">14.1.</span> <span class="toc-text">#88 爬楼梯的最少成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89-%E6%88%BF%E5%B1%8B%E5%81%B7%E7%9B%97"><span class="toc-number">14.2.</span> <span class="toc-text">#89 房屋偷盗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-%E7%8E%AF%E5%BD%A2%E6%88%BF%E5%B1%8B%E5%81%B7%E7%9B%97"><span class="toc-number">14.3.</span> <span class="toc-text">#90 环形房屋偷盗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#91-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90"><span class="toc-number">14.4.</span> <span class="toc-text">#91 粉刷房子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6"><span class="toc-number">14.5.</span> <span class="toc-text">#92 翻转字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93-%E6%9C%80%E9%95%BF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">14.6.</span> <span class="toc-text">#93 最长斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#94-%E6%9C%80%E5%B0%91%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2"><span class="toc-number">14.7.</span> <span class="toc-text">#94 最少回文分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#95-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">14.8.</span> <span class="toc-text">#95 最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E7%BB%87"><span class="toc-number">14.9.</span> <span class="toc-text">#96 字符串交织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE"><span class="toc-number">14.10.</span> <span class="toc-text"># 子序列数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">14.11.</span> <span class="toc-text">#98 路径的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#99-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C"><span class="toc-number">14.12.</span> <span class="toc-text">#99 最小路径之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#100-%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AD%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C"><span class="toc-number">14.13.</span> <span class="toc-text">#100 三角形中最小路径之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#101-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">14.14.</span> <span class="toc-text">#101 分割等和子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102-%E5%8A%A0%E5%87%8F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%80%BC"><span class="toc-number">14.15.</span> <span class="toc-text">#102 加减的目标值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#103-%E6%9C%80%E5%B0%91%E7%9A%84%E7%A1%AC%E5%B8%81%E6%95%B0%E7%9B%AE"><span class="toc-number">14.16.</span> <span class="toc-text">#103 最少的硬币数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104-%E6%8E%92%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">14.17.</span> <span class="toc-text">#104 排列的数目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">15.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#105-%E6%9C%80%E5%A4%A7%E7%9A%84%E5%B2%9B%E5%B1%BF"><span class="toc-number">15.1.</span> <span class="toc-text">#105 最大的岛屿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#106-%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">15.2.</span> <span class="toc-text">#106 二分图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#107-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="toc-number">15.3.</span> <span class="toc-text">#107 矩阵中的距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#108-%E5%8D%95%E8%AF%8D%E6%BC%94%E5%8F%98"><span class="toc-number">15.4.</span> <span class="toc-text">#108 单词演变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#109-%E5%BC%80%E5%AF%86%E7%A0%81%E9%94%81"><span class="toc-number">15.5.</span> <span class="toc-text">#109 开密码锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110-%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">15.6.</span> <span class="toc-text">#110 所有路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#111-%E8%AE%A1%E7%AE%97%E9%99%A4%E6%B3%95"><span class="toc-number">15.7.</span> <span class="toc-text">#111 计算除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112-%E6%9C%80%E9%95%BF%E7%9A%84%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="toc-number">15.8.</span> <span class="toc-text">#112 最长的递增路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">15.9.</span> <span class="toc-text">#拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113-%E8%AF%BE%E7%A8%8B%E9%A1%BA%E5%BA%8F"><span class="toc-number">15.10.</span> <span class="toc-text">#113 课程顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114-%E5%A4%96%E6%98%9F%E6%96%87%E5%AD%97%E5%85%B8"><span class="toc-number">15.11.</span> <span class="toc-text">#114 外星文字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#115-%E9%87%8D%E5%BB%BA%E5%BA%8F%E5%88%97"><span class="toc-number">15.12.</span> <span class="toc-text">#115 重建序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">15.13.</span> <span class="toc-text">#并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#116-%E6%9C%8B%E5%8F%8B%E5%9C%88"><span class="toc-number">15.14.</span> <span class="toc-text">#116 朋友圈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#117-%E7%9B%B8%E4%BC%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">15.15.</span> <span class="toc-text">#117 相似的字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#118-%E5%A4%9A%E4%BD%99%E7%9A%84%E8%BE%B9"><span class="toc-number">15.16.</span> <span class="toc-text">#118 多余的边</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#119-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">15.17.</span> <span class="toc-text">#119 最长连续序列</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/" title="深入理解JVM"><img src="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解JVM"/></a><div class="content"><a class="title" href="/2022/01/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/" title="深入理解JVM">深入理解JVM</a><time datetime="2022-01-17T00:53:13.291Z" title="发表于 2022-01-17 00:53:13">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/30/%E7%89%9B%E5%AE%A2%E7%BD%91java%E9%9D%A2%E7%BB%8F/" title="牛客网java面经"><img src="/img/%E7%89%9B%E5%AE%A2%E7%BD%91java%E9%9D%A2%E7%BB%8F.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="牛客网java面经"/></a><div class="content"><a class="title" href="/2021/12/30/%E7%89%9B%E5%AE%A2%E7%BD%91java%E9%9D%A2%E7%BB%8F/" title="牛客网java面经">牛客网java面经</a><time datetime="2021-12-30T16:00:14.339Z" title="发表于 2021-12-30 16:00:14">2021-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/25/IDEA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/" title="IDEA无法启动"><img src="/img/idea%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IDEA无法启动"/></a><div class="content"><a class="title" href="/2021/12/25/IDEA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/" title="IDEA无法启动">IDEA无法启动</a><time datetime="2021-12-25T16:15:44.046Z" title="发表于 2021-12-25 16:15:44">2021-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="剑指offer刷题-数据结构与算法篇"><img src="/img/%E5%89%91%E6%8C%87offer_1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="剑指offer刷题-数据结构与算法篇"/></a><div class="content"><a class="title" href="/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="剑指offer刷题-数据结构与算法篇">剑指offer刷题-数据结构与算法篇</a><time datetime="2021-10-16T16:30:46.584Z" title="发表于 2021-10-16 17:30:46">2021-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/29/linux_hsp/" title="linux韩顺平学习笔记"><img src="/img/linux_hsp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux韩顺平学习笔记"/></a><div class="content"><a class="title" href="/2021/09/29/linux_hsp/" title="linux韩顺平学习笔记">linux韩顺平学习笔记</a><time datetime="2021-09-29T22:48:36.000Z" title="发表于 2021-09-29 23:48:36">2021-09-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Toby</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '6738eac81c233ff71337',
      clientSecret: '981b5f973b7b3d150cf369182ffc8b4061452fa5',
      repo: 'hexo-comments',
      owner: 'dudu12091',
      admin: ['dudu12091'],
      id: 'af23dcd66b95b496dd7f95c6dcdec408',
      language: 'en',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>