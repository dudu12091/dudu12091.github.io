<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>剑指offer刷题-数据结构与算法篇 | Tobyy的博客</title><meta name="keywords" content="数据结构与算法"><meta name="author" content="Toby"><meta name="copyright" content="Toby"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="整数#1 整数除法输入两个int型整数，它们进行除法计算并返回商，**要求不得使用乘号*，除号&#x2F;以及求余符号%**，当发出溢出时，返回最大的整数值。假设除数不为0。例如，输入15和2，输出15&#x2F;2，即7。（注意：int型范围是-2^31 ~ -2^31-1） 分析： 只基于减法实现是可以的，但是此情况的最坏时间复杂度为O(n)，需要对效率进一步提升。 当被除数大于出除数时，继续比较判断被除数是否大">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer刷题-数据结构与算法篇">
<meta property="og:url" content="https://dudu12091.github.io/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Tobyy的博客">
<meta property="og:description" content="整数#1 整数除法输入两个int型整数，它们进行除法计算并返回商，**要求不得使用乘号*，除号&#x2F;以及求余符号%**，当发出溢出时，返回最大的整数值。假设除数不为0。例如，输入15和2，输出15&#x2F;2，即7。（注意：int型范围是-2^31 ~ -2^31-1） 分析： 只基于减法实现是可以的，但是此情况的最坏时间复杂度为O(n)，需要对效率进一步提升。 当被除数大于出除数时，继续比较判断被除数是否大">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dudu12091.github.io/img/%E5%89%91%E6%8C%87offer_1.jpg">
<meta property="article:published_time" content="2021-10-16T16:30:46.584Z">
<meta property="article:modified_time" content="2021-11-12T18:23:08.977Z">
<meta property="article:author" content="Toby">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dudu12091.github.io/img/%E5%89%91%E6%8C%87offer_1.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://dudu12091.github.io/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剑指offer刷题-数据结构与算法篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-12 18:23:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/tit.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> about</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i><span> myself</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E5%89%91%E6%8C%87offer_1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Tobyy的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> about</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i><span> myself</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指offer刷题-数据结构与算法篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-16T16:30:46.584Z" title="发表于 2021-10-16 17:30:46">2021-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-12T18:23:08.977Z" title="更新于 2021-11-12 18:23:08">2021-11-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指offer刷题-数据结构与算法篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><h3 id="1-整数除法"><a href="#1-整数除法" class="headerlink" title="#1 整数除法"></a>#1 整数除法</h3><p>输入两个int型整数，它们进行除法计算并返回商，**要求不得使用乘号*，除号/以及求余符号%**，当发出溢出时，返回最大的整数值。假设除数不为0。例如，输入15和2，输出15/2，即7。（注意：int型范围是-2^31 ~ -2^31-1）</p>
<p>分析：</p>
<p>只基于减法实现是可以的，但是此情况的最坏时间复杂度为O(n)，需要对效率进一步提升。</p>
<p>当被除数大于出除数时，继续比较判断被除数是否大于除数的2倍，如果是，则继续判断被除数是否大于除数的4倍、8倍等。如果被除数最多大于除数的2^k倍，那么将被除数减去除数的2^k倍，然后将剩余的被除数重复前面的步骤。由于每次将除数翻倍，因此优化后的时间复杂度是O(logn)。</p>
<p>细节：</p>
<ol>
<li>最小的整数是-2^31, 最大的整数是2^31-1。因此，如果将负整数直接转换为正整数可能导致溢出。可以先将正整数都转换成负整数，再根据需要调整商的符号。</li>
<li>直接溢出的情况，被除数为-2^31，除数为-1</li>
<li>防止被除数在扩大一倍时溢出，所以需要提前判断</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 辅助判断符号,奇数为负，偶数为正</span></span><br><span class="line">        <span class="keyword">int</span> negative = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            negative--;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            negative--;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = divideCore(dividend, divisor);</span><br><span class="line">        <span class="keyword">return</span> negative == <span class="number">1</span> ? -result : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divideCore</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dividend &lt;= divisor) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = divisor;</span><br><span class="line">        <span class="keyword">int</span> quotient = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个判断条件很重要，防止后面value扩大一倍时溢出</span></span><br><span class="line">        <span class="keyword">while</span> (value &gt;= Integer.MIN_VALUE / <span class="number">2</span> &amp;&amp; dividend &lt;= value + value) &#123;</span><br><span class="line">            quotient += quotient;</span><br><span class="line">            value += value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result += quotient;</span><br><span class="line">        dividend -= value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-二进制加法"><a href="#2-二进制加法" class="headerlink" title="#2 二进制加法"></a>#2 二进制加法</h3><p>给定两个表示二进制的字符串，请计算它们的和，并以二进制字符串的形式输出。例如，输入的二进制字符串分别是”11”和”10”，则输出”101”</p>
<p>注意：不能直接将二进制字符串转换成整数运算，因为并没有限定二进制字符串的长度，可能会造成溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a_length = a.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b_length = b.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (a_length &gt;= <span class="number">0</span> || b_length &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> digitA = a_length &gt;= <span class="number">0</span> ? a.charAt(a_length--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digitB = b_length &gt;= <span class="number">0</span> ? b.charAt(b_length--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = digitA + digitB + carry;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">            sum -= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑最后是否存在进位</span></span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">        result.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为存储顺序是从右至左，所以需要逆序输出</span></span><br><span class="line">    <span class="keyword">return</span> result.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-前n个数字二进制形式中1的个数"><a href="#3-前n个数字二进制形式中1的个数" class="headerlink" title="#3 前n个数字二进制形式中1的个数"></a>#3 前n个数字二进制形式中1的个数</h3><p>输入一个非负数n，请计算0到n之间每个数字的二进制形式中1的个数，并输出一个数组。例如，输入的n为4，由于0、1、2、3、4的二进制形式中1的个数分别为0、1、1、2、1，因此输出数组[0,1,1,2,1]。</p>
<p>简单分析：最直观的解法，就是用for循环来计算从0到n的每个整数i的二进制形式中1的个数。于是问题转换成如何求一个整数i的二进制形式中1的个数。</p>
<p>思路</p>
<ol>
<li><p>根据<code>i&amp;(i-1)</code>计算</p>
<p>此公式的核心思想是把i最右面的1变成0。可以通过for循环，不断地把最右边的1变成0，变化了几次就说明有几个1。其中页暗藏动态规划的思想，数字i中1的个数比i&amp;(i-1)中1的个数多1。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于思路<span class="number">1</span>实现:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countBits_1(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result[i] = result[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>根据<code>i/2</code>计算</p>
<p>通过观察发现，如果正整数i是偶数，那么i相当于’i/2’左移一位的结果，因此它们的二进制形式中1的个数是相同的。如果i是奇数，那么i相当于’i/2’左移一位之后，再将最右边一位设成1的结果，因此奇数i的二进制形式中1的个数比’i/2’中的1的个数多1。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于思路<span class="number">2</span>实现:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countBits_2(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// i &amp; 1, i为奇数则结果为1, 偶数为0</span></span><br><span class="line">        result[i] = result[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上述代码用’i &gt;&gt; 1’计算’i/2’，用’i &amp; 1’计算’i%2’，因为位运算比除法运算和求余运算更高效。</p>
<h3 id="4-只出现一次的数字"><a href="#4-只出现一次的数字" class="headerlink" title="#4 只出现一次的数字"></a>#4 只出现一次的数字</h3><p>输入一个整数数组，书注重只有一个数字出现了一次，而其他数字都出现了3次。请找出那个只出现一次的数字。例如，如果输入的数组为[0,1,0,1,0,1,100]，则只出现一次的数字是100。</p>
<p>思路：一个整数是由32个0或1组成的。我们可以将数组中所有数字的同一位置的数位相加。因此，<strong>如果数组中所有数字的第i个数位相加之和能被3整除，那么只出现一次的数字的第i个位数一定是0；如果数组中所有数字的第i个数位相加之和被3除余1，那么只出现一次的数字的第i个数位一定是1。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代表整数的长度为32bit</span></span><br><span class="line">    <span class="keyword">int</span>[] bitSums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把数组中所有数字按对应的bit位累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            bitSums[i] += (num &gt;&gt; (<span class="number">31</span> - i)) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断累加后对应的bit位能否被三整除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        result = (result &lt;&lt; <span class="number">1</span>) + bitSums[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>举一反三：</strong>如果数组中只有一个数字出现m次，其他数字都出现n次，m不能被n整除，找出唯一出现m次的数字。</p>
<p>用同样的思路解决此问题，最后验证累加后的整数对应bit位能否被m整除。</p>
<h3 id="5-单词长度的最大乘积"><a href="#5-单词长度的最大乘积" class="headerlink" title="#5 单词长度的最大乘积"></a>#5 单词长度的最大乘积</h3><p>给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p>
<p>例如：输入的字符串数组words为[“abcw”,”foo”,”bar”,”fxyz”,”abcdef”], 最后返回的应该是16。</p>
<p>思路1：</p>
<p>假设两字符串长度分别为p,q。</p>
<ol>
<li>最直观的解法就是蛮力法。如果蛮力法比较两个字符串是否有相等字符，比较的时间复杂度为O(pq)。</li>
<li>通过哈希表来优化时间效率。对于每个字符串，用一个哈希表记录该字符串中的所有字符。因为题目假设的所有字符都是英文小写字母，只有26个可能的字符，因此最多只需要在每个字符串对应的哈希表中查询26次就能判断两个字符串是否包含相同的字符，因此比较的时间复杂度为O(1)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct_1</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[words.length][<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 生成哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">            flags[i][c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 判断word i 和 word j是否有相同的字符</span></span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flags[i][k] == <span class="keyword">true</span> &amp;&amp; flags[j][k] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// k = 26说明没有相同字符</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> prod = words[i].length() * words[j].length();</span><br><span class="line">                result = Math.max(result, prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>进一步分析此方法的时间和空间复杂度。</p>
<p>第一步，初始化每个字符串对应的哈希表。如果words的长度为n，凭均每个字符串的长度为k，那么初始化哈希表的时间复杂度为O(nk)。</p>
<p>第二步，根据哈希表判断每对字符串是否包含相同的字符。总共有O(n^2)对字符串，每次判断需要的时间为O(1)，因此这一步的时间复杂度为O(n^2)。</p>
<p><strong>于是这种解法的整体时间复杂度为O(nk + n^2)。</strong></p>
<p>为每一个字符串创建一个数组，所以<strong>空间复杂度为O(n)</strong></p>
</li>
</ol>
<p>思路2：用整数的二进制数位记录字符串中出现的字符</p>
<p>前面的解法是用一个长度为26的布尔型数组记录字符串中出现的字符。布尔值只有两种可能，true or false。这与二进制有些类似。因此，可以将长度为26的布尔型数组用26个二进制的数位代替，二进制的0对应布尔值的false，1对应true。</p>
<p>26bit就足以表示一个字符串中可能出现的字符，所以我们可以用int(32bit)来表示。<strong>用二进制数位表示的好处是可以更快地判断两个字符串是否包含相同的字符。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct_2</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] flags = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : words[i].toCharArray()) &#123;</span><br><span class="line">            flags[i] |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 说明两个字符串没有相同的字符</span></span><br><span class="line">            <span class="keyword">if</span> ((flags[i] &amp; flags[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> prod = words[i].length() * words[j].length();</span><br><span class="line">                result = Math.max(result, prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<p>与思路1时间空间复杂度均相同。</p>
<p>但是在比较是否存在相等字符时，只需要一次运算即可。而思路1中可能需要26次布尔运算，所以<strong>新的解法时间效率更高</strong>。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="#双指针"></a>#双指针</h3><p>方向相反的双指针经常用来求排序数组中的两个数字之和。</p>
<p>方向相同的双指针通常用来求正数数组中子数组的和或乘积。</p>
<h3 id="6-排序数组中的两个数字之和"><a href="#6-排序数组中的两个数字之和" class="headerlink" title="#6 排序数组中的两个数字之和"></a>#6 排序数组中的两个数字之和</h3><p>考点 <code>双指针</code></p>
<p>输入一个递增序列的数组和一个值k，请问如何在数组中找出两个和为k的数字并返回它们的下标？假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。</p>
<p>例如：输入数组[1,2,4,6,10], k的值为8，应该返回[1,3]</p>
<p>分析：</p>
<ol>
<li><p>最直观的暴力解法，固定数组中的一个数字，然后判断数组中其余数字与他的和是不是等于k。可以看成是用两个for循环遍历数组，<strong>时间复杂度为O(n^2)</strong></p>
</li>
<li><p>上述解法可以用二分查找优化。还是先固定一个数字i，然后用二分查找寻找k-i。时间复杂度为O(nlogn)。</p>
</li>
<li><p>上述解法还可以用空间换时间进行优化。可以先将数组中所有的数字都放入一个哈希表，然后逐一扫描数组中的每个数字。扫描i, 就在哈希表里找k-i。判断哈希表中是否存在一个数字的时间复杂度为O(1)，因此新解法的**时间复杂度为O(n)<strong>。同时它需要一个大小为O(n)的哈希表，因此</strong>空间复杂度也是O(n)**。</p>
</li>
<li><p>存在时间复杂度是O(n)，空间复杂度是O(1)的解法，就是我们最后要引出的<code>双指针</code>。</p>
<p>两个指针一个从前向后移动，一个从后向前移动。如果小于target前指针后移，如果大于target后指针前移。如果相等则返回指针对应的索引。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// 双指针，一个从前向后移动，一个从后向前移动</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = numbers.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] != target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] + numbers[j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-数组中和为0的3个数字"><a href="#7-数组中和为0的3个数字" class="headerlink" title="#7 数组中和为0的3个数字"></a>#7 数组中和为0的3个数字</h3><p>输入一个数组，如何找出数组中所有和为0的3个数字的三元组？需要注意的是，返回值中不得包含重复的三元组。</p>
<p>例如：在数组[-1,0,1,2,-1,-4]中有两个三元组的和为0，它们分别是[-1,0,1]和[-1,-1,2]。</p>
<p>分析：</p>
<p>这是上一题的加强版。如果输入的数组是排序的，我们就可以先固定一个数字i，然后再排序数组中查找和为-i的两个数字。我们已经有了用O(n)时间在排序数组中找出和为给定值的两个数字的方法，由于需要固定数组中的每个数字，因此查找此三元组的时间复杂度是O(n^2)。</p>
<p>但是这个题目并没有说给出的数组是排序的，因此需要先对数组排序。排序算法的时间复杂度通常是O(nlogn)，因此这种解法的总时间复杂度是O(logn + n^2), <strong>最后还是O(n^2)</strong></p>
<p>最后要注意去除重复的三元组。在指针移动时跳过所有相同的值即可。需要跳过相同值的地方共有两处，第一处是固定i的时候，第二处是双指针移动的时候。移动前指针和后指针都可以，移动的那个指针要考虑跳过重复值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length - <span class="number">2</span>) &#123;</span><br><span class="line">            twoSum(nums, i, result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过重复的数字</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">while</span> (nums[i] == temp &amp;&amp; i &lt; nums.length - <span class="number">2</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class="line">    <span class="comment">// 双指针，一个从前向后移动，一个从后向前移动</span></span><br><span class="line">    <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过重复的数字</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">            <span class="keyword">while</span> (nums[j] == temp &amp;&amp; j &lt; k) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-和大于或等于k的最短子数组"><a href="#8-和大于或等于k的最短子数组" class="headerlink" title="#8 和大于或等于k的最短子数组"></a>#8 和大于或等于k的最短子数组</h3><p>输入一个正整数组成的数组和一个正整数k，请问数组中和大于或等于k的连续子数组的最短长度是多少？如果不存在所有数字之和大于或等于k的子数组，则返回0。</p>
<p>例如：输入数组[5,1,4,3]，k的值为7，最后输出2。</p>
<p>考点 <code>双指针</code></p>
<p>分析：</p>
<p>用两个指针P1，P2来锁定子数组，子数组由两个指针之间所有数字组成。</p>
<p>初始化时两指针都指向数组的第一个元素。</p>
<p>如果子数组和大于等于k，则P1右移，相当于从子数组的最左边删除一个数字，子数组长度减1。如果子数组和小于k，则P1右移，相当于在子数组的最右边添加一个新的数字，子数组长度加1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; right &lt; nums.length; right++) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>尽管代码中有两个嵌套的循环，但是**时间复杂度仍然是O(n)**。因为left和right都只加不减，变化范围都是[0~n-1]。</p>
<h3 id="9-乘积小于k的子数组"><a href="#9-乘积小于k的子数组" class="headerlink" title="#9 乘积小于k的子数组"></a>#9 乘积小于k的子数组</h3><p>输入一个由正整数组成的数组和一个正整数k，请问数组中有多少个数字乘积小于k的连续子数组？</p>
<p>例如：输入数组[10,5,2,6]，k的值为100，有8个子数组的所有数字的乘积小于100。</p>
<p>考点 <code>双指针</code></p>
<p>分析：</p>
<p>与上一题思路类似，用双指针P1，P2锁定子数组，如果子数组中所有数字的乘积小于k，那么右移P2；反之则右移P1。当指针P1到某个位置时子数组的乘积小于k，就不需要再向右移动指针P1。因为只要保持指针P2不动，向右移动指针P1形成的所有子数组的数字乘积就一定小于k。<strong>此时两个指针之间有多少个数字，就找到了多少个数字乘积小于k的子数组。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; right &lt; nums.length; right++) &#123;</span><br><span class="line">        product *= nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; product &gt;= k) &#123;</span><br><span class="line">            product /= nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        result += right &gt;= left ? right - left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>和上一题同理，<strong>时间复杂度为O(n)</strong></p>
<h3 id="累加数组数字求子数组之和"><a href="#累加数组数字求子数组之和" class="headerlink" title="#累加数组数字求子数组之和"></a>#累加数组数字求子数组之和</h3><p>使用双指针解决子数组之和问题有一个前提条件：数组中的所有数字都是正数。如果数组中有正数、负数和零，那么双指针的思路并不适用。因为当数组中有负数时在子数组中添加数字不一定能增加子数组之和，从子数组中删除数字也不一定能减少子数组之和。</p>
<p>所以引出求子数组和的另一种思路：<code>累加数组数字</code></p>
<p>首先需要预处理。假设数组长度为n，从头到尾扫描一次，就能求出从下标0开始到下标0结束的所有子数组之和S_0，从下标0开始到下标1结束的子数组之和S_1，以此类推，直到求出从下标0开始到最后一个数字的子数组之和S_n-1。因此，<strong>从下标为i开始到下标为j结束的子数组的和就是S_j - S_i-1</strong>。</p>
<h3 id="10-和为k的子数组"><a href="#10-和为k的子数组" class="headerlink" title="#10 和为k的子数组"></a>#10 和为k的子数组</h3><p>输入一个整数数组和一个整数k，请问数组中有多少个数字之和等于k的连续子数组？</p>
<p>例如：输入数组[1,1,1]，k的值为2，有2个连续子数组之和等于2。</p>
<p>分析：</p>
<p>最先想到暴力解法。在一个长度为n的数组中有O(n^2)个子数组，如果求出每个子数组的和需要O(n)的时间，那么总共需要O(n^3)的时间就能求出所有子数组的和。</p>
<p>对暴力解法进一步优化。在计算长度为i的子数组数字之和时，应该把子数组堪称长度为i-1的子数组的基础上添加一个新的数字。因此，如果已经求出了长度为i-1的子数组的数字之和，那么只要再加上新添加的数字就能得出长度为i的子数组的数字之和。因为只需要1次加法，需要O(1)时间，优化后的时间复杂度为O(n^2)。</p>
<p>再换一种思路，我们从头到尾扫描数组中的数字时求出前i个数字之和，并将结果保存下来。当扫描到数组的第i个数字时并求得前i个数字之和是x时，需要知道在i之前存在多少个j，满足前j个数字之和等于x-k。<strong>所以，对于每个i，不但要保存前i个数字之和，还要保存每个和出现的次数。</strong> 分析到这儿就知道我们需要一个哈希表，键是前i个数字之和，值是每个和出现的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; sumToCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刚开始累加和为0</span></span><br><span class="line">    sumToCount.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        result += sumToCount.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">        sumToCount.put(sum, sumToCount.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>只需要从头至尾扫描数组一次，所以**时间复杂度为O(n)<strong>。需要一个哈希表保存前i个数字的和及出现的次数，所以</strong>空间复杂度为O(n)**。</p>
<h3 id="11-0和1个数相同的子数组"><a href="#11-0和1个数相同的子数组" class="headerlink" title="#11 0和1个数相同的子数组"></a>#11 0和1个数相同的子数组</h3><p>输入一个只包含0和1的数组，请问如何求0和1个数相同的最长连续子数组的长度？</p>
<p>例如：在数组[0,1,0]中有两个子数组包含相同个数的0和1，分别是[0,1]和[1,0]，他们的长度都是2，因此输出2。</p>
<p>分析：</p>
<p><strong>如果题目中所有的0都变成-1，那么01个数相同的子数组和必为1。这样此题就转换成了一个求和为k的子数组的问题。</strong>想要完成这样的转换也很简单，只需要在每次累加时，判断当前数字时否为0，如果为0则累加-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; sumToIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果累加和为0，说明01数量已经相等，长度=索引+1</span></span><br><span class="line">    sumToIndex.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i] == <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sumToIndex.containsKey(sum)) &#123;</span><br><span class="line">            result = Math.max(result, i - sumToIndex.get(sum));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sumToIndex.put(sum, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>与求和为k的子数组同理，<strong>时间复杂度空间复杂度都为O(n)</strong></p>
<h3 id="12-左右两边子数组的和相等"><a href="#12-左右两边子数组的和相等" class="headerlink" title="#12 左右两边子数组的和相等"></a>#12 左右两边子数组的和相等</h3><p>输入一个整数数组，如果一个数字左边的子数组的数字之和等于右边的子数组的数字之和，那么返回该数字的下标。如果存在多个这样的数字，则返回最左边一个数字的下标。如果不存在这样的数字，则返回-1。</p>
<p>例如：在数组[1,7,3,6,2,9]中，下标为3的数字左右两边子数组之和相等，因此应该输出3。</p>
<p>分析：</p>
<p>当扫描到第i个数字时，可以算出前i个数字的累加和。此时，i左边子数组的和等于前i个数字的和减i，i右边子数组的和等于整个数组的和total减前i个数字的累加和。所以此题还得求整个数组的累加和total。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pivotIntex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; nums.length; i++) &#123;</span><br><span class="line">        total += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum - nums[i] == total - sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>共有两个时间复杂度为O(n)的循环，因此**时间复杂度为O(n)<strong>。并没有使用数组、哈希表等辅助数据容器，因此</strong>空间复杂度为O(1)**。</p>
<h3 id="13-二维子矩阵的数字之和"><a href="#13-二维子矩阵的数字之和" class="headerlink" title="#13 二维子矩阵的数字之和"></a>#13 二维子矩阵的数字之和</h3><p>输入一个二维矩阵，如何计算给定左上角坐标和右下角坐标的子矩阵的数字之和？对于同一个二维矩阵，计算子矩阵的数字之和的函数可能由于输入不同的坐标而被反复调用多次。</p>
<p>例如：输入如下矩阵和坐标(2,1),(4,3)，应该返回8</p>
<p>[[3,0,1,4,2],</p>
<p>[5,6,3,2,1],</p>
<p>[1,2,0,1,5],</p>
<p>[4,1,0,1,7],</p>
<p>[1,0,3,0,5]]    </p>
<p>分析：</p>
<p>如果不考虑时间复杂度，采用蛮力法用两个嵌套的循环总是可以求出一个二维矩阵的数字之和。如果矩阵的行数和列数分别是m和n，那么这种蛮力法的时间复杂度是O(mn)。但是由于题目提到，计算函数可能被反复调用多次，因此应该优化求和的过程，尽快地实现子矩阵求和函数。</p>
<p>我们用[(r1,c1)(r2,c2)]来表示左上角坐标为(r1,c1)，右下角坐标为(r2,c2)的子矩阵的数字之和。通过观察发现，此矩阵的数字之和可以用4个左上角坐标为(0,0)的子矩阵的数字之和求得。[(r1,c1)(r2,c2)] = [(0,0)(r2,c2)] - [(0,0)(r2,c1-1)] - [(0,0)(r1-1,c2)] + [(0,0)(r1-1,c1-1)]。</p>
<p>再进一步思考，只要在预处理阶段求出(0,0)到每个右下角坐标的子矩阵的数字之和，然后存到一个辅助矩阵中，目标子矩阵的数字之和就可以在常数时间内计算完毕。 </p>
<p>那要怎么计算子矩阵呢？可以把[(0,0),(i,j)]看成两部分。第一部分是[(0,0),(i-1,j)],第二部分是矩阵中第i行中列号从0到j的所有数字。<strong>为了计算方便，可以在初始化时创建一个比原数组行列多1的辅助矩阵。这样在计算辅助矩阵的第一行时也可以在循环中进行。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] NumMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] sums = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length+<span class="number">1</span>][matrix[<span class="number">0</span>].length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> rowSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            rowSum += matrix[i][j];</span><br><span class="line">            sums[i+<span class="number">1</span>][j+<span class="number">1</span>] = sums[i][j+<span class="number">1</span>] + rowSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> sums[][], <span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> 	sums[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] </span><br><span class="line">        	- sums[row1][col2 + <span class="number">1</span>] </span><br><span class="line">        	- sums[row2 + <span class="number">1</span>][col1] </span><br><span class="line">        	+ sums[row1][col1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>用两个嵌套的for循环计算辅助矩阵，时间复杂度为O(mn)。同时，辅助矩阵需要的空间也为O(mn)。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>java中String类型所表达的字符串时无法改变的。如果对字符串进行写操作，那么修改的内容在返回值的字符串中，原来的字符串保持不变。</p>
<p>由于每次对String实例进行修改将创建一个新的String实例，因此如果连续多次对String实例进行修改将连续创建多个新的String实例，不必要的内存开销较大。所以可以借助StringBuilder或StringBuffer(线程安全效率低)来容纳修改后的结果。</p>
<h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="#双指针"></a>#双指针</h3><p>如果将字符串看成一个由字符串组成的数组，那么也可以用两个指针来定位一个子字符串。</p>
<p>可以在移动这两个指针的同时，统计两个指针之间的字符串中字符出现的次数，这样可以解决很多常见的面试题，如定位变位词等。</p>
<p>由于这种类型的面试题都与统计字母出现的次数有关，我们经常使用哈希表来存储每个元素出现的次数，因此解决这种类型的面试题通常需要同时使用<strong>双指针和哈希表</strong>。</p>
<h3 id="14-字符串中的变位词"><a href="#14-字符串中的变位词" class="headerlink" title="#14 字符串中的变位词"></a>#14 字符串中的变位词</h3><p>输入字符串s1和s2，如何判断字符串s2中是否包含字符串s1的某个变位词？如果字符串s2中包含字符串s1的某个变位词，则字符串s1至少有一个变位词是字符串s2的子字符串。假设两个字符串中只包含英文小写字母。</p>
<p>例如：</p>
<ol>
<li>字符串s1为”ac”, s2为”dgcaf”, 输出true</li>
<li>字符串s1为”ab”, s2为”dgcaf”, 输出false</li>
</ol>
<p>分析：</p>
<p>还是最先想到暴力法。可以先求出字符串s1的所有排列，然后判断每个排列是不是字符串s2的子字符串。如果一个字符串有n个字符，那么它一共有n!个排列，因此这种解法的时间复杂度不会低于O(n!)。</p>
<p>下面尝试更高效的解法。我们可以以用一个哈希表来存储每个字符出现的次数。首先扫描s1，每扫描到一个字符，就找到它在哈希表中的位置并把对应的值加1。然后考虑s2中是否有s1的变位词。假设字符串s2中有一个子字符串是s1的变位词，逐个扫描这个变位词中的字母，并把字母在哈希表中对应的值减1。<strong>如果同位词存在，最后操作完，哈希表中所有的值应该都是0。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s2.length() &lt; s1.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 先判断第一组和s1等长的子字符串是否是其变位词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i 为第一个指针的索引， i - s1.length() + 1为第二个指针的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s1.length(); i &lt; s2.length(); i++) &#123;</span><br><span class="line">            counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            counts[s2.charAt(i - s1.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areAllZero</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：需要扫描字符串s1和s2各一次，如果他们的长度分别是m和n，那么**时间复杂度是O(m+n)<strong>。这种解法用到了一个长度为26的数组，是一个常数，所以</strong>空间复杂度是O(1)**。</p>
<h3 id="15-字符串中所有的变位词"><a href="#15-字符串中所有的变位词" class="headerlink" title="#15 字符串中所有的变位词"></a>#15 字符串中所有的变位词</h3><p>输入字符串s1和s2，如何找出字符串s2的所有变位词在字符串s1中的起始下标？假设两个字符串中只包含英文小写字母。</p>
<p>例如：字符串s1为”cbadabacg”, 字符串s2为”abc”，应该输出0和5。</p>
<p>分析：就是上一题的变种。在成功找到变位词时返回对应子字符串第一个字符的索引即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; indices = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s1.length() &lt; s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 方便添加进列表</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先判断第一组子字符串</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s2.length(); i++) &#123;</span><br><span class="line">        counts[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">        indices.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = s2.length(); i &lt; s1.length(); i++) &#123;</span><br><span class="line">        counts[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        counts[s1.charAt(i - s2.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (areAllZero(counts)) &#123;</span><br><span class="line">            <span class="comment">// 注意: 前一个指针的索引是 i - s2.length() + 1</span></span><br><span class="line">            indices.add(i - s2.length() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areAllZero</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：与上一题同理，<strong>时间复杂度为O(n)</strong>, **空间复杂度为O(1)**。</p>
<h3 id="16-不含重复字符的最长子字符串"><a href="#16-不含重复字符的最长子字符串" class="headerlink" title="#16 不含重复字符的最长子字符串"></a>#16 不含重复字符的最长子字符串</h3><p>输入一个字符串，求该字符串中不含重复字符的最长子字符串的长度。</p>
<p>例如：输入字符串”babcca”，其最长的不含重复字符的子字符串是”abc”，长度为3。</p>
<p>分析：</p>
<p>用左右两个指针锁定子字符串，用哈希表存放字符出现的次数。如果两指针之间的子字符串不包含重复字符，则向前移动右指针，否则向前移动左指针。两指针初始化时都在起始位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ASCII码一共256个字符</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 用字符标识索引时，字符会自动转换成对应的ASCII码</span></span><br><span class="line">        counts[s.charAt(i)]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hasGreaterThan1(counts)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            counts[s.charAt(j)]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的j并不是左指针的位置，而是左指针前面的位置，所以不需要i-j+1</span></span><br><span class="line">        longest = Math.max(longest, i - j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasGreaterThan1</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>进一步分析：</p>
<p>每次移动指针的时候都要扫描一次哈希表，虽然哈希表的长度固定，但是这个常数还是有点大。所以最好能有一个不需要多次遍历整个哈希表的解法。</p>
<p>其实我们真正关心的是哈希表中有没有比1大的数字，因为如果有大于的数字就说明子数组中包含重复的数字。可以定义一个变量countDup来存储哈希表中大于1的数字的个数**(其实这个值最大就是1，用boolean变量存也可以)**。当移动右指针导致哈希表中某个数字从1变成2时，变量countDup加1。当移动左指针导致哈希表中某个数字从2变成1时，变量countDup减1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ASCII码一共256个字符</span></span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> countDup = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 用字符标识索引时，字符会自动转换成对应的ASCII码</span></span><br><span class="line">            counts[s.charAt(i)]++;</span><br><span class="line">            <span class="keyword">if</span> (counts[s.charAt(i)] == <span class="number">2</span>) &#123;</span><br><span class="line">                countDup++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (countDup &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                counts[s.charAt(j)]--;</span><br><span class="line">                <span class="comment">// 检查是否有数字从2变成1</span></span><br><span class="line">                <span class="keyword">if</span> (counts[s.charAt(j)] == <span class="number">1</span>) &#123;</span><br><span class="line">                    countDup--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里的j并不是左指针的位置，而是左指针前面的位置，所以不需要i-j+1</span></span><br><span class="line">            longest = Math.max(longest, i - j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="17-包含所有字符串的最短字符串"><a href="#17-包含所有字符串的最短字符串" class="headerlink" title="#17 包含所有字符串的最短字符串"></a>#17 包含所有字符串的最短字符串</h3><p>输入两个字符串s和t，请找出字符串s中包含字符串t的所有字符的最短子字符串。</p>
<p>例如：输入的字符串s为”ADDBANCAD”，字符串t为”ABC”，则字符串s中包含字符’A’, ‘B’, ‘C’的最短子字符串是”BANC”。如果不存在符合条件的子字符串，则返回空字符串””。如果存在多个符合条件的子字符串，则返回任意一个。</p>
<p>分析：</p>
<p>用两个指针定位子字符串。如果某一时刻两个指针之间之间的子字符串还没有包含字符串t的所有字符，则在子字符串中添加新的字，于是向右移动第二个指针。如果已经包含字符串t的所有字符，则向右移动第一个指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; charToCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : t.toCharArray()) &#123;</span><br><span class="line">        charToCount.put(ch, charToCount.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当count等于0时，两指针之间的子字符串就包含t中的所有字符</span></span><br><span class="line">    <span class="keyword">int</span> count = charToCount.size();</span><br><span class="line">    <span class="comment">// start, end分别为两个指针</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, minStart = <span class="number">0</span>, minEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; s.length() || (count == <span class="number">0</span> &amp;&amp; end == s.length())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">// end &lt; s.length()</span></span><br><span class="line">            <span class="keyword">char</span> endCh = s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span> (charToCount.containsKey(endCh)) &#123;</span><br><span class="line">                charToCount.put(endCh, charToCount.get(endCh) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (charToCount.get(endCh) == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向右移动第二个指针</span></span><br><span class="line">            end++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// count == 0 &amp;&amp; end == s.length()</span></span><br><span class="line">            <span class="keyword">if</span> (end - start &lt; minLength) &#123;</span><br><span class="line">                minLength = end - start;</span><br><span class="line">                minStart = start;</span><br><span class="line">                minEnd = end;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> startCh = s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (charToCount.containsKey(startCh)) &#123;</span><br><span class="line">                charToCount.put(startCh, charToCount.get(startCh) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (charToCount.get(startCh) == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向右移动第一个指针</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minLength &lt; Integer.MAX_VALUE ? s.substring(minStart, minEnd) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>只有一个while循环，把两个变量从0增加到字符串s的长度。所以**时间复杂度为O(n)<strong>。哈希表的键为字符，假设字符串中只有英文字母，所以哈希表的大小不会超过256。因此</strong>空间复杂度为O(1)**。</p>
<h3 id="18-有效的回文"><a href="#18-有效的回文" class="headerlink" title="#18 有效的回文"></a>#18 有效的回文</h3><p>给定一个字符串，请判断它是不是回文。假设只需考虑字母和数字字符，并忽略大小写。</p>
<p>例如：”Was it a cat I saw”是一个回文字符串，而”race a car”不是回文字符串。</p>
<p>分析：</p>
<p>可以用双指针，一个从前向后移动，另一个从后向前移动。如果两指针指向的字符相同，则继续移动，直到两个指针相遇。<strong>注意：题目只考虑字母和数字字符，所以如果指针指向的字符既不是字母也不是数字，则跳过该字符。同时，由于忽略大小写，所以要把所有字母转换成相同的形式再做比较。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = s.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> ch2 = s.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (!Character.isLetterOrDigit(ch1)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isLetterOrDigit(ch2)) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ch1 = Character.toLowerCase(ch1);</span><br><span class="line">            ch2 = Character.toLowerCase(ch2);</span><br><span class="line">            <span class="keyword">if</span> (ch1 != ch2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在改变字母大小写时，建议操作字符而不是字符串。因为java中字符串不可变，修改字符串会创建新的字符串，造成内存浪费。</p>
<p>复杂度分析：</p>
<p>两个指针遍历字符串，**时间复杂度为O(n)**。</p>
<h3 id="19-最多删除一个字符得到回文"><a href="#19-最多删除一个字符得到回文" class="headerlink" title="#19 最多删除一个字符得到回文"></a>#19 最多删除一个字符得到回文</h3><p>给定一个字符串，请判断如果最多从字符串中删除一个字符能不能得到一个回文字符串。</p>
<p>例如：如果输入字符串”abca”，由于删除字符串’b’或’c’就能得到一个回文字符串，因此输出为true。</p>
<p>分析：</p>
<p>与上一题类似，还是用双指针从两侧开始向里逐步比较。如果字符相同，则继续比较。如果字符不同，则按题目要求，删除一个字符后比较剩下的字符。因为不知道删除两个不同字符中的哪一个，因此都可以进行尝试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当start == s.length() / 2说明是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(; start &lt; s.length() / <span class="number">2</span>; start++, end--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start) != s.charAt(end)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> start == s.length() / <span class="number">2</span></span><br><span class="line">                || isPalindrome(s, start, end - <span class="number">1</span>)</span><br><span class="line">                || isPalindrome(s, start + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) != s.charAt(end)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start &gt;= end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：最坏情况，从左右两端第一个字符开始就出现分歧，需要判断删除的情况。此时需要遍历字符串两遍，**时间复杂度O(n)**。</p>
<h3 id="20-回文子字符串的个数"><a href="#20-回文子字符串的个数" class="headerlink" title="#20 回文子字符串的个数"></a>#20 回文子字符串的个数</h3><p>给定一个字符串，请问该字符串中有多少个回文连续子字符串？</p>
<p>例如：字符串”aaa”有6个回文子字符串，分别为”a”, “a”, “a”, “aa”, “aa” 和 “aaa”。</p>
<p>分析：</p>
<p>同样用双指针来求解，但是思路略有不同。我们考虑从字符串的中心开始向两端延申。<strong>注意：回文的长度可以是奇数也可以是偶数。长度为奇数的回文对称中心只有一个字符，而长度为偶数的回文对称中心有两个字符。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        count+= countPalindrome(s, i, i);</span><br><span class="line">        count+= countPalindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.length()</span><br><span class="line">           &amp;&amp; s.charAt(start) == s.charAt(end)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        start--;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<p>for循环嵌套while循环，**时间复杂度为O(n^2)**。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单向链表的简单定义"><a href="#单向链表的简单定义" class="headerlink" title="#单向链表的简单定义"></a>#单向链表的简单定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="哨兵节点"><a href="#哨兵节点" class="headerlink" title="#哨兵节点"></a>#哨兵节点</h3><p>哨兵节点是为了简化处理链表边界条件而引入的附加链表节点。哨兵节点通常位于链表的头部，它的值没有任何意义。在一个有哨兵节点的链表中，从第2个节点开始才真正保存有意义的信息。</p>
<p><strong>用哨兵节点简化链表的插入操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">append</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode newNode = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="comment">// 索引到链表的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.next = newNode;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码需要用if语句来单独处理输入头节点head为null的情形。可以用哨兵节点简化代码的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">append</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode newNode = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">    ListNode node = dummy;</span><br><span class="line">    <span class="comment">// 索引到链表的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.next = newNode;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>用哨兵节点简化链表的删除操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">delete</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断删除的节点是否是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head.val == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next.val == value) &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码用两条if语句来处理两个特殊情况</p>
<ol>
<li>输入的链表为空</li>
<li>被删除的节点是原始链表的头节点</li>
</ol>
<p>可以用哨兵节点简化代码逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">delete</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode node = dummy;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next.val == value) &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>合理应用哨兵节点，就不再需要单独处理这些特殊的输入。</strong></p>
<h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="#双指针"></a>#双指针</h3><p>按移动方式可以细分成两种不同的方法。</p>
<ol>
<li>前后双指针，即一个指针在链表中提前朝着指向下一个节点的指针移动若干步，然后移动第二个指针。<strong>前后双指针的经典应用是查找链表的倒数第k个节点。</strong></li>
<li>快慢双指针，即两个指针在链表中移动的速度不一样，通常是快的指针朝着指向下一个节点的指针一次移动两步，慢的指针一次只移动一步。<strong>采用这种方法，在一个没有环的链表中，当快的指针到达链表尾节点的时候慢的指针正好指向链表的中间节点。</strong></li>
</ol>
<h3 id="21-删除倒数第k个节点"><a href="#21-删除倒数第k个节点" class="headerlink" title="#21 删除倒数第k个节点"></a>#21 删除倒数第k个节点</h3><p>如果给定一个链表，请问如何删除链表中的倒数第k个节点？假设链表中节点的总数为n，那么1&lt;=k&lt;=n。要求只能遍历链表一次。</p>
<p>例如：</p>
<p>输入链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，删除倒数第2个节点之后的链表为</p>
<p>1-&gt;2-&gt;3-&gt;4-&gt;6</p>
<p>分析：</p>
<p>如果可以遍历链表两次，那么这个问题就会变得简单。在第1次遍历链表时，可以得出链表的节点总数n。在第2次遍历链表时，可以找出链表的第n-k个节点(即倒数第k+1个节点)，然后通过修改指针，即可删除倒数第k个节点。</p>
<p>但是题目要求只能遍历链表一次。我们可以定义两个指针，来遍历一次就找到倒数第k+1个节点。第一个指针P1从链表头节点开始先走k步，第二个指针P2保持不动；从第k+1步开始指针P2也从链表的头节点开始和指针P1以相同的速度遍历。由于两个指针的距离始终保持为k，当指针P1指向链表的尾节点时指针P2正好指向倒数第k+1个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode front = head, back = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        front = front.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为前指针是从head开始，相当于开始时多走了一步</span></span><br><span class="line">    <span class="comment">// 所以判断条件为front != null 而不是 front.next != null</span></span><br><span class="line">    <span class="keyword">while</span> (front != <span class="keyword">null</span>) &#123;</span><br><span class="line">        front = front.next;</span><br><span class="line">        back = back.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    back.next = back.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：遍历列表一边，**时间复杂度为O(n)**。</p>
<h3 id="22-链表中环的入口节点"><a href="#22-链表中环的入口节点" class="headerlink" title="#22 链表中环的入口节点"></a>#22 链表中环的入口节点</h3><p>如果一个链表中包含环，那么应该如何找出环的入口节点？从链表的头节点开始顺着next指针方向进入环的第1个节点为环的入口节点。</p>
<p>例如：下图所示的链表中，环的入口节点是3。</p>
<p><img src="image-20211102122856262.png" alt="image-20211102122856262"></p>
<p>分析：</p>
<ol>
<li><p>第一步是确定一个链表中是否包含环。如果链表中没有环，自然不存在环的入口节点，此时应该返回null。</p>
<p>可以用两个指针来判断链表中是否有环。指针P1，P2同时从头节点出发，P1一次走一步，P2一次走两步。如果链表中不包含环，P2指针直至抵达链表的尾节点都不会和走得慢的指针相遇。如果链表中包含环，走得快的指针在环里绕了一圈之后将会追上走得慢的指针。因此，<strong>可以根据一快一慢两个指针能否相遇来判断链表中是否包含环。</strong></p>
</li>
<li><p>第二步是如何找到环的入口节点，还是可以用两个指针来解决。先定义两个指针P1，P2指向指向链表的头节点。如果链表中的环有n个节点，指针P1先在链表中向前移动n步，然后两个指针以相同的速度向前移动。当指针P2指向环的入口时，指针P1已经围绕环走了一圈又回到了入口节点。</p>
<p><img src="image-20211102124559505.png" alt="image-20211102124559505"></p>
</li>
<li><p>最后一个问题是如何得到环中节点的数目。前面用一快一慢两个指针判断链表中是否存在环时，两个指针相遇的节点一定在环中。可以从这个相遇的节点出发一边继续向前移动一边计数，当再次回到这个节点时就可以得到环中节点的数目。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">getNodeInLoop</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实两个指针不是必须都从头节点出发</span></span><br><span class="line">    <span class="comment">// 只要一快一慢两个指针相遇，即可判断成环</span></span><br><span class="line">    ListNode slow = head.next;</span><br><span class="line">    ListNode fast = slow.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle1</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode inLoop = getNodeInLoop(head);</span><br><span class="line">    <span class="keyword">if</span> (inLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到环中的节点数量n</span></span><br><span class="line">    <span class="keyword">int</span> loopCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ListNode n = inLoop; n.next != inLoop; n = n.next) &#123;</span><br><span class="line">        loopCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针先向前移动n步</span></span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopCount; i++) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针一起移动直至相遇</span></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>分析：</p>
<ol start="4">
<li><p>上述解法需要求出链表的环中节点的数目。但是如果仔细分析，就会发现没必要求出环中节点的数目。慢的指针一次走一步，假设在相遇时慢的指针走了k步。由于快的指针一次走两步，因此在相遇时快的指针一共走了2k步。因此相遇时慢的指针比快的指针多走了k步。另外，两指针相遇时快的指针比慢的指针在环中多转了若干全，也就是说，<strong>快指针多走的步数k一定是环中节点数目的整数倍。满指针走过的步数k也是环中节点数目的整数倍。</strong></p>
<p>基于此思想，可以让一个指针指向相遇的节点，该指针的位置是之前慢的指针走了k步到达的位置。接着让另一个指针指向链表的头节点，然后两个指针以相同的速率一起移动，<strong>此时两指针相遇，前指针比后指针多走k步，相遇的节点刚好是环的入口节点</strong>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode inLoop = getNodeInLoop(head);</span><br><span class="line">    <span class="keyword">if</span> (inLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inLoop提前移动了k步，node指向头节点</span></span><br><span class="line">    <span class="comment">// 然后两者以相同速率一起移动</span></span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != inLoop) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        inLoop = inLoop.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="23-两个链表的第1个重合节点"><a href="#23-两个链表的第1个重合节点" class="headerlink" title="#23 两个链表的第1个重合节点"></a>#23 两个链表的第1个重合节点</h3><p>输入两个单向链表，如何找出它们的第1个重合节点。</p>
<p>例如：</p>
<p><img src="image-20211102144127782.png" alt="image-20211102144127782"></p>
<p>此时两个链表的第1个重合节点的值是4。</p>
<p>分析：</p>
<p>很直观地想到暴力法求解。在第1个链表中按顺序遍历每个节点，每遍历到一个节点时，在第2个链表中顺序遍历每个节点，然后进行比较。如果第1个链表的长度为m，第2个链表的长度为n，那么该方法的时间复杂度是O(mn)。蛮力法一般不是最好的解法， 所以进一步分析此种链表的特点以求突破。</p>
<p>特点1：可以在重合的两个链表的基础上构造一个包含环的链表。</p>
<p><img src="image-20211102145829302.png" alt="image-20211102145829302"></p>
<p>此时，环的入口节点即是两个链表的第1个重合节点。可以利用上一题的方法解决。</p>
<p>特点2：如果两个单向链表有重合节点，那么从某个节点开始这两个链表的next指针都指向同一个节点。</p>
<p>那么如果我们可以从链表的尾部开始比较，最后一个相同的节点就是我们要找的节点。想要实现从尾部开始比较，可以利用栈这种先进后出的结构。将两个链表分别入栈，然后比较栈顶结点。如果两链表的长度分别为m，n，此种方法的**时间复杂度为O(m+n)<strong>。</strong>空间复杂度也为O(m+n)**。</p>
<p>上述方法之所以要用栈，是因为我们希望能同时到达两个链表的尾节点。当两个链表的长度不同时，如果从头开始遍历，到达尾节点的时间就不一致。其实解决这个问题有更简单的方法：首先遍历两个链表得到它们的长度，这样就能知道哪个链表比较长，以及长链表比短链表多几个节点。假设长链表比短链表多k个节点。第2次遍历时，指针P1，P2分别指向长短链表的头部。指针P1先在长链表中移动k步，然后两指针同时移动，此时两指针相遇的节点即是第一个公共节点。此种方法的**时间复杂度也是O(m+n)<strong>，</strong>由于不需要用栈，空间复杂度为O(1)**。</p>
<p><img src="image-20211102151210407.png" alt="image-20211102151210407"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count1 = countList(headA);</span><br><span class="line">    <span class="keyword">int</span> count2 = countList(headB);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> delta = Math.abs(count1 - count2);</span><br><span class="line">    ListNode longer = count1 &gt; count2 ? headA : headB;</span><br><span class="line">    ListNode shorter = count1 &gt; count2 ? headB : headA;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++) &#123;</span><br><span class="line">        longer = longer.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (longer != shorter) &#123;</span><br><span class="line">        shorter = shorter.next;</span><br><span class="line">        longer = longer.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="#24 反转链表"></a>#24 反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>例如：</p>
<p><img src="image-20211102152116962.png" alt="image-20211102152116962"></p>
<p>分析：</p>
<p>在调整节点指针时，除了需要知道节点本身，还要知道它的前一个节点和后一个节点。所以在遍历链表逐个反转每个节点的next指针时需要用到3个指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：遍历链表一边，**时间复杂度O(n)<strong>，</strong>空间复杂度O(1)**。</p>
<h3 id="25-链表中的数字相加"><a href="#25-链表中的数字相加" class="headerlink" title="#25 链表中的数字相加"></a>#25 链表中的数字相加</h3><p>给定两个表示非负整数的单向链表，请问如何实现这两个整数的相加并把它们的和仍然用单向链表表示？链表中的每个节点表示整数十进制的一位，并且头节点对应整数的最高位而尾节点对应整数的个位。</p>
<p>例如：</p>
<p><img src="image-20211102154056177.png" alt="image-20211102154056177"></p>
<p>分析：</p>
<p>第一反应是，根据链表求出整数，然后将整数相加，最后把结果用链表表示。<strong>这种思路最大的问题是没考虑到整数有可能会溢出</strong>，当链表较长时，可能会超出int甚至long的范围。</p>
<p>通常两整数相加，都是先算低位再算高位，因为还要考虑进位的问题。所以想到可以把链表反转，然后在逐个节点上实现加法。最后把表示和的链表反转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    head1 = reverseList(head1);</span><br><span class="line">    head2 = reverseList(head2);</span><br><span class="line">    ListNode reversedHead = addReversed(head1, head2);</span><br><span class="line">    <span class="keyword">return</span> reverseList(reversedHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">addReversed</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode sumNode = dummy;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> || head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (head1 == <span class="keyword">null</span> ? <span class="number">0</span> : head1.val)</span><br><span class="line">            + (head2 == <span class="keyword">null</span> ? <span class="number">0</span> : head2.val) + carry;</span><br><span class="line">        carry = sum &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        sum = sum &gt;= <span class="number">10</span> ? sum - <span class="number">10</span> : sum;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line"></span><br><span class="line">        sumNode.next = newNode;</span><br><span class="line">        sumNode = sumNode.next;</span><br><span class="line"></span><br><span class="line">        head1 = head1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : head1.next;</span><br><span class="line">        head2 = head2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : head2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后的进位</span></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sumNode.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="26-重排链表"><a href="#26-重排链表" class="headerlink" title="#26 重排链表"></a>#26 重排链表</h3><p>给定一个链表，链表中节点的顺序是L0-&gt;L1-&gt;L2-&gt;…-&gt;Ln-1-&gt;Ln，请问如何重排链表使节点的顺序变成L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;L2-&gt;Ln-2…</p>
<p>例如：</p>
<p><img src="image-20211102160234120.png" alt="image-20211102160234120"></p>
<p>分析：</p>
<p>观察输入链表和输出链表之间的关系，发现重排链表实际上是把链表分成前后两半。在示例链表中，前半段包含1、2、3三个节点，后半段包含4、5、6三个节点。然后把后半段链表反转，再与前半段链表拼接。</p>
<p>首先需要解决的问题是如何把一个链表分成两半，即找到链表的中间节点。可以一快一慢两个指针实现。两个指针同时从链表的头节点出发，快的指针一次走两步，慢的指针一次走一步，当快的指针走到链表的尾节点时，慢的指针刚好走到链表的中间节点。要注意：链表的节点总数可能是奇数也可能是偶数。当链表的节点总数是奇数时，要确保链表的前半段比后半段多一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode fast = dummy;</span><br><span class="line">    ListNode slow = dummy;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode temp = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    link(head, reverseList(temp), dummy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(ListNode node1, ListNode node2, ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = head;</span><br><span class="line">    <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = node1.next;</span><br><span class="line"></span><br><span class="line">        prev.next = node1;</span><br><span class="line">        node1.next = node2;</span><br><span class="line">        prev = node2;</span><br><span class="line"></span><br><span class="line">        node1 = temp;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.next = node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，当变量fast指向尾节点时，变量slow指向前半段的最后一个节点。</p>
<h3 id="27-回文链表"><a href="#27-回文链表" class="headerlink" title="#27 回文链表"></a>#27 回文链表</h3><p>如何判断一个链表是不是回文？要求解法的时间复杂度是O(n)，并且不得使用超过O(1)的辅助空间。</p>
<p>例如：</p>
<p><img src="image-20211107151640955.png" alt="image-20211107151640955"></p>
<p>分析：</p>
<p>如果不考虑辅助空间的限制，直观的解法是创建一个新的链表，链表中的节点顺序和输入链表的节点顺序正好相反。二者比较即可判断是否是回文链表，此时需要O(n)的辅助空间。</p>
<p>分析回文链表的特点以找出更好的解法。回文链表的一个特性是对称性，也就是说，如果把链表分为前后两半，那么前半段链表反转之后与后半段链表是相同的。因此可以想到把链表分成前后两半，然后把其中一半反转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode secondHalf = slow.next;</span><br><span class="line">    <span class="comment">// 如果fast.next != null，说明链表中节点个数为奇数</span></span><br><span class="line">    <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 跳过中间节点</span></span><br><span class="line">        secondHalf = slow.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> equals(secondHalf, reverseList(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.val != head2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head1 = head1.next;</span><br><span class="line">        head2 = head2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head1 == <span class="keyword">null</span> &amp;&amp; head2 == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，不管链表的节点总数是奇数还是偶数，变量slow都指向链表前半段的最后一个节点。</p>
<h3 id="双向链表和循环链表"><a href="#双向链表和循环链表" class="headerlink" title="双向链表和循环链表"></a>双向链表和循环链表</h3><p>由于单向链表只能从头节点开始遍历到尾节点，遍历的顺序受到限制，在很多场景下使用起来不太方便，因此双向链表应运而生。双向链表在单向链表节点的基础上增加了指向前一个节点的指针，这样一来，既可从前往后遍历，也可以从后向前遍历。</p>
<p>如果把链表尾节点的下一个节点的指针指向链表的头节点，那么此时链表就变成一个循环链表。循环链表既可以是单向链表，也可以是双向链表。</p>
<h3 id="28-展平多级双向链表"><a href="#28-展平多级双向链表" class="headerlink" title="#28 展平多级双向链表"></a>#28 展平多级双向链表</h3><p>在一个多级双向链表中，节点除了有两个指针分别指向前后两个节点，还有一个指针指向它的子链表，并且子链表也是一个双向链表，它的节点也有指向子链表的指针。请将这样的多级双向链表展成普通的双向链表，即所有节点都没有子链表。</p>
<p>例如：</p>
<p><img src="image-20211107160039114.png" alt="image-20211107160039114"></p>
<p>分析：</p>
<p>展平的规则是一个节点的子链表展平之后将插入该节点和它的下一个节点之间。由于子链表中的节点也有可能有子链表，<strong>因此这里的链表是一个递归的结构</strong>。在展平子链表时，如果它也有自己的子链表，那么它嵌套的子链表也要一起展平。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    flattenGetTail(head);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">flattenGetTail</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node node = head;</span><br><span class="line">    Node tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        <span class="keyword">if</span> (node.child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node child = node.child;</span><br><span class="line">            Node childTail = flattenGetTail(node.child);</span><br><span class="line"></span><br><span class="line">            node.child = <span class="keyword">null</span>;</span><br><span class="line">            node.next = child;</span><br><span class="line">            child.prev = node;</span><br><span class="line">            childTail.next = next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                next.prev = childTail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tail = childTail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，递归函数flattenGetTail在展平以head为头节点的链表之后返回链表的尾节点。在该函数中需要逐一扫描链表中的节点。如果一个节点node有子链表，由于子链表也可能有嵌套的子链表，因此先递归调用flattenGetTail函数展平子链表，子链表展平之后头节点时child，尾节点是childTail。最后将展平的子链表插入节点node和它的下一个节点next之间，即把展平的子链表头节点child插入节点node之后，并将尾节点childTail插入节点next之前。</p>
<p>这种解法每个节点都会遍历一次，如果链表总共有n个节点，那么时间复杂度时O(n)。函数flattenGetTail的递归调用次数取决于链表嵌套的次数，因此，如果链表的层数为k，那么该节点的空间复杂度是O(k)。</p>
<h3 id="29-排序的循环链表"><a href="#29-排序的循环链表" class="headerlink" title="#29 排序的循环链表"></a>#29 排序的循环链表</h3><p>在一个循环链表中节点的值递增排序，请设计一个算法在该循环链表中插入节点，并保证插入节点之后循环链表仍然是排序的。</p>
<p>例如：</p>
<p><img src="image-20211107163817220.png" alt="image-20211107163817220"></p>
<p>分析：</p>
<p>再插入节点4时，新的节点位于3，5节点之间。为了使插入新节点后循环链表仍然是排序的，新节点的前一个节点的值应该比新节点的值小，后一个节点的值应该比新节点大。</p>
<p>但是特殊情况需要特殊处理。</p>
<p>特殊情况1：如果新节点是链表中最大或最小的节点，新的节点将被插入到最大值和最小值之间。</p>
<p>特殊情况2：如果链表中的节点数小于2，那么应该有两种可能。第1种可能是开始的时候链表是空的，一个节点都没有，此时插入一个新的节点，该节点成为循环链表中唯一的节点，那么next指针指向节点自己。第2种可能是开始的时候链表中只有一个节点，插入一个新的节点之后，两个节点的next指针互相指向对方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">insert</span> <span class="params">(Node head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(insertVal);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        head.next = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == head) &#123;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.next = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertCore(head, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertCore</span><span class="params">(Node head, Node node)</span> </span>&#123;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = head.next;</span><br><span class="line">    Node biggest = head;</span><br><span class="line">    <span class="comment">// 如果是因为不满足next != head退出，表示新节点是链表中最大或最小的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!(cur.val &lt;= node.val &amp;&amp; next.val &gt;= node.val &amp;&amp; next != head)) &#123;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; biggest.val) &#123;</span><br><span class="line">            biggest = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur.val &lt;= node.val &amp;&amp; next.val &gt;= node.val) &#123;</span><br><span class="line">        cur.next = node;</span><br><span class="line">        node.next = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.next = biggest.next;</span><br><span class="line">        biggest.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="30-插入、删除和随机访问都是O-1-的容器"><a href="#30-插入、删除和随机访问都是O-1-的容器" class="headerlink" title="#30 插入、删除和随机访问都是O(1)的容器"></a>#30 插入、删除和随机访问都是O(1)的容器</h3><p>设计一个数据结构，使如下3个操作的时间复杂度都是O(1)。</p>
<ul>
<li>insert(value)：如果数据集种不包含一个数值，则把它添加到数据集中。</li>
<li>remove(value)：如果数据集中包含一个数值，则把它删除。</li>
<li>getRandom()：随机返回数据集中的一个数值，要求数据集中每个数字被返回的概率都相同。</li>
</ul>
<p>分析：</p>
<p>由于要求插入和删除的时间复杂度都是O(1)，因此需要用哈希表来实现。</p>
<p>如果只用哈希表，则不能等概率地返回其中的每个数值。如果数值是保存在数组中的，那么很容易实现等概率地返回其中的每个数值。假设数组的长度是n，那么等概率生成从0到n-1的一个数字。如果生成的随机数是i，则返回数组中下标为i的数值。由此可以发现，需要结合哈希表和数组来设计这个数据容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; numToLocation;</span><br><span class="line">    ArrayList&lt;Integer&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        numToLocation = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numToLocation.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        numToLocation.put(val, nums.size());</span><br><span class="line">        nums.add(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!numToLocation.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用数组中最后一个元素覆盖要删除的元素，并修改哈希表中对应位置的键值对</span></span><br><span class="line">        <span class="keyword">int</span> location = numToLocation.get(val);</span><br><span class="line">        numToLocation.put(nums.get(nums.size() - <span class="number">1</span>), location);</span><br><span class="line">        numToLocation.remove(val);</span><br><span class="line">        nums.set(location, nums.get(nums.size() - <span class="number">1</span>));</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> r = random.nextInt(nums.size());</span><br><span class="line">        <span class="keyword">return</span> nums.get(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="31-最近最少使用缓存"><a href="#31-最近最少使用缓存" class="headerlink" title="#31 最近最少使用缓存"></a>#31 最近最少使用缓存</h3><p>设计实现一个最近最少使用(Least Recently Used, LRU)缓存，要求如下两个操作的时间复杂度都是O(1)。</p>
<ul>
<li>get(key)：如果缓存中存在键key，则返回它对应的值，否则返回-1</li>
<li>put(key,value)：如果缓存中之前包含key，则它的值设为value；否则添加键key及对应的值value。在添加一个键时，如果缓存容量已经满了，则在添加新键之前删除最近最少使用的键(缓存中最长时间没有被使用过的元素)。</li>
</ul>
<p>分析：</p>
<p>哈希表的get和put操作的时间复杂度都是O(1)，但普通的哈希表无法找出最近最少使用的键，因此需要在哈希表的基础上进行改进。</p>
<p>由于需要知道缓存中最近最少使用的元素，因此可以把缓存中的元素存入链表中。每次访问一个元素(无论是通过get还是put操作)，该元素都被移到链表的尾部。这样，<strong>位于链表头部的元素就是最近最少使用的。</strong></p>
<p>如果这个链表是单向链表，那么找到一个节点的前一个节点需要从链表的头节点开始遍历链表，需要O(n)的时间。因此可以用双向链表来存储缓存中的元素。在双向链表中查找一个结点的前一个节点，只需要顺着prev指针向前走一步，时间复杂度为O(1)。</p>
<p>首先定义双向链表中的节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    <span class="keyword">public</span> ListNode prev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后定义最近最少使用缓存的数据结构。缓存中包含一个哈希表，哈希表的键就是缓存的键，哈希表的值是双向链表中的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line">    <span class="keyword">private</span> ListNode tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ListNode&gt; map;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个容量为cap的缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line"></span><br><span class="line">        capacity = cap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了便于在双向链表中添加和删除节点，上述代码创建了两个哨兵节点，即head和tail，他们分别位于双向链表的头部和尾部。函数put所添加的节点将位于这两个节点之间。</p>
<p>接下来实现get，put及辅助函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    ListNode node = map.get(key);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    moveToTail(node, node.value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">        moveToTail(map.get(key), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">            ListNode toBeDelete = head.next;</span><br><span class="line">            deleteNode(toBeDelete);</span><br><span class="line"></span><br><span class="line">            map.remove(toBeDelete.key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(key, value);</span><br><span class="line">        insertToTail(node);</span><br><span class="line"></span><br><span class="line">        map.put(key, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToTail</span><span class="params">(ListNode node, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    deleteNode(node);</span><br><span class="line"></span><br><span class="line">    node.value = newValue;</span><br><span class="line">    insertToTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.prev.next = node.next;</span><br><span class="line">    node.next.prev = node.prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertToTail</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    tail.prev.next = node;</span><br><span class="line">    node.prev = tail.prev;</span><br><span class="line">    node.next = tail;</span><br><span class="line">    tail.prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="32-有效的变位词"><a href="#32-有效的变位词" class="headerlink" title="#32 有效的变位词"></a>#32 有效的变位词</h3><p>给定两个字符串s和t，请判断它们是不是一组变位词。在一组变位词中，他们中的字符及每个字符出现的次数都相同， 但字符的顺序不能相同。</p>
<p>例如：</p>
<p>“anagram”和”nagaram”就是一组变位词。</p>
<p>分析：</p>
<p>由于变位词和字符出现的次数相关，因此可以用一个哈希表来存储每个字符出现的次数。哈希表的键是字符，而值是对应字符出现的次数。<strong>如果哈希表的键取值范围是固定的，而且范围不是很大，则可以用数组来模拟哈希表。</strong></p>
<p>如果只考虑英文字母，则用数组来模拟哈希表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram1</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 长度不同一定不是同位词</span></span><br><span class="line">    <span class="keyword">if</span> (str1.length() != str2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符顺序相同也不是同位词</span></span><br><span class="line">    <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str1.toCharArray()) &#123;</span><br><span class="line">        counts[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str2.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counts[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入字符串的长度为n，上述解法的**时间复杂度为O(n)<strong>。不管字符串的长度如何，辅助数组的长度都是固定的，因此</strong>空间复杂度是O(1)**。</p>
<p>如果考虑用字符串表示中文或其他非英语语言，那么ASCII码字符集是不够的。因为一个ASCII码字符的长度为8位，所以ASCII码字符集能包含256个不同的字符，中文及很多语言的字符集都远远超过这个数字。为了包含更多的字符，需要其他编码的字符集，目前使用最多的是Unicode编码。一个Unicode的字符的长度为16位，这样就能表示65536个字符。此种情况下，如果还和之前一样，创建一个长度为65536的数组，似乎会浪费内存。所以此时就可以创建一个类型为HashMap的真正的哈希表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram2</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1.length() != str2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str1.toCharArray()) &#123;</span><br><span class="line">        counts.put(ch, counts.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str2.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counts.containsKey(ch) || counts.get(ch) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counts.put(ch, counts.get(ch) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的**时间复杂度仍然是O(n)<strong>。但是如果输入的字符串中不同字符的数目越多，HashMap就需要越多的空间。因此，可以认为使用HashMap的</strong>空间复杂度是O(n)**。</p>
<h3 id="33-变位词组"><a href="#33-变位词组" class="headerlink" title="#33 变位词组"></a>#33 变位词组</h3><p>给定一组单词，请将他们按照变位词分组。假设单词中只包含英文小写字母。</p>
<p>例如：输入一组单词[“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]，这组单词可以分成三组，分别是[“eat”, “tea”, “ate”]、[“tan”, “nat”]、[“bat”]。</p>
<p>分析：</p>
<p>解决这个问题，就需要找出一组变位词共同的特性，然后依据此特性把它们分到一组。这里主要介绍两种方法：</p>
<ol>
<li><p>将单词映射到数字。把每个英文小写字母映射到一个质数，如把字母’a’映射到数字2，字母’b’映射到数字3，以此类推。字母’z’映射到第26个质数101。每给出一个单词，就把单词中的所有字母对应的数字相乘，于是每个单词都可以算出一个数字。例如，单词’eat’可以映射到数字1562(11*2*71)。’</p>
<p>如果两个单词护卫变位词，那么它们中每个字母出现的次数都对应相同，由于乘法满足交换律，因此上述算法把一组变位词映射到同一个数值。由于每个字母都是映射到一个质数，因此不互为变位词的两个单词一定会映射到不同的数字。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams1(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">int</span> hash[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Map&lt;Long, List&lt;String&gt;&gt; groups = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="keyword">long</span> wordHash = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            wordHash *= hash[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        groups.putIfAbsent(wordHash, <span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">        groups.get(wordHash).add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(groups.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入n个单词，平均每个单词有m个字母，那么该算法的时间复杂度是O(mn)。</p>
<p>该算法有一个潜在的问题：<strong>由于把单词映射到数字用到了乘法，因此当单词非常长时，乘法就有可能溢出</strong>。</p>
<ol start="2">
<li>将单词的字母排序。互为变位词的单词排序后会得到相同的字符串。因此可以定义一个哈希表，哈希表的键是把单词字母排序得到的字符串，而值是一组变位词。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams2(String[] strs) &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; groups = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        Arrays.sort(charArray);</span><br><span class="line">        String sorted = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">        groups.putIfAbsent(sorted, <span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">        groups.get(sorted).add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(groups.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果每个单词平均有m个字母，排序一个单词需要O(mlogm)的时间，假设总共有n个单词，该算法总的时间复杂度是<strong>O(nmlogm)<strong>。</strong>虽然该方法的时间效率不如前一种方法，但是该方法不用担心乘法可能带来的溢出问题。</strong></p>
<h3 id="34-外星语言是否排序"><a href="#34-外星语言是否排序" class="headerlink" title="#34 外星语言是否排序"></a>#34 外星语言是否排序</h3><p>y偶一门外星语言，它的子目标刚好包含所有的英文小写字母，只是字母表的顺序不同。给定一组单词和字母表顺序，请判断这些单词是否按照字母表的顺序排序。</p>
<p>例如：输入一组单词[“offer”, “is”, “comming”]，以及字母表顺序”zyxwvutsrqponmlkjihgfedcba”，由于字母’o’在字母表中位于’i’的前面，因此单词”offer”排在”is”的前面；同理，单词”is”排在”comming”的前面。因此，这一组单词是按照字母表顺序排序的，应该输出true。</p>
<p>分析：</p>
<p>为了方便查找每个字母在字母表中的顺序，可以创建一个哈希表，哈希表的键为字母表的每个字母，而值为字母在字母表中的顺序。字母表中字母的数目是固定的，一共26个。所以可以用数组来模拟哈希表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlienSorted</span><span class="params">(String[] words, String order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] orderArray = <span class="keyword">new</span> <span class="keyword">int</span>[order.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.length(); i++) &#123;</span><br><span class="line">            orderArray[order.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSorted(words[i], words[i + <span class="number">1</span>], orderArray)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(String word1, String word2, <span class="keyword">int</span>[] order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; word1.length() &amp;&amp; i &lt; word2.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = word1.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> ch2 = word2.charAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (order[ch1 - <span class="string">&#x27;a&#x27;</span>] &lt; order[ch2 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (order[ch1 - <span class="string">&#x27;a&#x27;</span>] &gt; order[ch2 - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i == word1.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入n个单词，每个单词的平均长度为m，那么该算法的**时间复杂度是O(mn)<strong>，</strong>空间复杂度是O(1)**。</p>
<h3 id="35-最小时间差"><a href="#35-最小时间差" class="headerlink" title="#35 最小时间差"></a>#35 最小时间差</h3><p>给定一组范围在00:00至23:59的时间，求任意两个时间之间的最小时间差。</p>
<p>例如：输入时间数组[“23:50”, “23:59”, “00:00”]，”23:59”和”00:00”之间只有1分钟的间隔，是最小的时间差。</p>
<p>分析：</p>
<p>最直观的解法是求出任意两个时间的间隔，然后得出最小的是价差。如果输入n个时间，这种蛮力法需要O(n^2)的时间。</p>
<p>上述解法的一个优化是把n个时间排序，排序后只需要计算两相邻时间之间的间隔，这样就只需要计算O(n)个时间差。由于对n个时间进行排序通常需要O(nlogn)的时间，因此这种优化算法的总体时间复杂度是O(nlogn)。</p>
<p>一个特殊情况需要考虑：”00:00”也有可能是第二天的00:00，所以在计算时要考虑到两种情况: </p>
<ol>
<li>最小时间间隔出现在同一天</li>
<li>最小时间间隔需要和第二天00:00比较</li>
</ol>
<p>一天有24小时，即1440分钟。如果用一个长度为1440的数组表示一天的时间，那么数组的下标为0的位置对应时间00:00，下表为1的位置对应时间00:01。数组中的每个元素是true或false标识。由于数组的下标对应的是时间，因此两个时间之间的时间差就是他们在数组中对应的下标之差。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 列表长度大于1440，则一定出现了两个相同时间，所以最小时间间隔为0</span></span><br><span class="line">    <span class="keyword">if</span> (timePoints.size() &gt; <span class="number">1440</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> minutesFlags[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1440</span>];</span><br><span class="line">    <span class="keyword">for</span> (String time : timePoints) &#123;</span><br><span class="line">        String t[] = time.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> min = Integer.parseInt(t[<span class="number">0</span>]) * <span class="number">60</span> + Integer.parseInt(t[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 如果为true，则列表中出现了两个相同时间，即最小时间间隔为0</span></span><br><span class="line">        <span class="keyword">if</span> (minutesFlags[min]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        minutesFlags[min] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(minutesFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">boolean</span> minuteFlags[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minDiff = minuteFlags.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> first = minuteFlags.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minuteFlags.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minuteFlags[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                minDiff = Math.min(i - prev, minDiff);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prev = i;</span><br><span class="line">            first = Math.min(i, first);</span><br><span class="line">            last = Math.max(i, last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minDiff = Math.min(minuteFlags.length - last + first, minDiff);</span><br><span class="line">    <span class="keyword">return</span> minDiff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设输入时间的数目是n。上述代码中有两个for循环，主函数for的时间复杂度是O(n)；辅助函数helper的for循环执行次数为minuteFlags的长度1440，所以时间复杂度为O(1)。因此**总时间复杂度为O(n)<strong>。该方法需要创建一个长度为常数的辅助数组，</strong>空间复杂度为O(1)**。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="Java中stack的常用操作"><a href="#Java中stack的常用操作" class="headerlink" title="# Java中stack的常用操作"></a># Java中stack的常用操作</h3><table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>push(e)</td>
<td>元素e入栈</td>
</tr>
<tr>
<td>2</td>
<td>pop</td>
<td>位于栈顶的元素出栈，并返回该元素</td>
</tr>
<tr>
<td>3</td>
<td>peek</td>
<td>返回位于栈顶的元素，该元素不出栈</td>
</tr>
</tbody></table>
<h3 id="36-后缀表达式"><a href="#36-后缀表达式" class="headerlink" title="#36 后缀表达式"></a>#36 后缀表达式</h3><p>后缀表达式是一种算术表达式，它的操作符在操作数的后面。输入一个用字符串数组表示的后缀表达式，请输出该后缀表达式的计算结果。假设输入的一定是有效的后缀表达式。</p>
<p>例如：后缀表达式[“2”, “1”, “3”, “*”, “+”]对应的算术表达式是”2+1*3”，因此输出它的计算结果5。</p>
<p>分析：</p>
<p>先将操作数入栈，遇到操作符时从栈中取出两个操作数进行运算，运算结果再入栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    <span class="keyword">int</span> num1 = stack.pop();</span><br><span class="line">                    <span class="keyword">int</span> num2 = stack.pop();</span><br><span class="line">                    <span class="comment">// 注意: 先取出来的是第二个操作数</span></span><br><span class="line">                    stack.push(calculate(num2, num1, token));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    stack.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, String operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 + num2;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 - num2;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 * num2;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 / num2;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在进行减法(除法)运算时，注意先出栈的是减数(除数)，后出栈的是被减数(被除数)。</strong></p>
<p>如果输入数组的长度是n，那么对其中的每个字符串都有一次push操作：如果是操作符，那么还需要进行数学计算和两次pop操作。由于每个push操作、pop操作和数学计算都是O(1)，因此总体**时间复杂度是O(n)<strong>。由于栈中可能有O(n)个操作数，因此</strong>空间复杂度也是O(n)**。</p>
<h3 id="37-小行星碰撞"><a href="#37-小行星碰撞" class="headerlink" title="#37 小行星碰撞"></a>#37 小行星碰撞</h3><p>输入一个表示小行星的数组，数组中每个数字的绝对值表示行星的大小，数字的正负号表示小行星运动的方向，正号表示向右飞行，负号表示向左飞行。如果两颗小行星相撞，那么体积较小的小行星将会爆炸最终消失，体积较大的小行星不受影响。如果相撞的两颗小行星大小形同，那么他们都会爆炸消失。飞行方向相同的小行星永远不会相撞。求最终剩下的小行星。</p>
<p>例如：有6颗小行星[4,5,-6,4,8,5]，它们相撞之后最终剩下3颗小行星[-6,4,8]。</p>
<p>分析：</p>
<p>根据题设总结小行星相撞的规律。如果一颗小行星向右飞行，可以将它入栈。如果一颗小行星向左飞行，而位于栈顶的小行星向右飞行，那么它将与位于栈顶的小行星相撞。如果位于栈顶的小行星较小，那么它将爆炸消失(出栈)。然后判断它是否将与下一刻位于栈顶的小行星相撞。如果小行星与栈中所有小行星相撞之后仍然没有爆炸消失，那么将它入栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] asteroidCollision(<span class="keyword">int</span>[] asteroids) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> as : asteroids) &#123;</span><br><span class="line">        <span class="comment">// 栈中有向右飞行的小行星，当前小行星向左飞行，且体积更大</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() &gt; <span class="number">0</span> &amp;&amp; stack.peek() &lt; -as) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈中有向右飞行的小行星，与当前向左飞行的小行星体积相等</span></span><br><span class="line">        <span class="keyword">if</span> (!stack.empty() &amp;&amp; as &lt; <span class="number">0</span> &amp;&amp; stack.peek() == -as) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (as &gt; <span class="number">0</span> || stack.empty() || stack.peek() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            stack.push(as);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，每颗小行星只可能入栈、出栈一次，因此**时间复杂度是O(n)，空间复杂度也是O(n)**。</p>
<h3 id="38-每日温度"><a href="#38-每日温度" class="headerlink" title="#38 每日温度"></a>#38 每日温度</h3><p>输入一个数组，它的每个数字是某天的温度。请计算每天需要等几天才会出现更高的温度。</p>
<p>例如：输入数组[35,31,33,36,34]，那么输出为[3,1,1,0,0]。由于第1天的温度是35℃，要等3天才会出现更高的温度36℃，因此对应的输出为3。第4天的温度为36℃，后面没有更高的温度，它对应的输出是0。其他的以此类推。</p>
<p>分析：</p>
<p>用一个栈保存每天的温度在数组中的下标。每次从数组中读取一个温度，然后将其与栈中保存的温度(根据下标可以得到温度)进行比较。如果当前温度比位于栈顶的温度高，那么就能知道位于栈顶那一天需要等待几天才会出现更高的温度。然后出栈1次，将当前温度与下一个位于栈顶的温度进行比较。如果栈中已经没有比当前温度低的温度，则将当前温度在数组中的下标入栈。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>温度/℃</th>
<th>栈</th>
<th>等待天数</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>35</td>
<td>[0]</td>
<td>[0,0,0,0,0]</td>
<td>0入栈</td>
</tr>
<tr>
<td>2</td>
<td>31</td>
<td>[0,1]</td>
<td>[0,0,0,0,0]</td>
<td>比较31，35，1入栈</td>
</tr>
<tr>
<td>3</td>
<td>33</td>
<td>[0,2]</td>
<td>[0,1,0,0,0]</td>
<td>比较33, 31, 1出栈; 比较33, 35, 2入栈</td>
</tr>
<tr>
<td>4</td>
<td>36</td>
<td>[3]</td>
<td>[3,1,1,0,0]</td>
<td>比较36, 33, 2出栈; 比较36, 35, 1出栈; 3入栈</td>
</tr>
<tr>
<td>5</td>
<td>34</td>
<td>[3,4]</td>
<td>[3,1,1,0,0]</td>
<td>比较34, 36, 4入栈</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[temperatures.length];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = stack.pop();</span><br><span class="line">            result[prev] = i - prev;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设数组的长度是n，虽然有一个嵌套的二重循环，但它的**时间复杂度是O(n)<strong>，这是因为数组中每个温度入栈、出栈各1次。这种解法的</strong>空间复杂度也是O(n)**。</p>
<h3 id="39-直方图最大矩形面积"><a href="#39-直方图最大矩形面积" class="headerlink" title="#39 直方图最大矩形面积"></a>#39 直方图最大矩形面积</h3><p>直方图是由排列在同一基线上的相邻柱子组成的图形。输入一个由非负数组成的数组，数组中的数字是直方图中柱子的高。求直方图中最大矩形的面积。假设直方图中柱子的宽都为1。</p>
<p>例如：输入数组[3,2,5,4,6,1,4,2]，该直方图中最大矩形面积为12。(已4为顶, 宽为3的矩形)</p>
<p>分析：</p>
<p>如果直方图中一个矩形的下标从i开始，到j结束，那么这两根柱子之间的矩形(含两端的柱子)的宽是j-i+1。矩形的高是两根柱子之间所有主子最矮的高度。</p>
<p>这里介绍三种解法：</p>
<ol>
<li>蛮力法。如果能逐一找出直方图中所有的矩形并比较他们的面积，就能得到最大矩形面积。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea1</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = heights[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; heights.length; j++) &#123;</span><br><span class="line">            min = Math.min(min, heights[j]);</span><br><span class="line">            <span class="keyword">int</span> area = min * (j- i + <span class="number">1</span>);</span><br><span class="line">            maxArea = Math.max(maxArea, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入数组的长度为n，直方图中总共有O(n^2)个矩形，则计算每个矩形的面积需要O(1)的时间，这种解法的**时间复杂度是O(n^2)<strong>。此解法没用到额外的内存开销，因此</strong>空间复杂度是O(1)**。</p>
<ol start="2">
<li>分治法。仔细观察直方图矩阵可以发现，直方图中最矮的柱子在数组中的下标是5，它的高度是1。这个直方图的最大矩形有3种可能。<strong>第1种</strong>是矩形通过这根最矮的柱子。通过最矮的柱子的最大举行的高为1，宽为7。<strong>第2种</strong>是矩形的起始柱子和终止柱子都在最矮的柱子左侧，也就是从下标为0的柱子到下标为4的柱子的直方图的最大矩形。<strong>第3种</strong>是矩形的起始柱子和终止柱子都在最矮的柱子右侧，也就是从下标为6的柱子到下标为7的柱子的直方图的最大矩形。第2种和第3种从本质上来说和求整个直方图的最大矩形面积是同一个问题，可以调用递归函数解决。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea2</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(heights, <span class="number">0</span>, heights.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果相等，代表只有一列</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">1</span> == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> heights[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minIndex = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heights[i] &lt; heights[minIndex]) &#123;</span><br><span class="line">            minIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为预设的范围不包括end，所以这里end-start不需要加1</span></span><br><span class="line">    <span class="keyword">int</span> area = (end - start) * heights[minIndex];</span><br><span class="line">    <span class="keyword">int</span> left = helper(heights, start, minIndex);</span><br><span class="line">    <span class="keyword">int</span> right = helper(heights, minIndex + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    area = Math.max(area, left);</span><br><span class="line">    <span class="keyword">return</span> Math.max(area, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>单调栈法</p>
<p>非常高效、巧妙的解法。这种解法用一个栈保存直方图的柱子，并且栈中的柱子高度是递增排序的。为了方便计算矩形的宽度，栈中保存的是柱子在数组中的下标，可以根据下标得到柱子的高度。</p>
<p>这种解法的基本思想是确保保存在栈中的直方图的柱子的高度是递增排序的。假设从左到右逐一扫描数组中的每根柱子，如果当前柱子的高度大于位于栈顶的柱子的高度，那么将该柱子的下标入栈；否则，将位于栈顶的下标出栈，并且计算以位于栈顶的柱子为顶的最大矩形的面积。</p>
<p>一番操作过后，以每个柱子为顶的最大直方图面积都会被计算。</p>
<p><strong>细节：如果某下标为i的柱子左侧没有柱子，这意味着它的左侧所有的柱子都比它高。因此，可以想象在下标为-1的位置有一根比它矮的柱子。</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea3</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">            <span class="comment">// 因为不包括第i根柱子，所以要-1</span></span><br><span class="line">            <span class="keyword">int</span> width = i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            maxArea = Math.max(maxArea, height * width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">        <span class="keyword">int</span> width = heights.length - stack.peek() - <span class="number">1</span>;</span><br><span class="line">        maxArea = Math.max(maxArea, height * width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同方法二，**时间复杂度和空间复杂度都为O(n)**。</p>
<h3 id="40-矩阵中国的最大矩形"><a href="#40-矩阵中国的最大矩形" class="headerlink" title="#40 矩阵中国的最大矩形"></a>#40 矩阵中国的最大矩形</h3><p>请在一个由0、1组成的矩阵中找出最大只包含1的矩形并输出它的面积。</p>
<p>例如：</p>
<p>[[1,0,1,0,0],</p>
<p>[0,0,1,1,1],</p>
<p>[1,1,1,1,1],</p>
<p>[1,0,0,1,0]]</p>
<p>此矩阵中最大的只包含1的矩阵面积为6。</p>
<p>分析：</p>
<p>可以把一个有n行的矩阵转换成n个直方图，进而转换成求直方图最大矩形面积的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    heights[i] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    heights[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxArea = Math.max(maxArea, largestRectangleArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">            <span class="comment">// 因为不包括第i根柱子，所以要-1</span></span><br><span class="line">            <span class="keyword">int</span> width = i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            maxArea = Math.max(maxArea, height * width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">        <span class="keyword">int</span> width = heights.length - stack.peek() - <span class="number">1</span>;</span><br><span class="line">        maxArea = Math.max(maxArea, height * width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设输入矩阵的大小为mxn，该矩阵可以转换成m个直方图，如果采用单调栈法，那么求每个直方图的最大矩形面积需要O(n)的时间，因此这种解法的**时间复杂度为O(mn)<strong>。使用单调栈法计算直方图中最大矩阵的面积需要O(n)的空间，同时要一个长度为n的数组heights，用于记录直方图中主子的高度，因此这种解法的</strong>空间复杂度是O(n)**。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="Java中Queue的常用操作"><a href="#Java中Queue的常用操作" class="headerlink" title="#Java中Queue的常用操作"></a>#Java中Queue的常用操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>抛异常</th>
<th>不抛异常</th>
</tr>
</thead>
<tbody><tr>
<td>插入元素</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>删除元素</td>
<td>remove</td>
<td>poll</td>
</tr>
<tr>
<td>返回最前面的元素</td>
<td>element</td>
<td>peek</td>
</tr>
</tbody></table>
<p>在Java中实现了接口Queue的常用类型有LinkedList, ArrayDeque和PriorityQueue等。但PriorityQueue并不是真正的队列。</p>
<h3 id="41-滑动窗口的平均值"><a href="#41-滑动窗口的平均值" class="headerlink" title="#41 滑动窗口的平均值"></a>#41 滑动窗口的平均值</h3><p>请实现如下类型MovingAverage，计算滑动窗口中所有数字的平均值，该类型构造函数的参数确定滑动窗口的大小，每次调用成员函数next时都会在滑动窗口中添加一个整数，并返回滑动窗口中所有数字的平均值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>分析：</p>
<p>滑动窗口满足先进先出的特点，因此可以用队列来实现。记录当前窗口的所有数字之和(用sum表示)，那么插入一个新的数字v1之后，窗口中的所有数字之和就是sum+v1。如果此时窗口的大小超出了限制，还需要删除一个数字v2，那么窗口中的所有数字之和是sum+v1-v2。因此，最多只需要一次假发和一次减法就能求出窗口中所有数字之和，**时间复杂度为O(1)**。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        nums = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        nums.offer(val);</span><br><span class="line">        sum += val;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &gt; capacity) &#123;</span><br><span class="line">            sum -= nums.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) sum / nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="42-最近请求次数"><a href="#42-最近请求次数" class="headerlink" title="#42 最近请求次数"></a>#42 最近请求次数</h3><p>请设计如下实现类型RecentCounter，它是统计过去3000ms内的请求次数的计数器。该类型的构造函数RecentCounter初始化计数器，请求数初始化为0; 函数ping(int t)在时间t添加一个新请求(t表示以毫秒为单位的时间)，并返回过去3000ms内(时间范围为[t-3000,t])发生的所有请求数。假设每次调用函数ping的参数t都比之前调用的参数值大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>分析：</p>
<p>最近请求次数，同样符合先进先出原则，可以用队列来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; times;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> windowSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.times = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.windowSize = <span class="number">3000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        times.offer(t);</span><br><span class="line">        <span class="keyword">while</span> (times.peek() &lt; t - windowSize) &#123;</span><br><span class="line">            times.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> times.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设计数器的时间窗口大小是w毫秒，其中记录的时间的递增的，那么时间窗口中记录的时间的数目是O(w)，因此**空间复杂度是O(w)<strong>。每当收到一个新的请求ping时，由于可能需要删除O(w)个已经滑出时间窗口的请求，因此</strong>时间复杂度也是O(w)**。由于此题中w是个常数，因此可以认为时间复杂度和空间复杂度都是O(1)。</p>
<h3 id="二叉树的广度优先搜索"><a href="#二叉树的广度优先搜索" class="headerlink" title="#二叉树的广度优先搜索"></a>#二叉树的广度优先搜索</h3><p>通常基于队列来实现二叉树的广度优先搜索。从二叉树的根节点开始，先把根节点放入一个队列之中，然后每次从队列中取出一个节点遍历。如果该节点有左右子节点，则分别将他们添加到队列当中。重复此过程直到所有节点都遍历完位置，此时队列为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        result.add(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设一棵二叉树有n个节点。由于逐层遍历每个节点，因此上述代码的时间复杂度时O(n)。如果把父节点已经遍历到但自身尚未到达的节点存储在队列之中，那么最多需要存储一层的节点。在一棵满的二叉树中，最下面一层的节点数最多，最多可能有(n+1)/2个节点，因此二叉树广度优先搜索的空间复杂度时O(n)。</p>
<h3 id="43-在完全二叉树中添加节点"><a href="#43-在完全二叉树中添加节点" class="headerlink" title="#43 在完全二叉树中添加节点"></a>#43 在完全二叉树中添加节点</h3><p>在完全二叉树中，除最后一层之外其他层的节点都是满的。最后一层的节点可能不满，该层所有的节点尽可能向左边靠拢。</p>
<p>实现数据结构CBTInserter有如下三种方法。</p>
<ul>
<li>构造函数CBTiNSERTER(TreeNode root)，用一棵完全二叉树的根节点初始化该数据结构。</li>
<li>函数insert(int v)在完全二叉树中添加一个值为v的节点，并返回被插入节点的父节点。</li>
<li>函数get_root()返回完全二叉树的根节点。</li>
</ul>
<p>分析：</p>
<p>按照广度优先搜索的思路，找出第一个缺少子节点的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CBTInserter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;TreeNode&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CBTInserter</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line"></span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.peek().left != <span class="keyword">null</span> &amp;&amp; queue.peek().right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        TreeNode parent = queue.peek();</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.left = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = node;</span><br><span class="line"></span><br><span class="line">            queue.poll();</span><br><span class="line">            queue.offer(parent.left);</span><br><span class="line">            queue.offer(parent.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parent.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">get_root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造函数本质上来说是按照广度优先搜索的顺序找出二叉树中所有既有左子节点又有右子节点的节点，因此**时间复杂度是O(n)<strong>。调用函数insert在完全二叉树中每添加一个节点最多只需要在队列中删除一个节点并添加两个节点。通常，队列的插入、删除操作的时间复杂度都是O(1)，因此函数</strong>insert的时间复杂度是O(1)<strong>。最后，</strong>get_root的时间复杂度是O(1)<strong>。需要一个队列来实现广度优先搜索算法保存缺少左子节点或右子节点的节点，</strong>空间复杂度是O(n)**。</p>
<h3 id="44-二叉树中每层的最大值"><a href="#44-二叉树中每层的最大值" class="headerlink" title="#44 二叉树中每层的最大值"></a>#44 二叉树中每层的最大值</h3><p>输入一棵二叉树，请找出二叉树中每层的最大值。</p>
<p>分析：</p>
<p>这个题目提到了二叉树的层。既然要找出二叉树中每层的最大值，就要逐层遍历二叉树，也就是说，按照广度优先的顺序遍历二叉树。这里介绍两种解法：</p>
<ol>
<li><p>用一个队列实现二叉树的广度优先搜索：</p>
<p>由于要找出二叉树中每层的最大值，因此在遍历时需要知道每层什么时候开始、什么时候结束。如果还是和前面一样只用一个队列来保存尚未遍历到的节点，那么有可能位于不同的两层的节点同时在队列之中。此时，每次从队列之中取出节点来遍历时就需要知道这个节点位于哪一层。解决办法之一是计数，<strong>用current记录当前层节点的数量，用next记录下一层节点的数量</strong>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">largestValues1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            current = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 取出当前层节点并更新计数变量</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            current--;</span><br><span class="line">            max = Math.max(max, node.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前层节点遍历完毕，更新变量值</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(max);</span><br><span class="line">                max = Integer.MIN_VALUE;</span><br><span class="line">                current = next;</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>用两个队列实现二叉树的广度优先搜索：</p>
<p>用两个队列分别存放不同层的节点。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">largestValues2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue1.offer(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue1.poll();</span><br><span class="line">        max = Math.max(max, node.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            result.add(max);</span><br><span class="line">            max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过比较上述两种思路的代码不难发现，是用两个队列的代码逻辑稍微简单一些。</p>
<p>每个节点需要入队一次，**时间复杂度为O(n)<strong>。队列中最多存储一层的全部节点，如果是满二叉树，则</strong>最坏空间复杂度为O(n)**。</p>
<h3 id="45-二叉树最低层最左边的值"><a href="#45-二叉树最低层最左边的值" class="headerlink" title="#45 二叉树最低层最左边的值"></a>#45 二叉树最低层最左边的值</h3><p>如何在一棵二叉树中找出它最低层最左边节点的值？假设二叉树中最少有一个节点。</p>
<p>分析：</p>
<p>利用广度优先搜索的思路，遍历所有节点。用一个变量bottomLeft来保存每一层最左边的节点的值。在遍历二叉树时，每当遇到新的一层时就将变量bottomLeft的值更新为该层第1个节点的值。当整颗二叉树都被遍历完之后，变量bottomLeft的值就是最后一层的第1个节点的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue1.offer(root);</span><br><span class="line">    <span class="keyword">int</span> bottomLeft = root.val;</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue1.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">                bottomLeft = queue1.peek().val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bottomLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="46-二叉树的右侧视图"><a href="#46-二叉树的右侧视图" class="headerlink" title="#46 二叉树的右侧视图"></a>#46 二叉树的右侧视图</h3><p>给定一棵二叉树，如果站在该二叉树的右侧，那么从上到下看到的节点构成二叉树的右侧试图。(每层最右边的节点)</p>
<p>分析：</p>
<p>广度优先搜索遍历二叉树，存储每层最后一个节点的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; view = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue1.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue1.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue2.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">            view.add(node.val);</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树的深度优先搜索"><a href="#二叉树的深度优先搜索" class="headerlink" title="#二叉树的深度优先搜索"></a>#二叉树的深度优先搜索</h3><p>二叉树的深度优先搜索又可以细分为中序遍历、前序遍历和后序遍历。</p>
<p><img src="%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211112175208698.png" alt="image-20211112175208698"></p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>遍历顺序：4，2，5，1，6，3，7</p>
<p>中序遍历的递归实现很直观：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    dfs(root, nodes);</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; nodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dfs(root.left, nodes);</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        dfs(root.right, nodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归有固有的局限性。如果二叉树的深度(从根节点到叶节点的最长路径的长度)太大，那么递归的代码可能会导致调用栈溢出的问题。<strong>可以用栈把递归的代码改写成迭代的代码。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        nodes.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量cur表示当前遍历的节点。如果该节点有左子节点，按照中序遍历的顺序，应该先遍历它的左子树。于是顺着指向左子节点的指针一直向下移动，并将沿途遇到的每个节点都添加到栈stack之中。第二个while循环结束之后，最左子节点(顺着指向左子节点的指针到达的最远的节点)位于栈顶，将它从栈顶出栈并遍历。按照中序遍历的顺序，在遍历一个节点之后再遍历它的右子树，因此把变量cur指向它的右子节点，开始下一轮的遍历，直到所有的节点都遍历完为止。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Toby</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dudu12091.github.io/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">https://dudu12091.github.io/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dudu12091.github.io" target="_blank">Tobyy的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="post_share"><div class="social-share" data-image="/img/%E5%89%91%E6%8C%87offer_1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/09/29/linux_hsp/"><img class="next-cover" src="/img/linux_hsp.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">linux韩顺平学习笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/tit.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Toby</div><div class="author-info__description">欢迎~</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dudu12091"><i></i><span>Toby's GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dudu12091" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:443126857@qq.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">announcement</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">整数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">#1 整数除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">#2 二进制加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%89%8Dn%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BD%A2%E5%BC%8F%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">#3 前n个数字二进制形式中1的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">1.4.</span> <span class="toc-text">#4 只出现一次的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF"><span class="toc-number">1.5.</span> <span class="toc-text">#5 单词长度的最大乘积</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">#双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-number">2.2.</span> <span class="toc-text">#6 排序数组中的两个数字之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA0%E7%9A%843%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">2.3.</span> <span class="toc-text">#7 数组中和为0的3个数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%92%8C%E5%A4%A7%E4%BA%8E%E6%88%96%E7%AD%89%E4%BA%8Ek%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.</span> <span class="toc-text">#8 和大于或等于k的最短子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.5.</span> <span class="toc-text">#9 乘积小于k的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E6%95%B0%E7%BB%84%E6%95%B0%E5%AD%97%E6%B1%82%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C"><span class="toc-number">2.6.</span> <span class="toc-text">#累加数组数字求子数组之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.7.</span> <span class="toc-text">#10 和为k的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-0%E5%92%8C1%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.8.</span> <span class="toc-text">#11 0和1个数相同的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89"><span class="toc-number">2.9.</span> <span class="toc-text">#12 左右两边子数组的和相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BA%8C%E7%BB%B4%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-number">2.10.</span> <span class="toc-text">#13 二维子矩阵的数字之和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="toc-number">3.1.</span> <span class="toc-text">#双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D"><span class="toc-number">3.2.</span> <span class="toc-text">#14 字符串中的变位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D"><span class="toc-number">3.3.</span> <span class="toc-text">#15 字符串中所有的变位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.4.</span> <span class="toc-text">#16 不含重复字符的最长子字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.</span> <span class="toc-text">#17 包含所有字符串的最短字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%96%87"><span class="toc-number">3.6.</span> <span class="toc-text">#18 有效的回文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E6%9C%80%E5%A4%9A%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87"><span class="toc-number">3.7.</span> <span class="toc-text">#19 最多删除一个字符得到回文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">#20 回文子字符串的个数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">#单向链表的简单定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">#哨兵节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="toc-number">4.3.</span> <span class="toc-text">#双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">4.4.</span> <span class="toc-text">#21 删除倒数第k个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9"><span class="toc-number">4.5.</span> <span class="toc-text">#22 链表中环的入口节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC1%E4%B8%AA%E9%87%8D%E5%90%88%E8%8A%82%E7%82%B9"><span class="toc-number">4.6.</span> <span class="toc-text">#23 两个链表的第1个重合节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">4.7.</span> <span class="toc-text">#24 反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0"><span class="toc-number">4.8.</span> <span class="toc-text">#25 链表中的数字相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="toc-number">4.9.</span> <span class="toc-text">#26 重排链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">4.10.</span> <span class="toc-text">#27 回文链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%92%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">4.11.</span> <span class="toc-text">双向链表和循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%B1%95%E5%B9%B3%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">4.12.</span> <span class="toc-text">#28 展平多级双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">4.13.</span> <span class="toc-text">#29 排序的循环链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E9%83%BD%E6%98%AFO-1-%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">#30 插入、删除和随机访问都是O(1)的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-number">5.2.</span> <span class="toc-text">#31 最近最少使用缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%9C%89%E6%95%88%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D"><span class="toc-number">5.3.</span> <span class="toc-text">#32 有效的变位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84"><span class="toc-number">5.4.</span> <span class="toc-text">#33 变位词组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E5%A4%96%E6%98%9F%E8%AF%AD%E8%A8%80%E6%98%AF%E5%90%A6%E6%8E%92%E5%BA%8F"><span class="toc-number">5.5.</span> <span class="toc-text">#34 外星语言是否排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE"><span class="toc-number">5.6.</span> <span class="toc-text">#35 最小时间差</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">6.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%ADstack%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">6.1.</span> <span class="toc-text"># Java中stack的常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">#36 后缀表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E"><span class="toc-number">6.3.</span> <span class="toc-text">#37 小行星碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-number">6.4.</span> <span class="toc-text">#38 每日温度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF"><span class="toc-number">6.5.</span> <span class="toc-text">#39 直方图最大矩形面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="toc-number">6.6.</span> <span class="toc-text">#40 矩阵中国的最大矩形</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%ADQueue%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.</span> <span class="toc-text">#Java中Queue的常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">7.2.</span> <span class="toc-text">#41 滑动窗口的平均值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">#42 最近请求次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">7.4.</span> <span class="toc-text">#二叉树的广度优先搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%9C%A8%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="toc-number">7.5.</span> <span class="toc-text">#43 在完全二叉树中添加节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%AF%8F%E5%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">7.6.</span> <span class="toc-text">#44 二叉树中每层的最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E4%BD%8E%E5%B1%82%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%80%BC"><span class="toc-number">7.7.</span> <span class="toc-text">#45 二叉树最低层最左边的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7%E8%A7%86%E5%9B%BE"><span class="toc-number">7.8.</span> <span class="toc-text">#46 二叉树的右侧视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">8.1.</span> <span class="toc-text">#二叉树的深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.1.</span> <span class="toc-text">中序遍历</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="剑指offer刷题-数据结构与算法篇"><img src="/img/%E5%89%91%E6%8C%87offer_1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="剑指offer刷题-数据结构与算法篇"/></a><div class="content"><a class="title" href="/2021/10/16/%E5%89%91%E6%8C%87offer_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="剑指offer刷题-数据结构与算法篇">剑指offer刷题-数据结构与算法篇</a><time datetime="2021-10-16T16:30:46.584Z" title="发表于 2021-10-16 17:30:46">2021-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/29/linux_hsp/" title="linux韩顺平学习笔记"><img src="/img/linux_hsp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux韩顺平学习笔记"/></a><div class="content"><a class="title" href="/2021/09/29/linux_hsp/" title="linux韩顺平学习笔记">linux韩顺平学习笔记</a><time datetime="2021-09-29T22:48:36.000Z" title="发表于 2021-09-29 23:48:36">2021-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/29/hello-world/" title="Hello World"><img src="/img/tit.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2021/09/29/hello-world/" title="Hello World">Hello World</a><time datetime="2021-09-29T05:37:25.447Z" title="发表于 2021-09-29 06:37:25">2021-09-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Toby</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '6738eac81c233ff71337',
      clientSecret: '981b5f973b7b3d150cf369182ffc8b4061452fa5',
      repo: 'hexo-comments',
      owner: 'dudu12091',
      admin: ['dudu12091'],
      id: 'af23dcd66b95b496dd7f95c6dcdec408',
      language: 'en',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>